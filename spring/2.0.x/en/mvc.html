<html>
<!-- Mirrored from static.springframework.org/spring/docs/2.0.x/reference/mvc.html by HTTrack Website Copier/3.x [XR&CO'2005], Tue, 17 Oct 2006 17:46:02 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;13.&nbsp;Web MVC framework</title><link rel="stylesheet" href="http://static.springframework.org/spring/docs/2.0.x/styles/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><link rel="home" href="index.html" title="The Spring Framework - Reference Documentation"><link rel="up" href="pt03.html" title="Part&nbsp;III.&nbsp;The Web"><link rel="previous" href="pt03.html" title="Part&nbsp;III.&nbsp;The Web"><link rel="next" href="view.html" title="Chapter&nbsp;14.&nbsp;Integrating view technologies"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns="http://www.w3.org/TR/xhtml1/transitional" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://www.springframework.org/" title="The Spring Framework"><img style="border:none;" src="images/xdev-spring_logo.jpg"></a><a style="border:none;" href="http://www.interface21.com/" title="Interface21 - Spring from the Source"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/i21-banner-rhs.jpg"></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="mvc"></a>Chapter&nbsp;13.&nbsp;Web MVC framework</h2></div></div>
   <table align="center">
<tr>
<td>
<script type="text/javascript"><!--
google_ad_client = "pub-2627642070897863";
google_ad_width = 336;
google_ad_height = 280;
google_ad_format = "336x280_as";
google_ad_type = "text_image";
//2006-10-13: com_336x280
google_ad_channel = "7652836435";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
<td>
<script type="text/javascript"><!--
google_ad_client = "pub-2627642070897863";
google_ad_width = 336;
google_ad_height = 280;
google_ad_format = "336x280_as";
google_ad_type = "text_image";
//2006-10-13: com_336x280
google_ad_channel = "7652836435";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</tr>
</table>
   <div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-introduction"></a>13.1.&nbsp;Introduction</h2></div></div><div></div></div><p>Spring's Web MVC framework is designed around a <tt class="classname">DispatcherServlet</tt>
    that dispatches requests to handlers, with configurable handler mappings,
    view resolution, locale and theme resolution as well as support for upload
    files. The default handler is a very simple <tt class="interfacename">Controller</tt> interface, just
    offering a <tt class="literal">ModelAndView handleRequest(request,response)</tt>
    method. This can already be used for application controllers, but you will
    prefer the included implementation hierarchy, consisting of, for example
    <tt class="classname">AbstractController</tt>,
    <tt class="classname">AbstractCommandController</tt> and
    <tt class="classname">SimpleFormController</tt>. Application controllers will
    typically be subclasses of those. Note that you can choose an appropriate
    base class: if you don't have a form, you don't need a form controller.
    This is a major difference to Struts.</p><div class="sidebar"><a name="mvc-open-for-extension"></a><p class="title"><b>&#8220;<span class="quote">Open for extension...</span>&#8221;</b></p><p>One of the overarching design principles in Spring Web MVC (and in Spring in general)
        is the &#8220;<span class="quote"><span class="emphasis"><em>Open for extension, closed for modification</em></span></span>&#8221;
        principle.</p><p>The reason that this principle is being mentioned here is because a number
        of methods in the core classes in Spring Web MVC are marked <tt class="literal">final</tt>.
        This means of course that you as a developer cannot override these methods to
        supply your own behavior... this is <span class="emphasis"><em>by design</em></span> and has not
        been done arbitrarily to annoy.</p><p>The book 'Expert Spring Web MVC and Web Flow' by Seth Ladd and others explains this
        principle and the reasons for adhering to it in some depth on page 117 (first edition)
        in the section entitled 'A Look At Design'.</p><p>If you don't have access to the aforementioned book, then the following article
        may be of interest the next time you find yourself going
        &#8220;<span class="quote">Gah! Why can't I override this method?</span>&#8221; (if indeed you ever do).</p><div class="orderedlist"><ol type="1"><li><p><a href="http://www.objectmentor.com/publications/ocp.pdf" target="_top">Bob Martin, The Open-Closed Principle (PDF)</a></p></li></ol></div></div><p>Spring Web MVC allows you to use any object as a command or form object -
    there is no need to implement a framework-specific interface or base class.
    Spring's data binding is highly flexible: for example, it treats type mismatches
    as validation errors that can be evaluated by the application, not as system
    errors. All this means that you don't need to duplicate your business objects'
    properties as simple, untyped strings in your form objects just to be able to
    handle invalid submissions, or to convert the Strings properly. Instead, it is
    often preferable to bind directly to your business objects. This is another
    major difference to Struts which is built around required base classes such as
    <tt class="classname">Action</tt> and <tt class="classname">ActionForm</tt>.</p><p>Compared to WebWork, Spring has more differentiated object roles. It
    supports the notion of a <tt class="interfacename">Controller</tt>, an optional
    command or form object, and a model that gets passed to the view. The model will
    normally include the command or form object but also arbitrary reference data;
    instead, a WebWork <tt class="interfacename">Action</tt> combines all those
    roles into one single object. WebWork does allow you to use existing business objects
    as part of your form, but only by making them bean properties of the respective
    <tt class="interfacename">Action</tt> class. Finally, the same
    <tt class="interfacename">Action</tt> instance that handles the request is used for
    evaluation and form population in the view. Thus, reference data needs to
    be modeled as bean properties of the <tt class="interfacename">Action</tt> too.
    These are (arguably) too many roles for one object.</p><p>Spring's view resolution is extremely flexible. A
    <tt class="interfacename">Controller</tt> implementation can even write a view
    directly to the response (by returning <tt class="literal">null</tt> for the
    <tt class="classname">ModelAndView</tt>). In the normal case, a
    <tt class="classname">ModelAndView</tt> instance consists of a view name and a model
    <tt class="interfacename">Map</tt>, which contains bean names and corresponding
    objects (like a command or form, containing reference data). View name resolution
    is highly configurable, either via bean names, via a properties file, or via your
    own <tt class="interfacename">ViewResolver</tt> implementation. The fact that the
    model (the M in MVC) is based on the <tt class="interfacename">Map</tt> interface
    allows for the complete abstraction of the view technology. Any renderer can be
    integrated directly, whether JSP, Velocity, or any other rendering technology.
    The model <tt class="interfacename">Map</tt> is simply transformed into an
    appropriate format, such as JSP request attributes or a Velocity template model.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-introduction-pluggability"></a>13.1.1.&nbsp;Pluggability of other MVC implementations</h3></div></div><div></div></div><p>There are several reasons why some projects will prefer to use
      other MVC implementations. Many teams expect to leverage their existing
      investment in skills and tools. In addition, there is a large body of
      knowledge and experience avalailable for the Struts framework. Thus, if
      you can live with Struts' architectural flaws, it can still be a viable
      choice for the web layer; the same applies to WebWork and other web MVC
      frameworks.</p><p>If you don't want to use Spring's web MVC, but intend to leverage
      other solutions that Spring offers, you can integrate the web MVC
      framework of your choice with Spring easily. Simply start up a Spring
      root application context via its <tt class="classname">ContextLoaderListener</tt>,
      and access it via its <tt class="interfacename">ServletContext</tt> attribute
      (or Spring's respective helper method) from within a Struts or WebWork action.
      Note that there aren't any "plugins" involved, so no dedicated integration
      is necessary. From the web layer's point of view, you'll simply use Spring
      as a library, with the root application context instance as the entry point.</p><p>All your registered beans and all of Spring's services can be at
      your fingertips even without Spring's web MVC. Spring doesn't compete
      with Struts or WebWork in this scenario, it just addresses the many
      areas that the pure web MVC frameworks don't, from bean configuration to
      data access and transaction handling. So you are able to enrich your
      application with a Spring middle tier and/or data access tier, even if
      you just want to use, for example, the transaction abstraction with JDBC
      or Hibernate.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-features"></a>13.1.2.&nbsp;Features of Spring Web MVC</h3></div></div><div></div></div><div class="sidebar"><p class="title"><b>Spring WebFlow</b></p><p>Spring Web Flow (SWF) aims to be the best solution for the management of web application page flow.</p><p>SWF integrates with existing frameworks like Spring MVC, Struts, and JSF, in both servlet and
	portlet environments. If you have a business process (or processes) that would benefit from a
	conversational model as opposed to a purely request model, then SWF may be the solution.</p><p>SWF allows you to capture logical page flows as self-contained modules that are reusable in different
	situations, and as such is ideal for building web application modules that guide the user through controlled
	navigations that drive business processes.</p><p>For more information about SWF, consult the
    <a href="http://opensource.atlassian.com/confluence/spring/display/WEBFLOW/Home/" target="_top">Spring WebFlow site</a>.</p></div><p>Spring's web module provides a wealth of unique web support
      features, including:</p><div class="itemizedlist"><ul type="disc"><li><p>Clear separation of roles - controller, validator, command
          object, form object, model object, <tt class="classname">DispatcherServlet</tt>,
          handler mapping, view resolver, etc. Each role can be fulfilled by a
          specialized object.</p></li><li><p>Powerful and straightforward configuration of both framework
          and application classes as JavaBeans, including easy referencing
          across contexts, such as from web controllers to business objects
          and validators.</p></li><li><p>Adaptability, non-intrusiveness. Use whatever controller
          subclass you need (plain, command, form, wizard, multi-action, or a
          custom one) for a given scenario instead of deriving from a single
          controller for everything.</p></li><li><p>Reusable business code - no need for duplication. You can use
          existing business objects as command or form objects instead of
          mirroring them in order to extend a particular framework base
          class.</p></li><li><p>Customizable binding and validation - type mismatches as
          application-level validation errors that keep the offending value,
          localized date and number binding, etc instead of String-only form
          objects with manual parsing and conversion to business
          objects.</p></li><li><p>Customizable handler mapping and view resolution - handler
          mapping and view resolution strategies range from simple URL-based
          configuration, to sophisticated, purpose-built resolution
          strategies. This is more flexible than some web MVC frameworks which
          mandate a particular technique.</p></li><li><p>Flexible model transfer - model transfer via a name/value
          <tt class="interfacename">Map</tt> supports easy integration with
          any view technology.</p></li><li><p>Customizable locale and theme resolution, support for JSPs
          with or without Spring tag library, support for JSTL, support for
          Velocity without the need for extra bridges, etc.</p></li><li><p>A simple yet powerful JSP tag library known as the Spring tag library
          that provides support for features such as data binding and themes. The
          custom tags allow for maximum flexibility in terms of markup code.
          For information on the tag library descriptor, see the appendix entitled
          <a href="spring.tld.html" title="Appendix&nbsp;D.&nbsp;spring.tld">Appendix&nbsp;D, <i>spring.tld</i></a></p></li><li><p>A JSP form tag library, introduced in Spring 2.0, that makes writing
          forms in JSP pages much easier. For information on the tag library descriptor,
          see the appendix entitled <a href="spring-form.tld.html" title="Appendix&nbsp;E.&nbsp;spring-form.tld">Appendix&nbsp;E, <i>spring-form.tld</i></a></p></li><li><p>Beans whose lifecycle is scoped to the current HTTP request or HTTP
          <tt class="interfacename">Session</tt>. This is not a specific feature of
          Spring MVC itself, but rather of the <tt class="interfacename">WebApplicationContext</tt>
          container(s) that Spring MVC uses. These bean scopes are described in detail in
          the section entitled <a href="beans.html#beans-factory-scopes-other" title="3.4.3.&nbsp;The other scopes">Section&nbsp;3.4.3, &#8220;The other scopes&#8221;</a></p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-servlet"></a>13.2.&nbsp;The <tt class="classname">DispatcherServlet</tt></h2></div></div><div></div></div><p>Spring's web MVC framework is, like many other web MVC frameworks,
    request-driven, designed around a central servlet that dispatches requests
    to controllers and offers other functionality facilitating the development
    of web applications. Spring's <tt class="classname">DispatcherServlet</tt>
    however, does more than just that. It is completely integrated with the
    Spring IoC container and as such allows you to use every other feature that
    Spring has.</p><p>The request processing workflow of the Spring Web MVC
    <tt class="classname">DispatcherServlet</tt> is illustrated in the following diagram.
    The pattern-savvy reader will recognize that the <tt class="classname">DispatcherServlet</tt>
    is an expression of the &#8220;<span class="quote">Front Controller</span>&#8221; design pattern (this is a
    pattern that Spring Web MVC shares with many other leading web frameworks).</p><p>
		</p><div class="mediaobject" align="center"><img src="images/mvc.png" align="middle"><div class="caption"><p>The requesting processing workflow in Spring Web MVC (high level)</p></div></div><p>
	</p><p>The <tt class="classname">DispatcherServlet</tt> <span class="emphasis"><em>is</em></span> an
    actual <tt class="interfacename">Servlet</tt> (it inherits from the
    <tt class="classname">HttpServlet</tt> base class), and as such is declared in the
    <tt class="literal">web.xml</tt> of your web application. Requests that you want the
    <tt class="classname">DispatcherServlet</tt> to handle will have to be mapped using
    a URL mapping in the same <tt class="literal">web.xml</tt> file. This is standard J2EE
    servlet configuration; an example of such a <tt class="classname">DispatcherServlet</tt>
    declaration and mapping can be found below.</p><pre class="programlisting">&lt;web-app&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;example&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;example&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</pre><p>In the example above, all requests ending with <tt class="literal">.form</tt>
    will be handled by the <tt class="literal">'example'</tt>
    <tt class="classname">DispatcherServlet</tt>. This is only the first step in
    setting up Spring Web MVC... the various beans used by the Spring Web MVC framework (over
    and above the <tt class="classname">DispatcherServlet</tt> itself) now need to be
    configured.</p><p>As detailed in the section entitled <a href="beans.html#context-introduction" title="3.8.&nbsp;The ApplicationContext">Section&nbsp;3.8, &#8220;The ApplicationContext&#8221;</a>,
    <tt class="interfacename">ApplicationContext</tt> instances in Spring can be scoped.
    In the web MVC framework, each <tt class="classname">DispatcherServlet</tt> has its own
    <tt class="interfacename">WebApplicationContext</tt>, which inherits all the beans
    already defined in the root <tt class="interfacename">WebApplicationContext</tt>.
	These inherited beans defined can be overridden in the servlet-specific scope,
    and new scope-specific beans can be defined local to a given servlet instance.</p><p>
		</p><div class="mediaobject" align="center"><img src="images/mvc-contexts.gif" align="middle"><div class="caption"><p>Context hierarchy in Spring Web MVC</p></div></div><p>
	</p><p>The framework will, on initialization of a <tt class="classname">DispatcherServlet</tt>,
    <span class="emphasis"><em>look for a file named <tt class="literal">[servlet-name]-servlet.xml</tt></em></span>
    in the <tt class="literal">WEB-INF</tt> directory of your web application and create the beans
    defined there (overriding the definitions of any beans defined with the same name in the
    global scope).</p><p>Consider the following <tt class="classname">DispatcherServlet</tt> servlet configuration
    (in the <tt class="literal">'web.xml'</tt> file.)</p><pre class="programlisting">&lt;web-app&gt;
    ...
    &lt;servlet&gt;
        &lt;servlet-name&gt;<span class="bold"><b>golfing</b></span>&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;<span class="bold"><b>golfing</b></span>&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre><p>With the above servlet configuration in place, you will need to have a file called
    <tt class="literal">'/WEB-INF/<span class="bold"><b>golfing</b></span>-servlet.xml'</tt> in your
    application; this file will contain all of your <span class="emphasis"><em>Spring Web MVC-specific</em></span>
    components (beans). The exact location of this configuration file can be changed via a
    servlet initialization parameter (see below for details).</p><p>The <tt class="interfacename">WebApplicationContext</tt> is an extension of the
    plain <tt class="interfacename">ApplicationContext</tt> that has some extra features
    necessary for web applications. It differs from a normal
    <tt class="interfacename">ApplicationContext</tt> in that it is capable of resolving
    themes (see <a href="mvc.html#mvc-themeresolver" title="13.7.&nbsp;Using themes">Section&nbsp;13.7, &#8220;Using themes&#8221;</a>), and that it knows which servlet
    it is associated with (by having a link to the <tt class="interfacename">ServletContext</tt>).
    The <tt class="interfacename">WebApplicationContext</tt> is bound in the
    <tt class="interfacename">ServletContext</tt>, and by using static methods on the
    <tt class="classname">RequestContextUtils</tt> class you can always lookup the
    <tt class="interfacename">WebApplicationContext</tt> in case you need access to it.</p><p>The Spring <tt class="classname">DispatcherServlet</tt> has a couple of special beans
    it uses in order to be able to process requests and render the appropriate views.
    These beans are included in the Spring framework and can be configured in
    the <tt class="interfacename">WebApplicationContext</tt>, just as any other bean would
    be configured. Each of those beans is described in more detail below. Right now, we'll
    just mention them, just to let you know they exist and to enable us to go on talking
    about the <tt class="classname">DispatcherServlet</tt>. For most of the beans, sensible
    defaults are provided so you don't (initially) have to worry about configuring them.</p><div class="table"><a name="d0e17034"></a><p class="title"><b>Table&nbsp;13.1.&nbsp;Special beans in the <tt class="interfacename">WebApplicationContext</tt></b></p><table summary="Special beans in the WebApplicationContext" border="1"><colgroup><col><col></colgroup><thead><tr><th>Bean type</th><th>Explanation</th></tr></thead><tbody><tr><td>Controllers</td><td><a href="mvc.html#mvc-controller" title="13.3.&nbsp;Controllers">Controllers</a> are the
            components that form the <tt class="literal">'C'</tt> part of the MVC.</td></tr><tr><td>Handler mappings</td><td><a href="mvc.html#mvc-handlermapping" title="13.4.&nbsp;Handler mappings">Handler mappings</a>
            handle the execution of a list of pre- and post-processors and controllers
            that will be executed if they match certain criteria (for instance a
            matching URL specified with the controller)</td></tr><tr><td>View resolvers</td><td><a href="mvc.html#mvc-viewresolver" title="13.5.&nbsp;Views and resolving them">View resolvers</a> are components
            capable of resolving view names to views</td></tr><tr><td>Locale resolver</td><td>A <a href="mvc.html#mvc-localeresolver" title="13.6.&nbsp;Using locales">locale resolver</a> is a
            component capable of resolving the locale a client is using, in order to be
            able to offer internationalized views</td></tr><tr><td>Theme resolver</td><td>A <a href="mvc.html#mvc-themeresolver" title="13.7.&nbsp;Using themes">theme resolver</a> is capable
            of resolving themes your web application can use, for example, to offer
            personalized layouts</td></tr><tr><td>multipart file resolver</td><td>A <a href="mvc.html#mvc-multipart" title="13.8.&nbsp;Spring's multipart (fileupload) support">multipart file resolver</a> offers
            the functionality to process file uploads from HTML forms</td></tr><tr><td>Handler exception resolver(s)</td><td><a href="mvc.html#mvc-exceptionhandlers" title="13.10.&nbsp;Handling exceptions">Handler exception resolvers</a>
            offer functionality to map exceptions to views or implement other more
            complex exception handling code</td></tr></tbody></table></div><p>When a <tt class="classname">DispatcherServlet</tt> is set up for use and a
    request comes in for that specific <tt class="classname">DispatcherServlet</tt>, said
    <tt class="classname">DispatcherServlet</tt> starts processing the request. The list
    below describes the complete process a request goes through when handled by a
    <tt class="classname">DispatcherServlet</tt>:</p><div class="orderedlist"><ol type="1"><li><p>The <tt class="interfacename">WebApplicationContext</tt> is searched
          for and bound in the request as an attribute in order for the controller
          and other elements in the process to use. It is bound by default under the key
          <tt class="literal">DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</tt>.</p></li><li><p>The locale resolver is bound to the request to let elements in
          the process resolve the locale to use when processing the request
          (rendering the view, preparing data, etc.) If you don't use the
          resolver, it won't affect anything, so if you don't need locale
          resolving, you don't have to use it.</p></li><li><p>The theme resolver is bound to the request to let elements
          such as views determine which theme to use. The theme resolver does
          not affect anything if you don't use it, so if you don't need themes
          you can just ignore it.</p></li><li><p>If a multipart resolver is specified, the request is inspected
          for multiparts; if multiparts are found, the request is wrapped in a
          <tt class="classname">MultipartHttpServletRequest</tt> for further
          processing by other elements in the process. (See the section
          entitled <a href="mvc.html#mvc-multipart-resolver" title="13.8.2.&nbsp;Using the MultipartResolver">Section&nbsp;13.8.2, &#8220;Using the MultipartResolver&#8221;</a> for further
          information about multipart handling).</p></li><li><p>An appropriate handler is searched for. If a handler is found,
          the execution chain associated with the handler (preprocessors,
          postprocessors, and controllers) will be executed in order to prepare
          a model (for rendering).</p></li><li><p>If a model is returned, the view is rendered. If no model is returned
          (which could be due to a pre- or postprocessor intercepting the request,
          for example, for security reasons), no view is rendered, since the request
          could already have been fulfilled.</p></li></ol></div><p>Exceptions that are thrown during processing of the request get
    picked up by any of the handler exception resolvers that are declared in
    the <tt class="interfacename">WebApplicationContext</tt>. Using these exception
    resolvers allows you to define custom behaviors in case such exceptions get
    thrown.</p><p>The Spring <tt class="classname">DispatcherServlet</tt> also has support for
    returning the <span class="emphasis"><em>last-modification-date</em></span>, as specified by the
    Servlet API. The process of determining the last modification date for a specific
    request is straightforward: the <tt class="classname">DispatcherServlet</tt> will first
    lookup an appropriate handler mapping and test if the handler that is found
    <span class="emphasis"><em>implements the interface <tt class="interfacename">LastModified</tt></em></span>
    interface. If so, the value of the <tt class="literal">long getLastModified(request)</tt> method
    of the <tt class="interfacename">LastModified</tt> interface is returned to the client.</p><p>You can customize Spring's <tt class="classname">DispatcherServlet</tt> by
    adding context parameters in the <tt class="literal">web.xml</tt> file or servlet
    initialization parameters. The possibilities are listed below.</p><div class="table"><a name="d0e17183"></a><p class="title"><b>Table&nbsp;13.2.&nbsp;<tt class="classname">DispatcherServlet</tt> initialization parameters</b></p><table summary="DispatcherServlet initialization parameters" border="1"><colgroup><col><col></colgroup><thead><tr><th>Parameter</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="literal">contextClass</tt></td><td>Class that implements <tt class="interfacename">WebApplicationContext</tt>,
            which will be used to instantiate the context used by this servlet. If this
            parameter isn't specified, the <tt class="classname">XmlWebApplicationContext</tt>
            will be used.</td></tr><tr><td><tt class="literal">contextConfigLocation</tt></td><td>String which is passed to the context instance (specified
            by <tt class="literal">contextClass</tt>) to indicate where context(s)
            can be found. The string is potentially split up into multiple
            strings (using a comma as a delimiter) to support multiple
            contexts (in case of multiple context locations, of beans that are
            defined twice, the latest takes precedence).</td></tr><tr><td>namespace</td><td>the namespace of the <tt class="interfacename">WebApplicationContext</tt>.
            Defaults to <tt class="literal">[server-name]-servlet</tt>.</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-controller"></a>13.3.&nbsp;Controllers</h2></div></div><div></div></div><p>The notion of a controller is part of the MVC design pattern (more specifically
    it is the <span class="emphasis"><em>'C'</em></span> in MVC. Controllers provide access to the application
    behavior which is typically defined by a service interface. Controllers interpret user
    input and transform said input into a sensible model which will be represented to the
    user by the view. Spring has implemented the notion of a controller in a very abstract
    way enabling a wide variety of different kinds of controllers to be created. Spring
    contains form-specific controllers, command-based controllers, and controllers
    that execute wizard-style logic, to name but a few.</p><p>Spring's basis for the controller architecture is the
    <tt class="interfacename">org.springframework.web.servlet.mvc.Controller</tt>
    interface, the source code for which is listed below. </p><pre class="programlisting">public interface Controller {

    /**
     * Process the request and return a ModelAndView object which the DispatcherServlet
     * will render.
     */
    ModelAndView handleRequest(
        HttpServletRequest request,
        HttpServletResponse response) throws Exception;

}</pre><p>As you can see, the <tt class="interfacename">Controller</tt> interface
    defines a single method that is responsible for handling a request and returning
    an appropriate model and view. These three concepts are the basis for the Spring
    MVC implementation - <tt class="classname">ModelAndView</tt> and
    <tt class="interfacename">Controller</tt>. While the
    <tt class="interfacename">Controller</tt> interface is quite abstract,
    Spring offers a lot of <tt class="interfacename">Controller</tt> implementations
    out of the box that already contain a lot of the functionality you might need. The
    <tt class="interfacename">Controller</tt> interface just defines the most basic
    responsibility required of every controller; namely handling a request and returning
    a model and a view.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-controller-abstractcontroller"></a>13.3.1.&nbsp;<tt class="classname">AbstractController</tt> and <tt class="classname">WebContentGenerator</tt></h3></div></div><div></div></div><p>To provide a basic infrastructure, all of Spring's various
      <tt class="interfacename">Controller</tt> inherit from
      <tt class="classname">AbstractController</tt>, a class offering caching support
      and, for example, the setting of the mimetype.</p><div class="table"><a name="mvc-controller-abstract-features"></a><p class="title"><b>Table&nbsp;13.3.&nbsp;Features offered by the <tt class="classname">AbstractController</tt></b></p><table summary="Features offered by the AbstractController" border="1"><colgroup><col><col></colgroup><thead><tr><th>Feature</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="literal">supportedMethods</tt></td><td>indicates what methods this controller should accept.
              Usually this is set to both <tt class="literal">GET</tt> and
              <tt class="literal">POST</tt>, but you can modify this to reflect the
              method you want to support. If a request is received with a
              method that is not supported by the controller, the client will
              be informed of this (expedited by the throwing of a
              <tt class="classname">ServletException</tt>).</td></tr><tr><td><tt class="literal">requiresSession</tt></td><td>indicates whether or not this controller requires a
              HTTP session to do its work. If a session is not present when
              such a controller receives a request, the user is informed
              of this by a <tt class="classname">ServletException</tt> being thrown.</td></tr><tr><td><tt class="literal">synchronizeSession</tt></td><td>use this if you want handling by this controller to be
              synchronized on the user's HTTP session.</td></tr><tr><td><tt class="literal">cacheSeconds</tt></td><td>when you want a controller to generate a caching
              directive in the HTTP response, specify a positive integer here.
              By default the value of this property is set to <span class="emphasis"><em>-1</em></span>
              so no caching directives will be included in the generated response.</td></tr><tr><td><tt class="literal">useExpiresHeader</tt></td><td>tweaks your controllers to specify the HTTP 1.0
              compatible <span class="emphasis"><em>"Expires"</em></span> header in the generated
              response. By default the value of this property is
              <tt class="literal">true</tt>.</td></tr><tr><td><tt class="literal">useCacheHeader</tt></td><td>tweaks your controllers to specify the HTTP 1.1
              compatible <span class="emphasis"><em>"Cache-Control"</em></span> header in the generated
              response. By default the value of this property is
              <tt class="literal">true</tt>.</td></tr></tbody></table></div><p>When using the <tt class="classname">AbstractController</tt> as the baseclass
      for your controllers you only have to override the
      <tt class="literal">handleRequestInternal(HttpServletRequest, HttpServletResponse)</tt>
      method, implement your logic, and return a <tt class="classname">ModelAndView</tt> object.
      Here is short example consisting of a class and a declaration in the web
      application context.</p><pre class="programlisting">package samples;

public class SampleController extends AbstractController {

    public ModelAndView handleRequestInternal(
        HttpServletRequest request,
        HttpServletResponse response) throws Exception {

        ModelAndView mav = new ModelAndView("hello");
        mav.addObject("message", "Hello World!");
        return mav;        
    }
}</pre><pre class="programlisting">&lt;bean id="sampleController" class="samples.SampleController"&gt;
    &lt;property name="cacheSeconds" value="120"/&gt;
&lt;/bean&gt;</pre><p>The above class and the declaration in the web application context is all
        you need besides setting up a handler mapping (see the section entitled
        <a href="mvc.html#mvc-handlermapping" title="13.4.&nbsp;Handler mappings">Section&nbsp;13.4, &#8220;Handler mappings&#8221;</a>) to get this very simple controller working.
        This controller will generate caching directives telling the client to cache things
        for 2 minutes before rechecking. This controller also returns a hard-coded view
        (which is typically considered bad practice).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-controller-othersimplecontrollers"></a>13.3.2.&nbsp;Other simple controllers</h3></div></div><div></div></div><p>Although you can extend <tt class="classname">AbstractController</tt>, Spring
      provides a number of concrete implementations which offer functionality that is
      commonly used in simple MVC applications. The
      <tt class="classname">ParameterizableViewController</tt> is basically the same as
      the example above, except for the fact that you can specify the view name that it
      will return in the web application context (and thus remove the need to hard-code
      the viewname in the Java class).</p><p>The <tt class="classname">UrlFilenameViewController</tt> inspects the URL
      and retrieves the filename of the file request and uses that as a viewname.
      For example, the filename of <tt class="literal">http://www.springframework.org/index.html</tt>
      request is <tt class="literal">index</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-controller-multiaction"></a>13.3.3.&nbsp;The <tt class="classname">MultiActionController</tt></h3></div></div><div></div></div><p>Spring offers a multi-action controller with which you aggregate
      multiple actions into one controller, thus grouping functionality together.
      The multi-action controller lives in a separate package -
      <tt class="literal">org.springframework.web.servlet.mvc.multiaction</tt> - and
      is capable of mapping requests to method names and then invoking the
      right method name. Using the multi-action controller is especially handy
      when you have a lot of common functionality in one controller, but want
      to have multiple entry points to the controller, for example, to tweak
      behavior.</p><div class="table"><a name="mvc-controller-multiaction-features"></a><p class="title"><b>Table&nbsp;13.4.&nbsp;Features offered by the <tt class="classname">MultiActionController</tt></b></p><table summary="Features offered by the MultiActionController" border="1"><colgroup><col><col></colgroup><thead><tr><th>Feature</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="literal">delegate</tt></td><td>there are two usage-scenarios for the
              <tt class="classname">MultiActionController</tt>. Either you subclass the
              <tt class="classname">MultiActionController</tt> and specify the methods
              that will be resolved by the <tt class="interfacename">MethodNameResolver</tt>
              on the subclass (in which case you don't need to set the delegate),
              or you define a delegate object, on which methods resolved by the
              <tt class="interfacename">MethodNameResolver</tt> will be invoked.
              If you choose this scenario, you will have to define the delegate using
              this configuration parameter as a collaborator.</td></tr><tr><td><tt class="literal">methodNameResolver</tt></td><td>the <tt class="classname">MultiActionController</tt> needs a strategy
              to resolve the method it has to invoke, based on the incoming request. This
              strategy is defined by the <tt class="interfacename">MethodNameResolver</tt>
              interface; the <tt class="classname">MultiActionController</tt> exposes a
              property sp that you can supply a resolver that is capable of doing that.</td></tr></tbody></table></div><p>Methods defined for a multi-action controller need to conform to
      the following signature:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// anyMeaningfulName can be replaced by any methodname</span></i>
public [ModelAndView | Map | void] anyMeaningfulName(HttpServletRequest, HttpServletResponse [, Exception | AnyObject]);</pre><p>Please note that method overloading is <span class="emphasis"><em>not</em></span>
      allowed since it would confuse the <tt class="classname">MultiActionController</tt>.
      Furthermore, you can define <span class="emphasis"><em>exception handlers</em></span> capable
      of handling exceptions that are thrown by the methods you specify.

      </p><p>The (optional) <tt class="classname">Exception</tt> argument can be <span class="emphasis"><em>any</em></span>
      exception, as long as it's a subclass of <tt class="classname">java.lang.Exception</tt> or
      <tt class="classname">java.lang.RuntimeException</tt>. The (optional) <tt class="classname">AnyObject</tt>
      argument can be <span class="emphasis"><em>any</em></span> class. Request parameters will be bound onto this
      object for convenient consumption.</p><p>
      
      </p><p>Find below some examples of valid <tt class="classname">MultiActionController</tt>
      method signatures.</p><p>
      
      </p><p>The standard signature (mirrors the <tt class="interfacename">Controller</tt> interface method).</p><p>
      </p><pre class="programlisting">public ModelAndView doRequest(HttpServletRequest, HttpServletResponse)</pre><p>
      </p><p>This signature accepts a <tt class="classname">Login</tt> argument that will be populated (bound) with parameters stripped from the request</p><p>
      </p><pre class="programlisting">public ModelAndView doLogin(HttpServletRequest, HttpServletResponse, Login)</pre><p>
      </p><p>The signature for an <tt class="classname">Exception</tt> handling method.</p><p>
      </p><pre class="programlisting">public ModelAndView processException(HttpServletRequest, HttpServletResponse, IllegalArgumentException)</pre><p>
      </p><p>This signature has a void return type (see the section entitled <a href="mvc.html#mvc-coc" title="13.11.&nbsp;Convention over configuration">Section&nbsp;13.11, &#8220;Convention over configuration&#8221;</a> below).</p><p>
      </p><pre class="programlisting">public void goHome(HttpServletRequest, HttpServletResponse)</pre><p>
      </p><p>This signature has a <tt class="interfacename">Map</tt> return type (see the section entitled <a href="mvc.html#mvc-coc" title="13.11.&nbsp;Convention over configuration">Section&nbsp;13.11, &#8220;Convention over configuration&#8221;</a> below).</p><p>
      </p><pre class="programlisting">public Map doRequest(HttpServletRequest, HttpServletResponse)</pre><p>

      </p><p>The <tt class="interfacename">MethodNameResolver</tt> is responsible for
      resolving method names based on the request coming in. Find below details about
      the three <tt class="interfacename">MethodNameResolver</tt> implementations
      that Spring provides out of the box.</p><p>
      
      </p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="classname">ParameterMethodNameResolver</tt> - capable of
            resolving a request parameter and using that as the method name
            (<tt class="literal">http://www.sf.net/index.view?testParam=testIt</tt>
            will result in a method <tt class="literal">testIt(HttpServletRequest,
            HttpServletResponse)</tt> being called). The <tt class="literal">paramName</tt>
            property specifies the request parameter that is to be inspected).</p></li><li><p><tt class="classname">InternalPathMethodNameResolver</tt> -
            retrieves the filename from the request path and uses that as the method
            name (<tt class="literal">http://www.sf.net/testing.view</tt> will
            result in a method <tt class="literal">testing(HttpServletRequest,
            HttpServletResponse)</tt> being called).</p></li><li><p><tt class="classname">PropertiesMethodNameResolver</tt> - uses a
            user-defined properties object with request URLs mapped to
            method names. When the properties contain
            <tt class="literal">/index/welcome.html=doIt</tt> and a request to
            <tt class="literal">/index/welcome.html</tt> comes in, the
            <tt class="literal">doIt(HttpServletRequest, HttpServletResponse)</tt>
            method is called. This method name resolver works with the
            <tt class="literal">PathMatcher</tt>, so if the properties contained
            <tt class="literal">/**/welcom?.html</tt>, it would also have
            worked!</p></li></ul></div><p>

      </p><p>Here are a couple of examples. First, an example showing the
      <tt class="classname">ParameterMethodNameResolver</tt> and the delegate
      property, which will accept requests to URLs with the parameter method
      included and set to <tt class="literal">retrieveIndex</tt>: </p><p>
      
      </p><pre class="programlisting">&lt;bean id="paramResolver" class="org....mvc.multiaction.ParameterMethodNameResolver"&gt;
  &lt;property name="paramName" value="method"/&gt;
&lt;/bean&gt;

&lt;bean id="paramMultiController" class="org....mvc.multiaction.MultiActionController"&gt;
  &lt;property name="methodNameResolver" ref="paramResolver"/&gt;
  &lt;property name="delegate" ref="sampleDelegate"/&gt;
&lt;/bean&gt;

&lt;bean id="sampleDelegate" class="samples.SampleDelegate"/&gt;

<i class="lineannotation"><span class="lineannotation">## together with</span></i>

public class SampleDelegate {

    public ModelAndView retrieveIndex(HttpServletRequest req, HttpServletResponse resp) {

        return new ModelAndView("index", "date", new Long(System.currentTimeMillis()));
    }
}</pre><p>

        </p><p>When using the delegates shown above, we could also use the
        <tt class="classname">PropertiesMethodNameResolver</tt> to match a couple of
        URLs to the method we defined: </p><p>
      
      </p><pre class="programlisting">&lt;bean id="propsResolver" class="org....mvc.multiaction.PropertiesMethodNameResolver"&gt;
  &lt;property name="mappings"&gt;
    &lt;value&gt;
        /index/welcome.html=retrieveIndex
        /**/notwelcome.html=retrieveIndex
        /*/user?.html=retrieveIndex
    &lt;/value&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="paramMultiController" class="org....mvc.multiaction.MultiActionController"&gt;
    &lt;property name="methodNameResolver" ref="propsResolver"/&gt;
    &lt;property name="delegate" ref="sampleDelegate"/&gt;
&lt;/bean&gt;</pre><p>
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-controller-command"></a>13.3.4.&nbsp;Command controllers</h3></div></div><div></div></div><p>Spring's <span class="emphasis"><em>command controllers</em></span> are a fundamental
      part of the Spring Web MVC package. Command controllers provide a way to
      interact with data objects and dynamically bind parameters from the
      <tt class="interfacename">HttpServletRequest</tt> to the data object specified.
      They perform a somewhat similar role to the Struts <tt class="classname">ActionForm</tt>,
      but in Spring, your data objects don't have to implement a framework-specific
      interface. First, lets examine what command controllers are available straight
      out of the box.</p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="classname">AbstractCommandController</tt> - a command
            controller you can use to create your own command controller,
            capable of binding request parameters to a data object you
            specify. This class does not offer form functionality; it does
            however offer validation features and lets you specify in the
            controller itself what to do with the command object that has been
            populated with request parameter values.</p></li><li><p><tt class="classname">AbstractFormController</tt> - an abstract
            controller offering form submission support. Using this controller
            you can model forms and populate them using a command object you
            retrieve in the controller. After a user has filled the form, the
            <tt class="classname">AbstractFormController</tt> binds the fields,
            validates the command object, and hands the object back to the
            controller to take the appropriate action. Supported features are:
            invalid form submission (resubmission), validation, and normal form
            workflow. You implement methods to determine which views are used
            for form presentation and success. Use this controller if you need
            forms, but don't want to specify what views you're going to show the
            user in the application context.</p></li><li><p><tt class="classname">SimpleFormController</tt> - a form controller
            that provides even more support when creating a form with a corresponding
            command object. The <tt class="classname">SimpleFormController</tt>
            let's you specify a command object, a viewname for the form, a
            viewname for page you want to show the user when form submission
            has succeeded, and more.</p></li><li><p><tt class="classname">AbstractWizardFormController</tt> - as the
            class name suggests, this is an abstract class - your
            wizard controller should extend it. This means you have to
            implement the <tt class="literal">validatePage()</tt>,
            <tt class="literal">processFinish()</tt> and
            <tt class="literal">processCancel()</tt> methods.</p><p>You probably also want to write a contractor, which should
            at the very least call <tt class="literal">setPages()</tt> and
            <tt class="literal">setCommandName()</tt>. The former takes as its
            argument an array of type String. This array is the list of views
            which comprise your wizard. The latter takes as its argument a
            String, which will be used to refer to your command object from
            within your views.</p><p>As with any instance of <tt class="classname">AbstractFormController</tt>, you are
            required to use a command object - a JavaBean which will be
            populated with the data from your forms. You can do this in one of
            two ways: either call <tt class="literal">setCommandClass()</tt> from
            the constructor with the class of your command object, or
            implement the <tt class="literal">formBackingObject()</tt>
            method.</p><p><tt class="classname">AbstractWizardFormController</tt> has a number of concrete
            methods that you may wish to override. Of these, the ones you are
            likely to find most useful are: <tt class="literal">referenceData(..)</tt>
            which you can use to pass model data to your view in the form of a
            <tt class="interfacename">Map</tt>; <tt class="literal">getTargetPage()</tt> if your wizard needs to
            change page order or omit pages dynamically; and
            <tt class="literal">onBindAndValidate()</tt> if you want to override the
            built-in binding and validation workflow.</p><p>Finally, it is worth pointing out the
            <tt class="literal">setAllowDirtyBack()</tt> and
            <tt class="literal">setAllowDirtyForward()</tt>, which you can call from
            <tt class="literal">getTargetPage()</tt> to allow users to move backwards
            and forwards in the wizard even if validation fails for the
            current page.</p><p>For a full list of methods, see the Javadoc for
            <tt class="classname">AbstractWizardFormController</tt>. There is an implemented example of
            this wizard in the jPetStore included in the Spring distribution:
            <tt class="classname">org.springframework.samples.jpetstore.web.spring.OrderFormController</tt>.</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-handlermapping"></a>13.4.&nbsp;Handler mappings</h2></div></div><div></div></div><p>Using a handler mapping you can map incoming web requests to
    appropriate handlers. There are some handler mappings you can use out of
    the box, for example, the <tt class="classname">SimpleUrlHandlerMapping</tt> or
    the <tt class="classname">BeanNameUrlHandlerMapping</tt>, but let's first examine
    the general concept of a <tt class="interfacename">HandlerMapping</tt>.</p><p>The functionality a basic <tt class="interfacename">HandlerMapping</tt> provides
    is the delivering of a <tt class="literal">HandlerExecutionChain</tt>, which
    must contain the handler that matches the incoming request, and may also
    contain a list of handler interceptors that are applied to the request.
    When a request comes in, the <tt class="classname">DispatcherServlet</tt> will
    hand it over to the handler mapping to let it inspect the request and come
    up with an appropriate HandlerExecutionChain. Then the <tt class="classname">DispatcherServlet</tt>
    will execute the handler and interceptors in the chain (if any).</p><p>The concept of configurable handler mappings that can optionally
    contain interceptors (executed before or after the actual handler was
    executed, or both) is extremely powerful. A lot of supporting
    functionality can be built into custom <tt class="interfacename">HandlerMapping</tt>s.
    Think of a custom handler mapping that chooses a handler not only based on
    the URL of the request coming in, but also on a specific state of the
    session associated with the request.</p><p>This section describes two of Spring's most commonly used handler
    mappings. They both extend the <tt class="literal">AbstractHandlerMapping</tt>
    and share the following properties: </p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">interceptors</tt>: the list of interceptors to
          use. <tt class="interfacename">HandlerInterceptor</tt>s are discussed in <a href="mvc.html#mvc-handlermapping-interceptor" title="13.4.3.&nbsp;Intercepting requests - the HandlerInterceptor interface">Section&nbsp;13.4.3, &#8220;Intercepting requests - the HandlerInterceptor interface&#8221;</a>.</p></li><li><p><tt class="literal">defaultHandler</tt>: the default handler to use,
          when this handler mapping does not result in a matching handler.</p></li><li><p><tt class="literal">order</tt>: based on the value of the order
          property (see the
          <tt class="literal">org.springframework.core.Ordered</tt> interface),
          Spring will sort all handler mappings available in the context and
          apply the first matching handler.</p></li><li><p><tt class="literal">alwaysUseFullPath</tt>: if this property is set
          to <tt class="literal">true</tt>, Spring will use the full path within the
          current servlet context to find an appropriate handler. If this
          property is set to <tt class="literal">false</tt> (the default), the path
          within the current servlet mapping will be used. For example, if a
          servlet is mapped using <tt class="literal">/testing/*</tt> and the
          <tt class="literal">alwaysUseFullPath</tt> property is set to true,
          <tt class="literal">/testing/viewPage.html</tt> would be used, whereas if
          the property is set to false, <tt class="literal">/viewPage.html</tt>
          would be used.</p></li><li><p><tt class="literal">urlPathHelper</tt>: using this property, you can
          tweak the UrlPathHelper used when inspecting URLs. Normally, you
          shouldn't have to change the default value.</p></li><li><p><tt class="literal">urlDecode</tt>: the default value for this
          property is <tt class="literal">false</tt>. The
          <tt class="interfacename">HttpServletRequest</tt> returns request URLs and URIs
          that are <span class="emphasis"><em>not</em></span> decoded. If you do want them to be
          decoded before a <tt class="interfacename">HandlerMapping</tt> uses them to find
          an appropriate handler, you have to set this to
          <tt class="literal">true</tt> (note that this requires JDK 1.4). The
          decoding method uses either the encoding specified by the request or
          the default ISO-8859-1 encoding scheme.</p></li><li><p><tt class="literal">lazyInitHandlers</tt>: allows for lazy
          initialization of <span class="emphasis"><em>singleton</em></span> handlers (prototype
          handlers are always lazily initialized). Default value is
          <tt class="literal">false</tt>.</p></li></ul></div><p>(<span class="emphasis"><em>Note: the last four properties are only available to subclasses of
        <tt class="classname">org.springframework.web.servlet.handler.AbstractUrlHandlerMapping</tt></em></span>).</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-handlermapping-beanname"></a>13.4.1.&nbsp;<tt class="classname">BeanNameUrlHandlerMapping</tt></h3></div></div><div></div></div><p>A very simple, but very powerful handler mapping is the
      <tt class="classname">BeanNameUrlHandlerMapping</tt>, which maps incoming HTTP
      requests to names of beans, defined in the web application context.
      Let's say we want to enable a user to insert an account and we've
      already provided an appropriate form controller (see
      <a href="mvc.html#mvc-controller-command" title="13.3.4.&nbsp;Command controllers">Section&nbsp;13.3.4, &#8220;Command controllers&#8221;</a> for more information on command- and
      form controllers) and a JSP view (or Velocity template) that renders the
      form. When using the <tt class="classname">BeanNameUrlHandlerMapping</tt>, we
      could map the HTTP request with the URL
      <tt class="literal">http://samples.com/editaccount.form</tt> to the appropriate
      form <tt class="interfacename">Controller</tt> as follows:</p><pre class="programlisting">&lt;beans&gt;
  &lt;bean id="handlerMapping" class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/&gt;

  &lt;bean name="/editaccount.form" class="org.springframework.web.servlet.mvc.SimpleFormController"&gt;
    &lt;property name="formView" value="account"/&gt;
    &lt;property name="successView" value="account-created"/&gt;
    &lt;property name="commandName" value="account"/&gt;
    &lt;property name="commandClass" value="samples.Account"/&gt;
  &lt;/bean&gt;
&lt;beans&gt;</pre><p>All incoming requests for the URL
      <tt class="literal">/editaccount.form</tt> will now be handled by the
      form <tt class="interfacename">Controller</tt> in the source listing above.
      Of course we have to define a servlet-mapping in <tt class="literal">web.xml</tt>
      as well, to let through all the requests ending with <tt class="literal">.form</tt>.
      </p><pre class="programlisting">&lt;web-app&gt;
    ...
    &lt;servlet&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

   <i class="lineannotation"><span class="lineannotation">&lt;!-- maps the sample dispatcher to <tt class="literal">*.form</tt> --&gt;</span></i>
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    ...
&lt;/web-app&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://static.springframework.org/spring/docs/2.0.x/images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you want to use the <tt class="classname">BeanNameUrlHandlerMapping</tt>,
        you don't necessarily have to define it in the web application context (as
        indicated above). By default, if no handler mapping can be found in the context,
        the <tt class="classname">DispatcherServlet</tt> creates a
        <tt class="classname">BeanNameUrlHandlerMapping</tt> for you!</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-handlermapping-urlhandlermapping"></a>13.4.2.&nbsp;<tt class="classname">SimpleUrlHandlerMapping</tt></h3></div></div><div></div></div><p>A further - and much more powerful handler mapping - is the
      <tt class="classname">SimpleUrlHandlerMapping</tt>. This mapping is configurable
      in the application context and has Ant-style path matching capabilities
      (see the Javadoc for the <tt class="classname">org.springframework.util.PathMatcher</tt>
      class). Here is an example:</p><pre class="programlisting">&lt;web-app&gt;
    ...
    &lt;servlet&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- maps the sample dispatcher to *.form --&gt;</span></i>
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- maps the sample dispatcher to *.html --&gt;</span></i>
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    ...
&lt;/web-app&gt;</pre><p>The above <tt class="literal">web.xml</tt> configuration snippet enables all requests
        ending with .html and <tt class="literal">.form</tt> to be handled by the sample dispatcher 
        servlet.</p><pre class="programlisting">&lt;beans&gt;
        
    <i class="lineannotation"><span class="lineannotation">&lt;!-- no <tt class="literal">'id'</tt> required, <tt class="interfacename">HandlerMapping</tt> beans are automatically detected by the <tt class="classname">DispatcherServlet</tt> --&gt;</span></i>
    &lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
        &lt;property name="mappings"&gt;
            &lt;value&gt;
                /*/account.form=editAccountFormController
                /*/editaccount.form=editAccountFormController
                /ex/view*.html=helpController
                /**/help.html=helpController
            &lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="helpController"
          class="org.springframework.web.servlet.mvc.UrlFilenameViewController"/&gt;

    &lt;bean id="editAccountFormController"
          class="org.springframework.web.servlet.mvc.SimpleFormController"&gt;
        &lt;property name="formView" value="account"/&gt;
        &lt;property name="successView" value="account-created"/&gt;
        &lt;property name="commandName" value="Account"/&gt;
        &lt;property name="commandClass" value="samples.Account"/&gt;
    &lt;/bean&gt;
&lt;beans&gt;</pre><p>This handler mapping routes requests for <tt class="literal">'help.html'</tt>
        in any directory to the <tt class="literal">'helpController'</tt>, which is a
        <tt class="classname">UrlFilenameViewController</tt> (more about controllers
        can be found in the section entitled <a href="mvc.html#mvc-controller" title="13.3.&nbsp;Controllers">Section&nbsp;13.3, &#8220;Controllers&#8221;</a>).
        Requests for a resource beginning with <tt class="literal">'view'</tt>, and ending
        with <tt class="literal">'.html'</tt> in the directory <tt class="literal">'ex'</tt> will
        be routed to the <tt class="literal">'helpController'</tt>. Two further mappings
        are also defined for <tt class="literal">'editAccountFormController'</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-handlermapping-interceptor"></a>13.4.3.&nbsp;Intercepting requests - the <tt class="interfacename">HandlerInterceptor</tt> interface</h3></div></div><div></div></div><p>Spring's handler mapping mechanism has the notion of handler
      interceptors, that can be extremely useful when you want to apply
      specific functionality to certain requests, for example, checking for a
      principal.</p><p>Interceptors located in the handler mapping must implement
      <tt class="interfacename">HandlerInterceptor</tt> from the
      <tt class="literal">org.springframework.web.servlet</tt> package. This
      interface defines three methods, one that will be called
      <span class="emphasis"><em>before</em></span> the actual handler will be executed, one
      that will be called <span class="emphasis"><em>after</em></span> the handler is executed,
      and one that is called <span class="emphasis"><em>after the complete request has
      finished</em></span>. These three methods should provide enough
      flexibility to do all kinds of pre- and post-processing.</p><p>The <tt class="literal">preHandle(..)</tt> method returns a boolean value.
      You can use this method to break or continue the processing of the
      execution chain. When this method returns <tt class="literal">true</tt>, the
      handler execution chain will continue, when it returns false, the
      <tt class="classname">DispatcherServlet</tt> assumes the interceptor itself has
      taken care of requests (and, for example, rendered an appropriate view) and
      does not continue executing the other interceptors and the actual handler in
      the execution chain.</p><p>The following example provides an interceptor that intercepts all
      requests and reroutes the user to a specific page if the time is not
      between 9 a.m. and 6 p.m.
      </p><pre class="programlisting">&lt;beans&gt;
    &lt;bean id="handlerMapping"
          class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
        &lt;property name="interceptors"&gt;
            &lt;list&gt;
                &lt;ref bean="officeHoursInterceptor"/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="mappings"&gt;
            &lt;value&gt;
                /*.form=editAccountFormController
                /*.view=editAccountFormController
            &lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="officeHoursInterceptor"
          class="samples.TimeBasedAccessInterceptor"&gt;
        &lt;property name="openingTime" value="9"/&gt;
        &lt;property name="closingTime" value="18"/&gt;
    &lt;/bean&gt;
&lt;beans&gt;</pre><pre class="programlisting">package samples;

public class TimeBasedAccessInterceptor extends HandlerInterceptorAdapter {

    private int openingTime;
    private int closingTime;

    public void setOpeningTime(int openingTime) {
        this.openingTime = openingTime;
    }

    public void setClosingTime(int closingTime) {
        this.closingTime = closingTime;
    }

    public boolean preHandle(
            HttpServletRequest request,
            HttpServletResponse response,
            Object handler) throws Exception {

        Calendar cal = Calendar.getInstance();
        int hour = cal.get(HOUR_OF_DAY);
        if (openingTime &lt;= hour &lt; closingTime) {
            return true;
        } else {
            response.sendRedirect("http://host.com/outsideOfficeHours.html");
            return false;
        }
    }
}</pre><p>Any request coming in, will be intercepted by the
      <tt class="classname">TimeBasedAccessInterceptor</tt>, and if the current time
      is outside office hours, the user will be redirected to a static html
      file, saying, for example, he can only access the website during office
      hours.</p><p>As you can see, Spring has an adapter class (the cunningly named
      <tt class="classname">HandlerInterceptorAdapter</tt>) to make it easier to
      extend the <tt class="interfacename">HandlerInterceptor</tt> interface.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-viewresolver"></a>13.5.&nbsp;Views and resolving them</h2></div></div><div></div></div><p>All MVC frameworks for web applications provide a way to address
    views. Spring provides view resolvers, which enable you to render models
    in a browser without tying you to a specific view technology. Out of the
    box, Spring enables you to use JSPs, Velocity templates and
    XSLT views, for example. The section entitled <a href="view.html" title="Chapter&nbsp;14.&nbsp;Integrating view technologies">Chapter&nbsp;14, <i>Integrating view technologies</i></a> has
    details of how to integrate and use a number of disparate view technologies.</p><p>The two interfaces which are important to the way Spring handles
    views are <tt class="interfacename">ViewResolver</tt> and
    <tt class="interfacename">View</tt>. The <tt class="interfacename">ViewResolver</tt>
    provides a mapping between view names and actual views. The
    <tt class="interfacename">View</tt> interface addresses the preparation of
    the request and hands the request over to one of the view technologies.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-viewresolver-resolver"></a>13.5.1.&nbsp;Resolving views - the <tt class="interfacename">ViewResolver</tt> interface</h3></div></div><div></div></div><p>As discussed in the section entitled <a href="mvc.html#mvc-controller" title="13.3.&nbsp;Controllers">Section&nbsp;13.3, &#8220;Controllers&#8221;</a>,
      all controllers in the Spring Web MVC framework return a
      <tt class="classname">ModelAndView</tt> instance. Views in Spring are addressed
      by a view name and are resolved by a view resolver. Spring comes with
      quite a few view resolvers. We'll list most of them and then provide a
      couple of examples.</p><div class="table"><a name="d0e18074"></a><p class="title"><b>Table&nbsp;13.5.&nbsp;View resolvers</b></p><table summary="View resolvers" border="1"><colgroup><col><col></colgroup><thead><tr><th><tt class="interfacename">ViewResolver</tt></th><th>Description</th></tr></thead><tbody><tr><td><tt class="classname">AbstractCachingViewResolver</tt></td><td>An abstract view resolver which takes care of caching
              views. Often views need preparation before they can be used,
              extending this view resolver provides caching of views.</td></tr><tr><td><tt class="classname">XmlViewResolver</tt></td><td>An implementation of <tt class="interfacename">ViewResolver</tt>
              that accepts a configuration file written in XML with the same DTD
              as Spring's XML bean factories. The default configuration file is
              <tt class="literal">/WEB-INF/views.xml</tt>.</td></tr><tr><td><tt class="classname">ResourceBundleViewResolver</tt></td><td>An implementation of <tt class="interfacename">ViewResolver</tt>
              that uses bean definitions in a <tt class="classname">ResourceBundle</tt>,
              specified by the bundle basename. The bundle is typically defined in a
              properties file, located in the classpath. The default file name is
              <tt class="literal">views.properties</tt>.</td></tr><tr><td><tt class="classname">UrlBasedViewResolver</tt></td><td>A simple implementation of the <tt class="interfacename">ViewResolver</tt>
              interface that effects the direct resolution of symbolic view names to
              URLs, without an explicit mapping definition. This is appropriate if your
              symbolic names match the names of your view resources in a
              straightforward manner, without the need for arbitrary mappings.</td></tr><tr><td><tt class="classname">InternalResourceViewResolver</tt></td><td>A convenience subclass of <tt class="classname">UrlBasedViewResolver</tt>
              that supports <tt class="classname">InternalResourceView</tt> (i.e. Servlets and JSPs),
              and subclasses such as <tt class="classname">JstlView</tt> and
              <tt class="classname">TilesView</tt>. The view class for all views generated
              by this resolver can be specified via <tt class="literal">setViewClass(..)</tt>.
              See the Javadocs for the <tt class="classname">UrlBasedViewResolver</tt> class
              for details.</td></tr><tr><td><tt class="classname">VelocityViewResolver</tt> / <tt class="classname">FreeMarkerViewResolver</tt></td><td>A convenience subclass of <tt class="classname">UrlBasedViewResolver</tt> that
              supports <tt class="classname">VelocityView</tt> (i.e. Velocity templates) or
              <tt class="classname">FreeMarkerView</tt> respectively and custom subclasses of
              them.</td></tr></tbody></table></div><p>As an example, when using JSP for a view technology you can use
      the <tt class="classname">UrlBasedViewResolver</tt>. This view resolver
      translates a view name to a URL and hands the request over the
      RequestDispatcher to render the view.</p><pre class="programlisting">&lt;bean id="viewResolver"
      class="org.springframework.web.servlet.view.UrlBasedViewResolver"&gt;
    &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;
    &lt;property name="suffix" value=".jsp"/&gt;
&lt;/bean&gt;</pre><p>When returning <tt class="literal">test</tt> as a
      viewname, this view resolver will hand the request over to the
      <tt class="classname">RequestDispatcher</tt> that will send the request to
      <tt class="literal">/WEB-INF/jsp/test.jsp</tt>.</p><p>When mixing different view technologies in a web application, you
      can use the <tt class="classname">ResourceBundleViewResolver</tt>:</p><pre class="programlisting">&lt;bean id="viewResolver"
      class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
    &lt;property name="basename" value="views"/&gt;
    &lt;property name="defaultParentView" value="parentView"/&gt;
&lt;/bean&gt;</pre><p>The <tt class="classname">ResourceBundleViewResolver</tt> inspects the
      <tt class="classname">ResourceBundle</tt> identified by the basename, and for
      each view it is supposed to resolve,
      it uses the value of the property <tt class="literal">[viewname].class</tt> as
      the view class and the value of the property
      <tt class="literal">[viewname].url</tt> as the view url. As you can see, you
      can identify a parent view, from which all views in the properties file
      sort of extend. This way you can specify a default view class, for
      example.</p><p><span class="emphasis"><em>A note on caching</em></span> - subclasses of
      <tt class="classname">AbstractCachingViewResolver</tt> cache view instances they
      have resolved. This greatly improves performance when using certain view
      technologies. It's possible to turn off the cache, by setting the
      <tt class="literal">cache</tt> property to <tt class="literal">false</tt>. Furthermore,
      if you have the requirement to be able to refresh a certain view at
      runtime (for example when a Velocity template has been modified), you can
      use the <tt class="literal">removeFromCache(String viewName, Locale loc)</tt> method.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-viewresolver-chaining"></a>13.5.2.&nbsp;Chaining ViewResolvers</h3></div></div><div></div></div><p>Spring supports more than just one view resolver. This allows you
      to chain resolvers and, for example, override specific views in certain
      circumstances. Chaining view resolvers is pretty straightforward - just
      add more than one resolver to your application context and, if
      necessary, set the <tt class="literal">order</tt> property to specify an
      order. Remember, the higher the order property, the later the view
      resolver will be positioned in the chain.</p><p>In the following example, the chain of view resolvers consists of
      two resolvers, a <tt class="classname">InternalResourceViewResolver</tt> (which
      is always automatically positioned as the last resolver in the chain)
      and an <tt class="classname">XmlViewResolver</tt> for specifying Excel views
      (which are not supported by the <tt class="classname">InternalResourceViewResolver</tt>):</p><pre class="programlisting">&lt;bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
  &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;
  &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;
  &lt;property name="suffix" value=".jsp"/&gt;
&lt;/bean&gt;

&lt;bean id="excelViewResolver" class="org.springframework.web.servlet.view.XmlViewResolver"&gt;
  &lt;property name="order" value="1"/&gt;
  &lt;property name="location" value="/WEB-INF/views.xml"/&gt;
&lt;/bean&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- in <tt class="literal">views.xml</tt> --&gt;</span></i>

&lt;beans&gt;
  &lt;bean name="report" class="org.springframework.example.ReportExcelView"/&gt;
&lt;/beans&gt;</pre><p>If a specific view resolver does not result in a view, Spring will
      inspect the context to see if other view resolvers are configured. If
      there are additional view resolvers, it will continue to inspect them.
      If not, it will throw an <tt class="classname">Exception</tt>.</p><p>You have to keep something else in mind - the contract of a view
      resolver mentions that a view resolver <span class="emphasis"><em>can</em></span> return
      null to indicate the view could not be found. Not all view resolvers do
      this however! This is because in some cases, the resolver simply cannot
      detect whether or not the view exists. For example, the
      <tt class="classname">InternalResourceViewResolver</tt> uses the
      <tt class="classname">RequestDispatcher</tt> internally, and dispatching is the only way to figure
      out if a JSP exists - this can only be done once. The same holds for the
      <tt class="classname">VelocityViewResolver</tt> and some others. Check the Javadoc for the view
      resolver to see if you're dealing with a view resolver that does not
      report non-existing views. As a result of this, putting an
      <tt class="classname">InternalResourceViewResolver</tt> in the chain in a place
      other than the last, will result in the chain not being fully inspected,
      since the <tt class="classname">InternalResourceViewResolver</tt> will
      <span class="emphasis"><em>always</em></span> return a view!</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e18282"></a>13.5.3.&nbsp;Redirecting to views</h3></div></div><div></div></div><p>As has been mentioned, a controller normally returns a logical
      view name, which a view resolver resolves to a particular view
      technology. For view technologies such as JSPs that are actually
      processed via the Servlet/JSP engine, this is normally handled via
      <tt class="classname">InternalResourceViewResolver</tt> / <tt class="classname">InternalResourceView</tt>
      which will ultimately end up issuing an internal forward or include, via
      the Servlet API's <tt class="literal">RequestDispatcher.forward(..)</tt> or
      <tt class="literal">RequestDispatcher.include()</tt>. For other view
      technologies, such as Velocity, XSLT, etc., the view itself produces the
      content on the response stream.</p><p>It is sometimes desirable to issue an HTTP redirect back to the
      client, before the view is rendered. This is desirable for example when
      one controller has been called with <tt class="literal">POST</tt>ed data, and the response is
      actually a delegation to another controller (for example on a successful
      form submission). In this case, a normal internal forward will mean the
      other controller will also see the same <tt class="literal">POST</tt> data, which is potentially
      problematic if it can confuse it with other expected data. Another reason
      to do a redirect before displaying the result is that this will
      eliminate the possibility of the user doing a double submission of form
      data. The browser will have sent the initial <tt class="literal">POST</tt>, will have seen a
      redirect back and done a subsequent <tt class="literal">GET</tt> because of that, and thus as far
      as it is concerned, the current page does not reflect the result of a
      <tt class="literal">POST</tt>, but rather of a <tt class="literal">GET</tt>, so there is no way the user can accidentally
      re-<tt class="literal">POST</tt> the same data by doing a refresh. The refresh would just force a
      <tt class="literal">GET</tt> of the result page, not a resend of the initial <tt class="literal">POST</tt> data.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e18328"></a>13.5.3.1.&nbsp;<tt class="classname">RedirectView</tt></h4></div></div><div></div></div><p>One way to force a redirect as the result of a controller
        response is for the controller to create and return an instance of
        Spring's <tt class="classname">RedirectView</tt>. In this case,
        <tt class="classname">DispatcherServlet</tt> will not use the normal view
        resolution mechanism, but rather as it has been given the (redirect)
        view already, will just ask it to do its work.</p><p>The <tt class="classname">RedirectView</tt> simply ends up issuing an
        <tt class="literal">HttpServletResponse.sendRedirect()</tt> call, which will
        come back to the client browser as an HTTP redirect. All model
        attributes are simply exposed as HTTP query parameters. This does mean
        that the model must contain only objects (generally Strings or
        convertible to Strings) which can be readily converted to a
        string-form HTTP query parameter.</p><p>If using <tt class="classname">RedirectView</tt> and the view is created
        by the controller itself, it is preferable for the redirect URL to be injected
        into the controller so that it is not baked into the controller but configured
        in the context along with the view names.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e18353"></a>13.5.3.2.&nbsp;The <tt class="literal">redirect:</tt> prefix</h4></div></div><div></div></div><p>While the use of <tt class="classname">RedirectView</tt> works fine, if
        the controller itself is creating the <tt class="classname">RedirectView</tt>,
        there is no getting around the fact that the controller is aware that
        a redirection is happening. This is really suboptimal and couples
        things too tightly. The controller should not really care about how
        the response gets handled... it should generally think only in terms of
        view names that have been injected into it.</p><p>The special <tt class="literal">redirect:</tt> prefix allows this to be achieved. If a
        view name is returned which has the prefix redirect:, then
        <tt class="classname">UrlBasedViewResolver</tt> (and all subclasses) will
        recognize this as a special indication that a redirect is needed. The
        rest of the view name will be treated as the redirect URL.</p><p>The net effect is the same as if the controller had returned a
        <tt class="classname">RedirectView</tt>, but now the controller itself can
        deal just in terms of logical view names. A logical view name such as
        <tt class="literal">redirect:/my/response/controller.html</tt> will redirect
        relative to the current servlet context, while a name such as
        <tt class="literal">redirect:http://myhost.com/some/arbitrary/path.html</tt>
        will redirect to an absolute URL. The important thing is that as long
        is this redirect view name is injected into the controller like any
        other logical view name, the controller is not even aware that
        redirection is happening.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e18386"></a>13.5.3.3.&nbsp;The <tt class="literal">forward:</tt> prefix</h4></div></div><div></div></div><p>It is also possible to use a special <tt class="literal">forward:</tt> prefix for view
        names that will ultimately be resolved by
        <tt class="classname">UrlBasedViewResolver</tt> and subclasses. All this does
        is create an <tt class="classname">InternalResourceView</tt> (which ultimately
        does a <tt class="literal">RequestDispatcher.forward()</tt>) around the rest
        of the view name, which is considered a URL. Therefore, there is never
        any use in using this prefix when using
        <tt class="classname">InternalResourceViewResolver</tt> / <tt class="classname">InternalResourceView</tt>
        anyway (for JSPs for example), but it's of potential use when you are
        primarily using another view technology, but still want to force
        a forward to happen to a resource to be handled by
        the Servlet/JSP engine. (Note that you may also chain multiple view
        resolvers, instead.)</p><p>As with the <tt class="literal">redirect:</tt> prefix, if the view
        name with the prefix is just injected into the controller, the
        controller does not have to be aware that anything special is
        happening in terms of handling the response.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-localeresolver"></a>13.6.&nbsp;Using locales</h2></div></div><div></div></div><p>Most parts of Spring's architecture support internationalization,
    just as the Spring web MVC framework does. <tt class="classname">DispatcherServlet</tt> enables you
    to automatically resolve messages using the client's locale. This is done
    with <tt class="interfacename">LocaleResolver</tt> objects.</p><p>When a request comes in, the <tt class="classname">DispatcherServlet</tt> looks for a locale
    resolver and if it finds one it tries to use it to set the locale. Using
    the <tt class="literal">RequestContext.getLocale()</tt> method, you can always
    retrieve the locale that was resolved by the locale resolver.</p><p>Besides the automatic locale resolution, you can also attach an
    interceptor to the handler mapping (see <a href="mvc.html#mvc-handlermapping-interceptor" title="13.4.3.&nbsp;Intercepting requests - the HandlerInterceptor interface">Section&nbsp;13.4.3, &#8220;Intercepting requests - the HandlerInterceptor interface&#8221;</a> for more information on
    handler mapping interceptors), to change the locale under specific
    circumstances, based on a parameter in the request, for example.</p><p>Locale resolvers and interceptors are all defined in the
    <tt class="literal">org.springframework.web.servlet.i18n</tt> package, and are
    configured in your application context in the normal way. Here is a
    selection of the locale resolvers included in Spring.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-localeresolver-acceptheader"></a>13.6.1.&nbsp;<tt class="classname">AcceptHeaderLocaleResolver</tt></h3></div></div><div></div></div><p>This locale resolver inspects the
      <tt class="literal">accept-language</tt> header in the request that was sent
      by the browser of the client. Usually this header field contains the
      locale of the client's operating system.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-localeresolver-cookie"></a>13.6.2.&nbsp;<tt class="classname">CookieLocaleResolver</tt></h3></div></div><div></div></div><p>This locale resolver inspects a <tt class="classname">Cookie</tt> that might
      exist on the client, to see if a locale is specified. If so, it uses that specific
      locale. Using the properties of this locale resolver, you can specify
      the name of the cookie, as well as the maximum age. Find below an example of
      defining a <tt class="classname">CookieLocaleResolver</tt>.</p><pre class="programlisting">&lt;bean id="localeResolver"&gt;

    &lt;property name="cookieName" value="clientlanguage"/&gt;
    
    <i class="lineannotation"><span class="lineannotation">&lt;!-- in seconds. If set to <tt class="literal">-1</tt>, the cookie is not persisted (deleted when browser shuts down) --&gt;</span></i>
    &lt;property name="cookieMaxAge" value="100000"&gt;

&lt;/bean&gt;</pre><div class="table"><a name="d0e18474"></a><p class="title"><b>Table&nbsp;13.6.&nbsp;<tt class="classname">CookieLocaleResolver</tt> properties</b></p><table summary="CookieLocaleResolver properties" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Property</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>cookieName</td><td>classname + LOCALE</td><td>The name of the cookie</td></tr><tr><td>cookieMaxAge</td><td>Integer.MAX_INT</td><td>The maximum time a cookie will stay persistent on the
              client. If -1 is specified, the cookie will not be persisted. It
              will only be available until the client shuts down his or her
              browser.</td></tr><tr><td>cookiePath</td><td>/</td><td>Using this parameter, you can limit the visibility of the
              cookie to a certain part of your site. When cookiePath is
              specified, the cookie will only be visible to that path, and the
              paths below it.</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-localeresolver-session"></a>13.6.3.&nbsp;<tt class="classname">SessionLocaleResolver</tt></h3></div></div><div></div></div><p>The <tt class="classname">SessionLocaleResolver</tt> allows you to
      retrieve locales from the session that might be associated with the
      user's request.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-localeresolver-interceptor"></a>13.6.4.&nbsp;<tt class="classname">LocaleChangeInterceptor</tt></h3></div></div><div></div></div><p>You can build in changing of locales using the
      <tt class="classname">LocaleChangeInterceptor</tt>. This interceptor needs to be
      added to one of the handler mappings (see <a href="mvc.html#mvc-handlermapping" title="13.4.&nbsp;Handler mappings">Section&nbsp;13.4, &#8220;Handler mappings&#8221;</a>).
      It will detect a parameter in the  request and change the locale
      (it calls <tt class="literal">setLocale()</tt> on the <tt class="interfacename">LocaleResolver</tt>
      that also exists in the context).</p><pre class="programlisting">&lt;bean id="localeChangeInterceptor"
      class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"&gt;
    &lt;property name="paramName" value="siteLanguage"/&gt;
&lt;/bean&gt;

&lt;bean id="localeResolver"
      class="org.springframework.web.servlet.i18n.CookieLocaleResolver"/&gt;

&lt;bean id="urlMapping"
      class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
    &lt;property name="interceptors"&gt;
        &lt;list&gt;
            &lt;ref bean="localeChangeInterceptor"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="mappings"&gt;
        &lt;value&gt;/**/*.view=someController&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>All calls to all <tt class="literal">*.view</tt> resources containing a
        parameter named <tt class="literal">siteLanguage</tt> will now change the
        locale. So a request for the following URL,
        <tt class="literal">http://www.sf.net/home.view?siteLanguage=nl</tt> will change
        the site language to Dutch.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-themeresolver"></a>13.7.&nbsp;Using themes</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-themeresolver-introduction"></a>13.7.1.&nbsp;Introduction</h3></div></div><div></div></div><p>The <span class="emphasis"><em>theme</em></span> support provided by the Spring web
      MVC framework enables you to further enhance the user experience by
      allowing the look and feel of your application to be
      <span class="emphasis"><em>themed</em></span>. A theme is basically a collection of static
      resources affecting the visual style of the application, typically style
      sheets and images.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-themeresolver-defining"></a>13.7.2.&nbsp;Defining themes</h3></div></div><div></div></div><p>When you want to use themes in your web application you'll have to
      set up a <tt class="interfacename">org.springframework.ui.context.ThemeSource</tt>.
      The <tt class="interfacename">WebApplicationContext</tt> interface extends
      <tt class="interfacename">ThemeSource</tt> but delegates its responsibilities to a
      dedicated implementation. By default the delegate will be a
      <tt class="classname">org.springframework.ui.context.support.ResourceBundleThemeSource</tt>
      that loads properties files from the root of the classpath. If you want
      to use a custom <tt class="interfacename">ThemeSource</tt> implementation or if you
      need to configure the basename prefix of the
      <tt class="classname">ResourceBundleThemeSource</tt>, you can register a bean in
      the application context with the reserved name "themeSource". The web
      application context will automatically detect that bean and start using
      it.</p><p>When using the <tt class="classname">ResourceBundleThemeSource</tt>, a
      theme is defined in a simple properties file. The properties file lists
      the resources that make up the theme. Here is an example:</p><pre class="programlisting">styleSheet=/themes/cool/style.css
background=/themes/cool/img/coolBg.jpg</pre><p>The keys of the properties are the names used to refer to
      the themed elements from view code. For a JSP this would typically be
      done using the <tt class="literal">spring:theme</tt> custom tag, which is very
      similar to the <tt class="literal">spring:message</tt> tag. The following JSP
      fragment uses the theme defined above to customize the look and feel:</p><pre class="programlisting">&lt;%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;link rel="stylesheet" href="&lt;spring:theme code="styleSheet"/&gt;" type="text/css"/&gt;
   &lt;/head&gt;
   &lt;body background="&lt;spring:theme code="background"/&gt;"&gt;
      ...
   &lt;/body&gt;
&lt;/html&gt;</pre><p>By default, the <tt class="classname">ResourceBundleThemeSource</tt> uses
      an empty basename prefix. As a result the properties files will be
      loaded from the root of the classpath, so we'll have to put our
      <tt class="literal">cool.properties</tt> theme definition in a directory at
      the root of the classpath, e.g. in <tt class="literal">/WEB-INF/classes</tt>.
      Note that the <tt class="classname">ResourceBundleThemeSource</tt> uses the
      standard Java resource bundle loading mechanism, allowing for full
      internationalization of themes. For instance, we could have a
      <tt class="literal">/WEB-INF/classes/cool_nl.properties</tt> that references a
      special background image, e.g. with Dutch text on it.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-themeresolver-resolving"></a>13.7.3.&nbsp;Theme resolvers</h3></div></div><div></div></div><p>Now that we have our themes defined, the only thing left to do is
      decide which theme to use. The <tt class="classname">DispatcherServlet</tt> will
      look for a bean named "themeResolver" to find out which
      <tt class="interfacename">ThemeResolver</tt> implementation to use. A theme resolver
      works in much the same way as a <tt class="interfacename">LocaleResolver</tt>. It can
      detect the theme that should be used for a particular request and can
      also alter the request's theme. The following theme resolvers are
      provided by Spring:</p><div class="table"><a name="d0e18637"></a><p class="title"><b>Table&nbsp;13.7.&nbsp;<tt class="interfacename">ThemeResolver</tt> implementations</b></p><table summary="ThemeResolver implementations" border="1"><colgroup><col><col></colgroup><thead><tr><th>Class</th><th>Description</th></tr></thead><tbody><tr><td><tt class="classname">FixedThemeResolver</tt></td><td>Selects a fixed theme, set using the "defaultThemeName" property.</td></tr><tr><td><tt class="classname">SessionThemeResolver</tt></td><td>The theme is maintained in the users HTTP session. It
              only needs to be set once for each session, but is not persisted
              between sessions.</td></tr><tr><td><tt class="classname">CookieThemeResolver</tt></td><td>The selected theme is stored in a cookie on the user-agent's machine.</td></tr></tbody></table></div><p>Spring also provides a <tt class="classname">ThemeChangeInterceptor</tt>,
      which allows changing the theme on every request by including a simple
      request parameter.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-multipart"></a>13.8.&nbsp;Spring's multipart (fileupload) support</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-multipart-introduction"></a>13.8.1.&nbsp;Introduction</h3></div></div><div></div></div><p>
			Spring has built-in multipart support to handle fileuploads in web
			applications. The design for the multipart support is done with
			pluggable <tt class="interfacename">MultipartResolver</tt> objects,
			defined in the <tt class="literal">org.springframework.web.multipart</tt>
			package. Out of the	box, Spring provides
			<tt class="interfacename">MultipartResolver</tt>s for use with
			<span class="emphasis"><em>Commons FileUpload</em></span>
			(<a href="http://jakarta.apache.org/commons/fileupload" target="_top">http://jakarta.apache.org/commons/fileupload</a>) and
			<span class="emphasis"><em>COS FileUpload</em></span>
			(<a href="http://www.servlets.com/cos" target="_top">http://www.servlets.com/cos</a>). How uploading
			files is supported will be described in the rest of this chapter.
      </p><p>
			By default, no multipart handling will be done by Spring, as some
			developers will want to handle multiparts themselves. You will have to
			enable it yourself by adding a multipart resolver to the web
			application's context. After you have done that, each request will be
			inspected to see if it contains a multipart. If no multipart is found,
			the request will continue as expected. However, if a multipart is found
			in the request, the <tt class="classname">MultipartResolver</tt> that has
			been declared in your context will be used. After that, the multipart
			attribute in your request will be treated like any other attribute.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-multipart-resolver"></a>13.8.2.&nbsp;Using the <tt class="interfacename">MultipartResolver</tt></h3></div></div><div></div></div><p>
			The following example shows how to use the <tt class="classname">CommonsMultipartResolver</tt>:
      </p><pre class="programlisting">&lt;bean id="multipartResolver"
    class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- one of the properties available; the maximum file size in bytes --&gt;</span></i>
    &lt;property name="maxUploadSize" value="100000"/&gt;
&lt;/bean&gt;</pre><p>
			This is an example using the <tt class="classname">CosMultipartResolver</tt>:
	  </p><pre class="programlisting">&lt;bean id="multipartResolver" class="org.springframework.web.multipart.cos.CosMultipartResolver"&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- one of the properties available; the maximum file size in bytes --&gt;</span></i>
    &lt;property name="maxUploadSize" value="100000"/&gt;
&lt;/bean&gt;</pre><p>
			Of course you also need to put the appropriate jars in your classpath
			for the multipart resolver to work. In the case of the
			<tt class="classname">CommonsMultipartResolver</tt>, you need to use
			<tt class="literal">commons-fileupload.jar</tt>; in the case of the
			<tt class="classname">CosMultipartResolver</tt>, use <tt class="literal">cos.jar</tt>.
	  </p><p>
			Now that you have seen how to set Spring up to handle multipart
			requests, let's talk about how to actually use it. When the Spring
			<tt class="classname">DispatcherServlet</tt> detects a multi-part request,
			it activates the resolver that has been declared in your context and
			hands over the request. What the resolver then does is wrap the current
			<tt class="classname">HttpServletRequest</tt> into a
			<tt class="classname">MultipartHttpServletRequest</tt> that has support for
			multipart file uploads. Using the <tt class="classname">MultipartHttpServletRequest</tt>
			you can get information about the multiparts contained by this request
			and actually get access to the multipart files themselves in your controllers.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-multipart-forms"></a>13.8.3.&nbsp;Handling a file upload in a form</h3></div></div><div></div></div><p>
			After the <tt class="classname">MultipartResolver</tt> has finished doing its
			job, the request will be processed like any other. To use it, you create a form
			with an upload field (see immediately below), then let Spring bind the file
			onto your form (backing object). To actually let the user upload a file, we
			have to create a (HTML) form:
      </p><pre class="programlisting">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Upload a file please&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Please upload a file&lt;/h1&gt;
        &lt;form method="post" action="upload.form" enctype="multipart/form-data"&gt;
            &lt;input type="file" name="file"/&gt;
            &lt;input type="submit"/&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre><p>
			As you can see, we've created a field named after the property of the bean
			that holds the <tt class="literal">byte[]</tt>. Furthermore we've added the
			encoding attribute (<tt class="literal">enctype="multipart/form-data"</tt>) which is
			necessary to let the browser know how to encode the multipart fields (do not
			forget this!).
		</p><p>
			Just as with any other property that's not automagically convertible to a
			string or primitive type, to be able to put binary data in your objects
			you have to register a custom editor with the
			<tt class="classname">ServletRequestDatabinder</tt>. There are a couple of
			editors available for handling files and setting the results on an object.
			There's a <tt class="classname">StringMultipartEditor</tt> capable of converting
			files to Strings (using a user-defined character set) and there is a
			<tt class="classname">ByteArrayMultipartEditor</tt> which converts files to byte
			arrays. They function just as the <tt class="classname">CustomDateEditor</tt>
			does.
      </p><p>
			So, to be able to upload files using a (HTML) form, declare the resolver,
			a url mapping to a controller that will process the bean, and the controller
			itself.
	  </p><pre class="programlisting">&lt;beans&gt;
	<i class="lineannotation"><span class="lineannotation">&lt;!-- lets use the Commons-based implementation of the MultipartResolver interface --&gt;</span></i>
    &lt;bean id="multipartResolver"
        class="org.springframework.web.multipart.commons.CommonsMultipartResolver"/&gt;

    &lt;bean id="urlMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
        &lt;property name="mappings"&gt;
            &lt;value&gt;
                /upload.form=fileUploadController
            &lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="fileUploadController" class="examples.FileUploadController"&gt;
        &lt;property name="commandClass" value="examples.FileUploadBean"/&gt;
        &lt;property name="formView" value="fileuploadform"/&gt;
        &lt;property name="successView" value="confirmation"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>
			After that, create the controller and the actual class to hold the file property.
	  </p><pre class="programlisting">public class FileUploadController extends SimpleFormController {

    protected ModelAndView onSubmit(
        HttpServletRequest request,
        HttpServletResponse response,
        Object command,
        BindException errors) throws ServletException, IOException {

        <i class="lineannotation"><span class="lineannotation"> // cast the bean</span></i>
        FileUploadBean bean = (FileUploadBean) command;

        <i class="lineannotation"><span class="lineannotation"> let's see if there's content there</span></i>
        byte[] file = bean.getFile();
        if (file == null) {
            <i class="lineannotation"><span class="lineannotation"> // hmm, that's strange, the user did not upload anything</span></i>
        }

        <i class="lineannotation"><span class="lineannotation"> // well, let's do nothing with the bean for now and return</span></i>
        return super.onSubmit(request, response, command, errors);
    }

    protected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder)
        throws ServletException {
        // to actually be able to convert Multipart instance to byte[]
        // we have to register a custom editor
        binder.registerCustomEditor(byte[].class, new ByteArrayMultipartFileEditor());
        // now Spring knows how to handle multipart object and convert them
    }

}

public class FileUploadBean {

    private byte[] file;

    public void setFile(byte[] file) {
        this.file = file;
    }

    public byte[] getFile() {
        return file;
    }
}</pre><p>
			As you can see, the <tt class="classname">FileUploadBean</tt> has a property typed
			<tt class="literal">byte[]</tt> that holds the file. The controller registers
			a custom editor to let Spring know how to actually convert the multipart
			objects the resolver has found to properties specified by the bean. In
			this example, nothing is done with the <tt class="literal">byte[]</tt>
			property of the bean itself, but in practice you can do whatever you
			want (save it in a database, mail it to somebody, etc).
      </p><p>
			An equivalent example in which a file is bound straight to a String-typed
			property on a (form backing) object might look like:
      </p><pre class="programlisting">public class FileUploadController extends SimpleFormController {

    protected ModelAndView onSubmit(
        HttpServletRequest request,
        HttpServletResponse response,
        Object command,
        BindException errors) throws ServletException, IOException {

        <i class="lineannotation"><span class="lineannotation"> // cast the bean</span></i>
        FileUploadBean bean = (FileUploadBean) command;

        <i class="lineannotation"><span class="lineannotation"> let's see if there's content there</span></i>
        String file = bean.getFile();
        if (file == null) {
            <i class="lineannotation"><span class="lineannotation"> // hmm, that's strange, the user did not upload anything</span></i>
        }

        <i class="lineannotation"><span class="lineannotation"> // well, let's do nothing with the bean for now and return</span></i>
        return super.onSubmit(request, response, command, errors);
    }

    protected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder)
        throws ServletException {
        // to actually be able to convert Multipart instance to a String
        // we have to register a custom editor
        binder.registerCustomEditor(String.class, new StringMultipartFileEditor());
        // now Spring knows how to handle multipart object and convert them
    }

}

public class FileUploadBean {

    private String file;

    public void setFile(String file) {
        this.file = file;
    }

    public String getFile() {
        return file;
    }
}</pre><p>
            Of course, this last example only makes (logical) sense in the context of uploading
            a plain text file (it wouldn't work so well in the case of uploading an image file).
        </p><p>
            The third (and final) option is where one binds directly to a 
            <tt class="interfacename">MultipartFile</tt> property declared on the
            (form backing) object's class. In this case one does not need to register any
            custom <tt class="interfacename">PropertyEditor</tt> because there is no
            type conversion to be performed.
        </p><pre class="programlisting">public class FileUploadController extends SimpleFormController {

    protected ModelAndView onSubmit(
        HttpServletRequest request,
        HttpServletResponse response,
        Object command,
        BindException errors) throws ServletException, IOException {

        <i class="lineannotation"><span class="lineannotation"> // cast the bean</span></i>
        FileUploadBean bean = (FileUploadBean) command;

        <i class="lineannotation"><span class="lineannotation"> let's see if there's content there</span></i>
        MultipartFile file = bean.getFile();
        if (file == null) {
            <i class="lineannotation"><span class="lineannotation"> // hmm, that's strange, the user did not upload anything</span></i>
        }

        <i class="lineannotation"><span class="lineannotation"> // well, let's do nothing with the bean for now and return</span></i>
        return super.onSubmit(request, response, command, errors);
    }
}

public class FileUploadBean {

    private MultipartFile file;

    public void setFile(MultipartFile file) {
        this.file = file;
    }

    public MultipartFile getFile() {
        return file;
    }
}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-formtaglib"></a>13.9.&nbsp;Using Spring's form tag library</h2></div></div><div></div></div><p>As of version 2.0, Spring provides a comprehensive set of data binding-aware tags for handling
    form elements when using JSP and Spring Web MVC. Each tag provides support for the set of attributes
    of its corresponding HTML tag counterpart, making the tags familiar and intuitive to use. The
    tag-generated HTML is HTML 4.01/XHTML 1.0 compliant.</p><p>Unlike other form/input tag libraries, Spring's form tag library is integrated with Spring
    Web MVC, giving the tags access to the command object and reference data your controller deals
    with. As you will see in the following examples, the form tags make JSPs easier to develop, read
    and maintain. </p><p>Let's go through the form tags and look at an example of how each tag is used.
    We have included generated HTML snippets where certain tags require further commentary.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-formtaglib-configuration"></a>13.9.1.&nbsp;Configuration</h3></div></div><div></div></div><p>The form tag library comes bundled in <tt class="literal">spring.jar</tt>. The library descriptor is called
    <tt class="literal">spring-form.tld</tt>.</p><p>To use the tags from this library, add the following directive to the top of your JSP page:</p><pre class="programlisting">&lt;%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %&gt;</pre><p>... where <tt class="literal">form</tt> is the tag name prefix you want to use for the tags from this library.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-formtaglib-formtag"></a>13.9.2.&nbsp;The <tt class="literal">form</tt> tag</h3></div></div><div></div></div><p>
        This tag renders an HTML 'form' tag and exposes a binding path to inner tags for binding.
        It puts the command object in the <tt class="literal">PageContext</tt> so that the command object
        can be accessed by inner tags. <span class="emphasis"><em>All the other tags in this library are nested tags
        of the <tt class="literal">form</tt> tag</em></span>.
    </p><p>
        Let's assume we have a domain object called <tt class="classname">User</tt>. It is a JavaBean with
        properties such as <tt class="literal">firstName</tt> and <tt class="literal">lastName</tt>. We will
        use it as the form backing object of our form controller which returns
        <tt class="literal">form.jsp</tt>. Below is an example of what <tt class="literal">form.jsp</tt> would
        look like:
    </p><pre class="programlisting">&lt;form:form&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;First Name:&lt;/td&gt;
            &lt;td&gt;&lt;form:input path="firstName" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Last Name:&lt;/td&gt;
            &lt;td&gt;&lt;form:input path="lastName" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan="3"&gt;
                &lt;input type="submit" value="Save Changes" /&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form:form&gt;</pre><p>
        The <tt class="literal">firstName</tt> and <tt class="literal">lastName</tt> values are
        retrieved from the command object placed in the <tt class="interfacename">PageContext</tt>
        by the page controller. Keep reading to see more complex examples of how inner
        tags are used with the <tt class="literal">form</tt> tag.
    </p><p>The generated HTML looks like a standard form:</p><pre class="programlisting">&lt;form method="POST"&gt;
    &lt;table&gt;
      &lt;tr&gt;
          &lt;td&gt;First Name:&lt;/td&gt;
          &lt;td&gt;&lt;input name="firstName" type="text" value="Harry"/&gt;&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Last Name:&lt;/td&gt;
          &lt;td&gt;&lt;input name="lastName" type="text" value="Potter"/&gt;&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td colspan="3"&gt;
            &lt;input type="submit" value="Save Changes" /&gt;
          &lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;</pre><p>The preceding JSP assumes that the variable name of the form backing object is 
    <tt class="literal">'command'</tt>. If you have put the form backing object into the model
    under another name (definitely a best practice), then you can bind the form to the
    named variable like so:</p><pre class="programlisting">&lt;form:form <i class="lineannotation"><span class="lineannotation"><span class="bold"><b>commandName="user"</b></span></span></i>&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;First Name:&lt;/td&gt;
            &lt;td&gt;&lt;form:input path="firstName" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Last Name:&lt;/td&gt;
            &lt;td&gt;&lt;form:input path="lastName" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan="3"&gt;
                &lt;input type="submit" value="Save Changes" /&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form:form&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-formtaglib-inputtag"></a>13.9.3.&nbsp;The <tt class="literal">input</tt> tag</h3></div></div><div></div></div><p>This tag renders an HTML 'input' tag with type 'text' using the bound value.
    For an example of this tag, see <a href="mvc.html#mvc-formtaglib-formtag" title="13.9.2.&nbsp;The form tag">Section&nbsp;13.9.2, &#8220;The form tag&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-formtaglib-checkboxtag"></a>13.9.4.&nbsp;The <tt class="literal">checkbox</tt> tag</h3></div></div><div></div></div><p>This tag renders an HTML 'input' tag with type 'checkbox'.</p><p>Let's assume our <tt class="classname">User</tt> has preferences such as newsletter subscription
      and a list of hobbies. Below is an example of the <tt class="classname">Preferences</tt> class:</p></div><pre class="programlisting">public class Preferences {

    private boolean receiveNewsletter;

    private String[] interests;

    private String favouriteWord;

    public boolean isReceiveNewsletter() {
        return receiveNewsletter;
    }

    public void setReceiveNewsletter(boolean receiveNewsletter) {
        this.receiveNewsletter = receiveNewsletter;
    }

    public String[] getInterests() {
        return interests;
    }

    public void setInterests(String[] interests) {
        this.interests = interests;
    }

    public String getFavouriteWord() {
        return favouriteWord;
    }

    public void setFavouriteWord(String favouriteWord) {
        this.favouriteWord = favouriteWord;
    }
}</pre><p>The <tt class="literal">form.jsp</tt> would look like:</p><pre class="programlisting">&lt;form:form&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;Subscribe to newsletter?:&lt;/td&gt;
            <i class="lineannotation"><span class="lineannotation">&lt;%-- Approach 1: Property is of type <tt class="classname">java.lang.Boolean</tt> --%&gt;</span></i>
            &lt;td&gt;&lt;form:checkbox path="preferences.receiveNewsletter"/&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;

        &lt;tr&gt;
            &lt;td&gt;Interests:&lt;/td&gt;
            &lt;td&gt;
                <i class="lineannotation"><span class="lineannotation">&lt;%-- Approach 2: Property is of an array or of type <tt class="interfacename">java.util.Collection</tt> --%&gt;</span></i>
                Quidditch: &lt;form:checkbox path="preferences.interests" value="Quidditch"/&gt;
                Herbology: &lt;form:checkbox path="preferences.interests" value="Herbology"/&gt;
                Defence Against the Dark Arts: &lt;form:checkbox path="preferences.interests"
                    value="Defence Against the Dark Arts"/&gt;
            &lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Favourite Word:&lt;/td&gt;
            &lt;td&gt;
                <i class="lineannotation"><span class="lineannotation">&lt;%-- Approach 3: Property is of type <tt class="classname">java.lang.Object</tt> --%&gt;</span></i>
                Magic: &lt;form:checkbox path="preferences.favouriteWord" value="Magic"/&gt;
            &lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form:form&gt;</pre><p>There are 3 approaches to the <tt class="literal">checkbox</tt> tag which should meet all your checkbox needs.

          </p><div class="itemizedlist"><ul type="disc"><li><p>Approach One  -  When the bound value is of type <tt class="literal">java.lang.Boolean</tt>,
            the <tt class="literal">input(checkbox)</tt> is marked as 'checked' if the bound value is
            <tt class="literal">true</tt>. The <tt class="literal">value</tt> attribute corresponds to the
            resolved value of the <tt class="literal">setValue(Object)</tt> value property.</p></li><li><p>Approach Two - When the bound value is of type <tt class="literal">array</tt> or
            <tt class="interfacename">java.util.Collection</tt>, the <tt class="literal">input(checkbox)</tt> is marked as 'checked'
            if the configured <tt class="literal">setValue(Object)</tt> value is present in the bound
            <tt class="interfacename">Collection</tt>.</p></li><li><p>Approach Three - For any other bound value type, the <tt class="literal">input(checkbox)</tt>
            is marked as 'checked' if the configured <tt class="literal">setValue(Object)</tt> is equal to the
            bound value.</p></li></ul></div><p>
      </p><p>Note that regardless of the approach, the same HTML structure is generated.
      Below is an HTML snippet of some checkboxes:</p><pre class="programlisting">&lt;tr&gt;
    &lt;td&gt;Interests:&lt;/td&gt;
    &lt;td&gt;
        Quidditch: &lt;input name="preferences.interests" type="checkbox" value="Quidditch"/&gt;
        &lt;input type="hidden" value="1" name="_preferences.interests"/&gt;
        Herbology: &lt;input name="preferences.interests" type="checkbox" value="Herbology"/&gt;
        &lt;input type="hidden" value="1" name="_preferences.interests"/&gt;
        Defence Against the Dark Arts: &lt;input name="preferences.interests" type="checkbox"
            value="Defence Against the Dark Arts"/&gt;
        &lt;input type="hidden" value="1" name="_preferences.interests"/&gt;
    &lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;</pre><p>What you might not expect to see is the additional hidden field after each checkbox.
    When a checkbox in an HTML page is <span class="emphasis"><em>not</em></span> checked, its value will not be
    sent to the server as part of the HTTP request parameters once the form is submitted, so we
    need a workaround for this quirk in HTML in order for Spring form data binding to work. The
    <tt class="literal">checkbox</tt> tag follows the existing Spring convention of including a hidden
    parameter prefixed by an underscore ("_") for each checkbox. By doing this, you are
    effectively telling Spring that &#8220;<span class="quote"><span class="emphasis"><em>the checkbox was visible in the form and I
    want my object to which the form data will be bound to reflect the state of the checkbox no
    matter what</em></span></span>&#8221;.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-formtaglib-radiobuttontag"></a>13.9.5.&nbsp;The <tt class="literal">radiobutton</tt> tag</h3></div></div><div></div></div><p>This tag renders an HTML 'input' tag with type 'radio'.</p><p>A typical usage pattern will involve multiple tag instances bound to the same property but with different
    values.</p><pre class="programlisting">&lt;tr&gt;
    &lt;td&gt;Sex:&lt;/td&gt;
    &lt;td&gt;Male: &lt;form:radiobutton path="sex" value="M"/&gt; &lt;br/&gt;
        Female: &lt;form:radiobutton path="sex" value="F"/&gt; &lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-formtaglib-passwordtag"></a>13.9.6.&nbsp;The <tt class="literal">password</tt> tag</h3></div></div><div></div></div><p>This tag renders an HTML 'input' tag with type 'password' using the bound value.</p><pre class="programlisting">&lt;tr&gt;
    &lt;td&gt;Password:&lt;/td&gt;
    &lt;td&gt;
        &lt;form:password path="password" /&gt;
    &lt;/td&gt;
&lt;/tr&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-formtaglib-selecttag"></a>13.9.7.&nbsp;The <tt class="literal">select</tt> tag</h3></div></div><div></div></div><p>This tag renders an HTML 'select' element. It supports data binding to the selected
    option as well as the use of nested <tt class="literal">option</tt> and <tt class="literal">options</tt>
    tags.</p><p>Let's assume a <tt class="classname">User</tt> has a list of skills.</p><pre class="programlisting">&lt;tr&gt;
    &lt;td&gt;Skills:&lt;/td&gt;
    &lt;td&gt;&lt;form:select path="skills" items="${skills}"/&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;</pre><p>If the <tt class="literal">User's</tt> skill were in Herbology, the HTML source of the 'Skills'
    row would look like:</p><pre class="programlisting">&lt;tr&gt;
    &lt;td&gt;Skills:&lt;/td&gt;
    &lt;td&gt;&lt;select name="skills" multiple="true"&gt;
        &lt;option value="Potions"&gt;Potions&lt;/option&gt;
        &lt;option value="Herbology" selected="true"&gt;Herbology&lt;/option&gt;
        &lt;option value="Quidditch"&gt;Quidditch&lt;/option&gt;&lt;/select&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-formtaglib-optiontag"></a>13.9.8.&nbsp;The <tt class="literal">option</tt> tag</h3></div></div><div></div></div><p>This tag renders an HTML 'option'. It sets 'selected' as appropriate based on the bound value.</p><pre class="programlisting">&lt;tr&gt;
    &lt;td&gt;House:&lt;/td&gt;
    &lt;td&gt;
        &lt;form:select path="house"&gt;
            &lt;form:option value="Gryffindor"/&gt;
            &lt;form:option value="Hufflepuff"/&gt;
            &lt;form:option value="Ravenclaw"/&gt;
            &lt;form:option value="Slytherin"/&gt;
        &lt;/form:select&gt;
    &lt;/td&gt;
&lt;/tr&gt;</pre><p>If the <tt class="literal">User's</tt> house was in Gryffindor, the HTML source of the 'House'
    row would look like:</p><pre class="programlisting">&lt;tr&gt;
    &lt;td&gt;House:&lt;/td&gt;
    &lt;td&gt;
        &lt;select name="house"&gt;
            &lt;option value="Gryffindor" selected="true"&gt;Gryffindor&lt;/option&gt;
            &lt;option value="Hufflepuff"&gt;Hufflepuff&lt;/option&gt;
            &lt;option value="Ravenclaw"&gt;Ravenclaw&lt;/option&gt;
            &lt;option value="Slytherin"&gt;Slytherin&lt;/option&gt;
        &lt;/select&gt;
    &lt;/td&gt;
 &lt;/tr&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-formtaglib-optionstag"></a>13.9.9.&nbsp;The <tt class="literal">options</tt> tag</h3></div></div><div></div></div><p>This tag renders a list of HTML 'option' tags. It sets the 'selected' attribute
    as appropriate based on the bound value.</p><pre class="programlisting">&lt;tr&gt;
    &lt;td&gt;Country:&lt;/td&gt;
    &lt;td&gt;
        &lt;form:select path="country"&gt;
            &lt;form:option value="-" label="--Please Select"/&gt;
            &lt;form:options items="${countryList}" itemValue="code" itemLabel="name"/&gt;
        &lt;/form:select&gt;
    &lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;</pre><p>If the <tt class="classname">User</tt> lived in the UK, the HTML source of the 'Country'
    row would look like:</p><pre class="programlisting"> &lt;tr&gt;
    &lt;td&gt;Country:&lt;/td&gt;
    &lt;tr&gt;
        &lt;td&gt;Country:&lt;/td&gt;
        &lt;td&gt;
            &lt;select name="country"&gt;
                &lt;option value="-"&gt;--Please Select&lt;/option&gt;
                &lt;option value="AT"&gt;Austria&lt;/option&gt;
                &lt;option value="UK" selected="true"&gt;United Kingdom&lt;/option&gt;
                &lt;option value="US"&gt;United States&lt;/option&gt;
            &lt;/select&gt;
        &lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;</pre><p>As the example shows, the combined usage of an <tt class="literal">option</tt> tag with the
      <tt class="literal">options</tt> tag generates the same standard HTML, but allows you to explicitly
      specify a value in the JSP that is for display only (where it belongs) such as the default string in
      the example: "-- Please Select".
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-formtaglib-textAreatag"></a>13.9.10.&nbsp;The <tt class="literal">textarea</tt> tag</h3></div></div><div></div></div><p>This tag renders an HTML 'textarea'.</p><pre class="programlisting">&lt;tr&gt;
    &lt;td&gt;Notes:&lt;/td&gt;
    &lt;td&gt;&lt;form:textarea path="notes" rows="3" cols="20" /&gt;&lt;/td&gt;
    &lt;td&gt;&lt;form:errors path="notes" /&gt;&lt;/td&gt;
&lt;/tr&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-formtaglib-hiddeninputtag"></a>13.9.11.&nbsp;The <tt class="literal">hidden</tt> tag</h3></div></div><div></div></div><p>This tag renders an HTML 'input' tag with type 'hidden' using the bound value.
    To submit an unbound hidden value, use the HTML <tt class="literal">input</tt> tag with
    type 'hidden'.</p><pre class="programlisting">&lt;form:hidden path="house" /&gt;
</pre><p>If we choose to submit the 'house' value as a hidden one, the HTML would look like:</p><pre class="programlisting">&lt;input name="house" type="hidden" value="Gryffindor"/&gt;
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-formtaglib-errorstag"></a>13.9.12.&nbsp;The <tt class="literal">errors</tt> tag</h3></div></div><div></div></div><p>This tag renders field errors in an HTML 'span' tag. It provides access to the errors created in your
    controller or those that were created by any validators associated with your controller.</p><p>Let's assume we want to display all error messages for the <tt class="literal">firstName</tt> and
    <tt class="literal">lastName</tt> fields once we submit the form. We have a validator for instances of the
    <tt class="classname">User</tt> class called <tt class="classname">UserValidator</tt>.</p><pre class="programlisting">public class UserValidator implements Validator {

    public boolean supports(Class candidate) {
        return User.class.isAssignableFrom(candidate);
    }

    public void validate(Object obj, Errors errors) {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "required", "Field is required.");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "lastName", "required", "Field is required.");
    }
}</pre><p>The <tt class="literal">form.jsp</tt> would look like:</p><pre class="programlisting">&lt;form:form&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;First Name:&lt;/td&gt;
            &lt;td&gt;&lt;form:input path="firstName" /&gt;&lt;/td&gt;
            <i class="lineannotation"><span class="lineannotation">&lt;%-- Show errors for firstName field --%&gt;</span></i>
            &lt;td&gt;&lt;form:errors path="firstName" /&gt;&lt;/td&gt;
        &lt;/tr&gt;

        &lt;tr&gt;
            &lt;td&gt;Last Name:&lt;/td&gt;
            &lt;td&gt;&lt;form:input path="lastName" /&gt;&lt;/td&gt;
            <i class="lineannotation"><span class="lineannotation">&lt;%-- Show errors for lastName field --%&gt;</span></i>
            &lt;td&gt;&lt;form:errors path="lastName"  /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan="3"&gt;
                &lt;input type="submit" value="Save Changes" /&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form:form&gt;</pre><p>If we submit a form with empty values in the <tt class="literal">firstHame</tt> and
    <tt class="literal">lastName</tt> fields, this is what the HTML would look like:</p><pre class="programlisting">&lt;form method="POST"&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;First Name:&lt;/td&gt;
            &lt;td&gt;&lt;input name="firstName" type="text" value=""/&gt;&lt;/td&gt;
            <i class="lineannotation"><span class="lineannotation">&lt;%-- Associated errors to firstName field displayed --%&gt;</span></i>
            &lt;td&gt;&lt;span name="firstName.errors"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;
        &lt;/tr&gt;

        &lt;tr&gt;
            &lt;td&gt;Last Name:&lt;/td&gt;
            &lt;td&gt;&lt;input name="lastName" type="text" value=""/&gt;&lt;/td&gt;
            <i class="lineannotation"><span class="lineannotation">&lt;%-- Associated errors to lastName field displayed --%&gt;</span></i>
            &lt;td&gt;&lt;span name="lastName.errors"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan="3"&gt;
                &lt;input type="submit" value="Save Changes" /&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;</pre><p>What if we want to display the entire list of errors for a given page? The example
    below shows that the <tt class="literal">errors</tt> tag also supports some basic wildcarding
    functionality.</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">path="*"</tt> - displays all errors</p></li><li><p><tt class="literal">path="lastName*"</tt> - displays all errors associated with
            the <tt class="literal">lastName</tt> field</p></li></ul></div><p>The example below will display a list of errors at the top of the page, followed by
    field-specific errors next to the fields:</p><pre class="programlisting">&lt;form:form&gt;
    &lt;form:errors path="*" cssClass="errorBox" /&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;First Name:&lt;/td&gt;
            &lt;td&gt;&lt;form:input path="firstName" /&gt;&lt;/td&gt;
            &lt;td&gt;&lt;form:errors path="firstName" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Last Name:&lt;/td&gt;
            &lt;td&gt;&lt;form:input path="lastName" /&gt;&lt;/td&gt;
            &lt;td&gt;&lt;form:errors path="lastName"  /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan="3"&gt;
                &lt;input type="submit" value="Save Changes" /&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form:form&gt;</pre><p>The HTML would look like:</p><pre class="programlisting">&lt;form method="POST"&gt;
    &lt;span name="*.errors" class="errorBox"&gt;Field is required.&lt;br/&gt;Field is required.&lt;/span&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;First Name:&lt;/td&gt;
            &lt;td&gt;&lt;input name="firstName" type="text" value=""/&gt;&lt;/td&gt;
            &lt;td&gt;&lt;span name="firstName.errors"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;
        &lt;/tr&gt;

        &lt;tr&gt;
            &lt;td&gt;Last Name:&lt;/td&gt;
            &lt;td&gt;&lt;input name="lastName" type="text" value=""/&gt;&lt;/td&gt;
            &lt;td&gt;&lt;span name="lastName.errors"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan="3"&gt;
                &lt;input type="submit" value="Save Changes" /&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
&lt;/form&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-exceptionhandlers"></a>13.10.&nbsp;Handling exceptions</h2></div></div><div></div></div><p>Spring provides <tt class="literal">HandlerExceptionResolvers</tt> to ease
    the pain of unexpected exceptions occurring while your request is being
    handled by a controller which matched the request.
    <tt class="literal">HandlerExceptionResolvers</tt> somewhat resemble the
    exception mappings you can define in the web application descriptor
    <tt class="literal">web.xml</tt>. However, they provide a more flexible way to
    handle exceptions. They provide information about what handler was
    executing when the exception was thrown. Furthermore, a programmatic way
    of handling exception gives you many more options for how to respond
    appropriately before the request is forwarded to another URL (the same end
    result as when using the servlet specific exception mappings).</p><p>Besides implementing the <tt class="interfacename">HandlerExceptionResolver</tt>
    interface, which is only a matter of implementing the
    <tt class="literal">resolveException(Exception, Handler)</tt> method and returning a
    <tt class="classname">ModelAndView</tt>, you may also use the
    <tt class="classname">SimpleMappingExceptionResolver</tt>. This resolver enables you
    to take the class name of any exception that might be thrown and map it to a view
    name. This is functionally equivalent to the exception mapping feature from the
    Servlet API, but it's also possible to implement more fine grained mappings of
    exceptions from different handlers.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-coc"></a>13.11.&nbsp;Convention over configuration</h2></div></div><div></div></div><p>For a lot of projects, sticking to established conventions and
        having reasonable defaults is just what they (the projects) need...
        this theme of convention-over-configuration now has explicit support in
        Spring Web MVC. What this means is that if you establish a set of naming
        conventions and suchlike, you can <span class="emphasis"><em>substantially</em></span>
        cut down on the amount of configuration that is required to set up handler
        mappings, view resolvers, <tt class="classname">ModelAndView</tt> instances,
        etc. This is a great boon with regards to rapid prototyping, and can also
        lend a degree of (always good-to-have) consistency across a codebase should
        you choose to move forward with it into production.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="http://static.springframework.org/spring/docs/2.0.x/images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>The Spring distribution ships with a web application that
            showcases the convention over configuration support described in
            this section. The application can be found in the
            <tt class="literal">'samples/showcases/mvc-convention'</tt> directory.</p></td></tr></table></div><p>This convention over configuration support address the three core areas
        of MVC - namely, the models, views, and controllers.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-coc-ccnhm"></a>13.11.1.&nbsp;The Controller - <tt class="classname">ControllerClassNameHandlerMapping</tt></h3></div></div><div></div></div><p>The <tt class="classname">ControllerClassNameHandlerMapping</tt> class
            is a <tt class="interfacename">HandlerMapping</tt> implementation that
            uses a convention to determine the mapping between request URLs and
            the <tt class="interfacename">Controller</tt> instances that are to handle
            those requests.</p><p>An example; consider the following (simplistic)
            <tt class="interfacename">Controller</tt> implementation. Take especial
            notice of the <span class="emphasis"><em>name</em></span> of the class.</p><pre class="programlisting">public class <span class="bold"><b>ViewShoppingCartController</b></span> implements Controller {

    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {
        <i class="lineannotation"><span class="lineannotation">// the implementation is not hugely important for this example...</span></i>
    }
}</pre><p>Here is a snippet from the attendent Spring Web MVC configuration file...</p><pre class="programlisting">&lt;bean class="org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping"/&gt;
                
&lt;bean id="<span class="bold"><b>viewShoppingCart</b></span>" class="x.y.z.ViewShoppingCartController"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- inject dependencies as required... --&gt;</span></i>
&lt;/bean&gt;</pre><p>The <tt class="classname">ControllerClassNameHandlerMapping</tt> finds all of the
            various handler (or <tt class="interfacename">Controller</tt>) beans defined in its
            application context and strips <tt class="literal">'Controller'</tt> off the name to
            define its handler mappings.</p><p>Let's look at some more examples so that the central idea becomes immediately
            familiar.</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">WelcomeController</tt> maps to the <tt class="literal">'/welcome*'</tt> request URL</p></li><li><p><tt class="classname">HomeController</tt> maps to the <tt class="literal">'/home*'</tt> request URL</p></li><li><p><tt class="classname">IndexController</tt> maps to the <tt class="literal">'/index*'</tt> request URL</p></li><li><p><tt class="classname">RegisterController</tt> maps to the <tt class="literal">'/register*'</tt> request URL</p></li><li><p><tt class="classname">DisplayShoppingCartController</tt> maps to the <tt class="literal">'/displayshoppingcart*'</tt> request URL</p><p><span class="emphasis"><em>(Notice the casing - all lowercase - in the case of camel-cased <tt class="interfacename">Controller</tt> class names.)</em></span></p></li></ul></div><p>In the case of <tt class="classname">MultiActionController</tt> handler classes, the
            mappings generated are (ever so slightly) more complex, but hopefully no less
            understandable. Some examples (all of the <tt class="interfacename">Controller</tt>
            names in this next bit are assumed to be <tt class="classname">MultiActionController</tt>
            implementations).</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">AdminController</tt> maps to the
                    <tt class="literal">'/admin<span class="bold"><b>/*</b></span>'</tt> request URL</p></li><li><p><tt class="classname">CatalogController</tt> maps to the
                    <tt class="literal">'/catalog<span class="bold"><b>/*</b></span>'</tt> request URL</p></li></ul></div><p>If you follow the pretty standard convention of naming your
            <tt class="interfacename">Controller</tt> implementations as
            <tt class="literal">xxx<span class="bold"><b>Controller</b></span></tt>,
            then the <tt class="classname">ControllerClassNameHandlerMapping</tt> will save you the
            tedium of having to firstly define and then having to maintain a potentially
            <span class="emphasis"><em>looooong</em></span> <tt class="classname">SimpleUrlHandlerMapping</tt>
            (or suchlike).</p><p>The <tt class="classname">ControllerClassNameHandlerMapping</tt> class extends
            the <tt class="classname">AbstractHandlerMapping</tt> base class so you can define
            <tt class="interfacename">HandlerInterceptor</tt> instances and everything else
            just like you would with many other <tt class="interfacename">HandlerMapping</tt>
            implementations.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-coc-modelmap"></a>13.11.2.&nbsp;The Model - <tt class="classname">ModelMap</tt> (<tt class="classname">ModelAndView</tt>)</h3></div></div><div></div></div><p>The <tt class="classname">ModelMap</tt> class is an essentially glorified
            <tt class="interfacename">Map</tt> that can make adding objects that are
            to be displayed in (or on) a <tt class="interfacename">View</tt> adhere to
            a common naming convention. The idea is simple so that rather than trying to
            explain it in prose, I will show you some examples (and then do the prose bit
            afterwards).</p><p>Consider the following <tt class="interfacename">Controller</tt>
            implementation. Notice that objects are added to the
            <tt class="classname">ModelAndView</tt> without any associated name
            being specified.</p><pre class="programlisting">public class DisplayShoppingCartController implements Controller {

    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {
        
        List cartItems = <i class="lineannotation"><span class="lineannotation">// get a <tt class="interfacename">List</tt> of <tt class="classname">CartItem</tt> objects</span></i>
        User user = <i class="lineannotation"><span class="lineannotation">// get the <tt class="classname">User</tt> doing the shopping</span></i>
        
        ModelAndView mav = new ModelAndView("displayShoppingCart"); <i class="lineannotation"><span class="lineannotation">&lt;-- the logical view name</span></i>

        mav.addObject(cartItems); <i class="lineannotation"><span class="lineannotation">&lt;-- look ma, no name, just the object</span></i>
        mav.addObject(user); <i class="lineannotation"><span class="lineannotation">&lt;-- and again ma!</span></i>

        return mav;
    }
}</pre><p>The <tt class="classname">ModelAndView</tt> class uses a
            <tt class="classname">ModelMap</tt> class that is a custom
            <tt class="interfacename">Map</tt> implementation that automatically generates
            a key for an object when an object is added to it. The strategy for determining
            the name for an added object is, in the case of a scalar object such as
            <tt class="classname">User</tt>, to use the short class name of the object's class.
            Find below some examples of the names that are generated for scalar objects
            put into a <tt class="classname">ModelMap</tt> instance.</p><div class="itemizedlist"><ul type="disc"><li><p>An <tt class="classname">x.y.User</tt> instance added will have the name
                    <tt class="literal">'user'</tt> generated</p></li><li><p>An <tt class="classname">x.y.Registration</tt> instance added will have the
                    name <tt class="literal">'registration'</tt> generated</p></li><li><p>An <tt class="classname">x.y.Foo</tt> instance added will have the name
                    <tt class="literal">'foo'</tt> generated</p></li><li><p>A <tt class="classname">java.util.HashMap</tt> instance added will have the
                    name <tt class="literal">'hashMap'</tt> generated (you'll probably want
                    to be explicit about the name in this case because <tt class="literal">'hashMap'</tt>
                    is less than intuitive).</p></li><li><p>Adding <tt class="literal">null</tt> will result in an
                    <tt class="classname">IllegalArgumentException</tt> being thrown. If the object
                    (or objects) that you are adding could potentially be <tt class="literal">null</tt>,
                    then you will also want to be explicit about the name).</p></li></ul></div><div class="sidebar"><p class="title"><b>What, no automatic pluralisation?</b></p><p>Spring Web MVC's convention over configuration support does not
                support automatic pluralisation. That is to say, you cannot add a
                <tt class="interfacename">List</tt> of
                <tt class="classname">Person</tt> objects to a
                <tt class="classname">ModelAndView</tt> and have the generated name
                be 'people'.</p><p>This decision was taken after some debate, with
                the &#8220;<span class="quote">Principle of Least Surprise</span>&#8221; winning out in the end.</p></div><p>The strategy for generating a name after adding a
            <tt class="interfacename">Set</tt>, <tt class="interfacename">List</tt> or
            array object is to peek into the collection, take the short class name of
            the first object in the collection, and use that with <tt class="literal">'List'</tt>
            appended to the name. Some examples will make the semantics of name generation
            for collections clearer...</p><div class="itemizedlist"><ul type="disc"><li><p>An <tt class="classname">x.y.User[]</tt> array with one or more
                    <tt class="classname">x.y.User</tt> elements added will have the name
                    <tt class="literal">'userList'</tt> generated</p></li><li><p>An <tt class="classname">x.y.Foo[]</tt> array with one or more
                    <tt class="classname">x.y.User</tt> elements added will have the name
                    <tt class="literal">'fooList'</tt> generated</p></li><li><p>A <tt class="classname">java.util.ArrayList</tt> with one or more
                    <tt class="classname">x.y.User</tt> elements added will have the name
                    <tt class="literal">'userList'</tt> generated</p></li><li><p>A <tt class="classname">java.util.HashSet</tt> with one or more
                    <tt class="classname">x.y.Foo</tt> elements added will have the name
                    <tt class="literal">'fooList'</tt> generated</p></li><li><p>An <span class="bold"><b>empty</b></span> <tt class="classname">java.util.ArrayList</tt>
                    will not be added at all (i.e. the <tt class="literal">adObject(..)</tt> call will
                    essentially be a no-op).</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-coc-r2vnt"></a>13.11.3.&nbsp;The View - <tt class="interfacename">RequestToViewNameTranslator</tt></h3></div></div><div></div></div><p>The <tt class="interfacename">RequestToViewNameTranslator</tt> interface
            is responsible for determining a logical <tt class="interfacename">View</tt> name
            when no such logical view name is explicitly supplied. It has but one implementation,
            the rather cunningly named <tt class="classname">DefaultRequestToViewNameTranslator</tt>
            class.</p><p>The <tt class="classname">DefaultRequestToViewNameTranslator</tt> maps request
            URLs to logical view names in a fashion that is probably best explained by recourse
            to an example. Consider the following <tt class="interfacename">Controller</tt>
            implementation, and the attendant Spring Web MVC XML configuration.</p><pre class="programlisting">public class RegistrationController implements Controller {
                
    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {
        <i class="lineannotation"><span class="lineannotation">// process the request...</span></i>
        ModelAndView mav = new ModelAndView();
        <i class="lineannotation"><span class="lineannotation">// add <span class="bold"><b>data</b></span> as necessary to the model...</span></i>
        return mav;
        <i class="lineannotation"><span class="lineannotation">// notice that no <tt class="interfacename">View</tt> or logical view name has been set</span></i>
    }
}</pre><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
        "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;
&lt;beans&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- this bean with the well known name generates view names for us --&gt;</span></i>
    &lt;bean id="viewNameTranslator" class="org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator"/&gt;

    &lt;bean class="x.y.RegistrationControllerController"&gt;
        <i class="lineannotation"><span class="lineannotation">&lt;!-- inject dependencies as necessary --&gt;</span></i>
    &lt;/bean&gt;
    
    <i class="lineannotation"><span class="lineannotation">&lt;!-- maps request URLs to Controller names --&gt;</span></i>
    &lt;bean class="org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping"/&gt;

    &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
        &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;
        &lt;property name="suffix" value=".jsp"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</pre><p>Notice how in the implementation of the <tt class="literal">handleRequest(..)</tt>
            method no <tt class="interfacename">View</tt> or logical view name is ever
            set on the <tt class="classname">ModelAndView</tt> that is returned. It is the
            <tt class="classname">DefaultRequestToViewNameTranslator</tt> that will be tasked
            with generating a <span class="emphasis"><em>logical view name</em></span> from the URL
            of the request. In the case of the above
            <tt class="classname">RegistrationControllerController</tt>, which is being
            used in conjunction with the <tt class="classname">ControllerClassNameHandlerMapping</tt>,
            a request URL of <tt class="literal">'http://localhost/registration.html'</tt> will
            result in a logical view name of <tt class="literal">'registration'</tt> being
            generated by the <tt class="classname">DefaultRequestToViewNameTranslator</tt>.
            This logical view name will then be resolved into the
            <tt class="literal">'/WEB-INF/jsp/registration.jsp'</tt> view by the
            <tt class="classname">InternalResourceViewResolver</tt> bean.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="http://static.springframework.org/spring/docs/2.0.x/images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>You don't even need to define a <tt class="classname">DefaultRequestToViewNameTranslator</tt>
                bean explicitly. If you are okay with the default settings of the
                <tt class="classname">DefaultRequestToViewNameTranslator</tt>, then you can
                rely on the fact that the Spring Web MVC <tt class="classname">DispatcherServlet</tt>
                will actually instantiate an instance of this class if one is not
                explicitly configured.</p></td></tr></table></div><p>Of course, if you need to change the default settings, then you do need to
            configure your own <tt class="classname">DefaultRequestToViewNameTranslator</tt> bean
            explicitly. Please do consult the quite comprehensive Javadoc for the
            <tt class="classname">DefaultRequestToViewNameTranslator</tt> class for details of the
            various properties that can be configured.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-resources"></a>13.12.&nbsp;Further Resources</h2></div></div><div></div></div><p>Find below links and pointers to further resources about Spring Web MVC.</p><div class="itemizedlist"><ul type="disc"><li><p>The Spring distribution ships with a Spring Web MVC tutorial that
				guides the reader through building a complete Spring Web MVC-based application
				using a step-by-step approach. This tutorial is available in the
				<tt class="literal">'docs'</tt> directory of the Spring distribution. An
				online version can also be found on the
				<a href="http://springframework.org/" target="_top">Spring Framework website</a>.</p></li><li><p>The book entitled &#8220;<span class="quote">Expert Spring Web MVC and WebFlow</span>&#8221; by
				Seth Ladd and others (published by Apress) is an excellent hardcopy
				source of Spring Web MVC goodness.</p></li></ul></div></div></div><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pt03.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="view.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part&nbsp;III.&nbsp;The Web&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.interface21.com/" title="Interface21 - Spring from the Source">Sponsored by Interface21</a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;14.&nbsp;Integrating view technologies</td></tr></table></div></body>
<!-- Mirrored from static.springframework.org/spring/docs/2.0.x/reference/mvc.html by HTTrack Website Copier/3.x [XR&CO'2005], Tue, 17 Oct 2006 17:46:02 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
