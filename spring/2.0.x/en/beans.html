<html>
<!-- Mirrored from static.springframework.org/spring/docs/2.0.x/reference/beans.html by HTTrack Website Copier/3.x [XR&CO'2005], Tue, 17 Oct 2006 17:45:43 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;3.&nbsp;The IoC container</title><link rel="stylesheet" href="http://static.springframework.org/spring/docs/2.0.x/styles/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><link rel="home" href="index.html" title="The Spring Framework - Reference Documentation"><link rel="up" href="pt01.html" title="Part&nbsp;I.&nbsp;Core Technologies"><link rel="previous" href="pt01.html" title="Part&nbsp;I.&nbsp;Core Technologies"><link rel="next" href="resources.html" title="Chapter&nbsp;4.&nbsp;Resources"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns="http://www.w3.org/TR/xhtml1/transitional" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://www.springframework.org/" title="The Spring Framework"><img style="border:none;" src="images/xdev-spring_logo.jpg"></a><a style="border:none;" href="http://www.interface21.com/" title="Interface21 - Spring from the Source"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/i21-banner-rhs.jpg"></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="beans"></a>Chapter&nbsp;3.&nbsp;The IoC container</h2></div></div>
   <table align="center">
<tr>
<td>
<script type="text/javascript"><!--
google_ad_client = "pub-2627642070897863";
google_ad_width = 336;
google_ad_height = 280;
google_ad_format = "336x280_as";
google_ad_type = "text_image";
//2006-10-13: com_336x280
google_ad_channel = "7652836435";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
<td>
<script type="text/javascript"><!--
google_ad_client = "pub-2627642070897863";
google_ad_width = 336;
google_ad_height = 280;
google_ad_format = "336x280_as";
google_ad_type = "text_image";
//2006-10-13: com_336x280
google_ad_channel = "7652836435";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</tr>
</table>
   <div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-introduction"></a>3.1.&nbsp;Introduction</h2></div></div><div></div></div><p>This chapter is devoted to covering (in detail) the Spring Framework's
        implementation of the Inversion of Control (IoC)
		<sup>[<a name="d0e814" href="#ftn.d0e814">1</a>]</sup>
		principle. IoC underpins a lot of the surrounding functionality that is provided by
		the Spring Framework as a whole, and so a thorough treatment of this rich, yet
		conceptually very simple, technology is in order.</p><div class="sidebar"><p class="title"><b>Which interface?</b></p><p>Users are sometimes unsure whether a <tt class="interfacename">BeanFactory</tt>
            or an <tt class="interfacename">ApplicationContext</tt> is best suited for use
            in a particular situation. Normally when building most applications in a
            J2EE-environment, <span class="emphasis"><em>the best option is to use the</em></span>
            <tt class="interfacename">ApplicationContext</tt>, since it offers
            all the features of the <tt class="interfacename">BeanFactory</tt>, while also
            allowing a more declarative approach to the use of some functionality, which is
            generally desirable.</p></div><p>The <tt class="literal">org.springframework.beans</tt> and
        <tt class="literal">org.springframework.context</tt> packages provide the basis
        for the Spring Framework's IoC container. The
        <tt class="interfacename"><a href="http://www.springframework.org/docs/api/org/springframework/beans/factory/BeanFactory.html" target="_top">BeanFactory</a></tt>
		interface provides an advanced configuration mechanism capable of managing
		objects of any nature. The
        <tt class="literal"><a href="http://www.springframework.org/docs/api/org/springframework/context/ApplicationContext.html" target="_top">ApplicationContext</a></tt>
        interface builds on top of the <tt class="interfacename">BeanFactory</tt>
        (it is a sub-interface) and adds other functionality such as easier integration
        with Spring's AOP features, message resource handling (for use in
        internationalization), event propagation, and application-layer specific contexts
        such as the <tt class="interfacename">WebApplicationContext</tt> for use in web
        applications.</p><p>In short, the <tt class="interfacename">BeanFactory</tt> provides the
		configuration framework and basic functionality, while the
		<tt class="interfacename">ApplicationContext</tt> adds more enterprise-centric
		functionality to it. The <tt class="interfacename">ApplicationContext</tt> is a
		complete superset of the <tt class="interfacename">BeanFactory</tt>, and any
		description of <tt class="interfacename">BeanFactory</tt> capabilities and
		behavior is to be considered to apply to the
		<tt class="interfacename">ApplicationContext</tt> as well.</p><p>This chapter is divided into two parts, with the
		<a href="beans.html#beans-factory" title="3.2.1.&nbsp;The container">first part</a> covering the basic principles
		that apply to both the <tt class="interfacename">BeanFactory</tt> and
		<tt class="interfacename">ApplicationContext</tt>, and with the
		<a href="beans.html#context-introduction" title="3.8.&nbsp;The ApplicationContext">second part</a>	covering those features
		that apply only to the <tt class="interfacename">ApplicationContext</tt> interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-basics"></a>3.2.&nbsp;Basics - containers and beans</h2></div></div><div></div></div><p>In Spring, those objects that form the backbone of your application and that
		are managed by the Spring IoC container are referred to as <i class="firstterm">beans</i>.
		A bean is simply an object that typically is instantiated, assembled and otherwise
		managed by a Spring IoC <i class="firstterm">container</i>; other than that, there is
		nothing special about a bean (it is in all other respects one of probably many objects
		in your application). These beans, and the <i class="firstterm">dependencies</i> between
		them, are reflected in the <i class="firstterm">configuration metadata</i> used by a
		container.</p><div class="sidebar"><p class="title"><b>Why... <span class="emphasis"><em>bean</em></span>?</b></p><p>The motivation for using the name <span class="emphasis"><em>'bean'</em></span>, as opposed
			to <span class="emphasis"><em>'component'</em></span> or <span class="emphasis"><em>'object'</em></span> is rooted
			in the origins of the Spring Framework itself (it arose partly as a response to
			the complexity of Enterprise Java<span class="emphasis"><em>Beans</em></span>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory"></a>3.2.1.&nbsp;The container</h3></div></div><div></div></div><p>The <tt class="interfacename">org.springframework.beans.factory.BeanFactory</tt>
            is the actual representation of the Spring IoC <span class="emphasis"><em>container</em></span> that is
            responsible for containing and otherwise managing the aforementioned beans.</p><p>The <tt class="interfacename">BeanFactory</tt> interface is the central IoC container
            interface in Spring. Its responsibilities include instantiating or sourcing application
            objects, configuring said objects, and assembling the dependencies between these objects.</p><p>There are a number of implementations of the <tt class="interfacename">BeanFactory</tt>
			interface that come supplied straight out-of-the-box with Spring. The most commonly used
			<tt class="interfacename">BeanFactory</tt> implementation is the
			<tt class="classname">XmlBeanFactory</tt> class. This implementation allows you to express the
			objects that compose your application, and the doubtless rich interdependencies between such
			objects, in terms of XML. The <tt class="classname">XmlBeanFactory</tt> takes this
			XML <i class="firstterm">configuration metadata</i> and uses it to create a
			fully configured system or application.</p><p>
				</p><div class="mediaobject" align="center"><img src="images/container-magic.png" align="middle"><div class="caption"><p>The Spring IoC container</p></div></div><p>
			</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e979"></a>3.2.1.1.&nbsp;Configuration metadata</h4></div></div><div></div></div><p>
					As can be seen in the above image, the Spring IoC container consumes some form of
					<span class="emphasis"><em>configuration metadata</em></span>; this configuration metadata is nothing
					more than how you (as an application developer) inform the Spring container as to
					how to &#8220;<span class="quote"><span class="emphasis"><em>instantiate, configure, and assemble [the objects in your
					application]</em></span></span>&#8221;. This configuration metadata is typically supplied in a
					simple and intuitive XML format. When using XML-based configuration metadata, you
					write <span class="emphasis"><em>bean definitions</em></span> for those beans that you want the
					Spring IoC container to manage, and then let said container do its stuff.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://static.springframework.org/spring/docs/2.0.x/images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>XML-based metadata is by far the most commonly used form of configuration
					metadata. It is <span class="emphasis"><em>not</em></span> however the only form of
					configuration metadata that is allowed. The Spring IoC container itself
					is <span class="emphasis"><em>totally</em></span> decoupled from the format in which this
					configuration metadata is actually written.</p><p>At the time of writing, you can supply this configuration metadata
					using either XML, the Java properties format, or programmatically (using
					Spring's public API). The XML-based configuration metadata format really is
					simple though, and so the remainder of this chapter will use the XML format
					to convey key concepts and features of the Spring IoC container.</p></td></tr></table></div></div><div class="sidebar"><p class="title"><b>Resources</b></p><p>
						Once you have learned the basics of the IoC container (this chapter),
						it will also be useful to learn about Spring's
						<tt class="interfacename">Resource</tt> abstraction, as described in
						<a href="resources.html" title="Chapter&nbsp;4.&nbsp;Resources">Chapter&nbsp;4, <i>Resources</i></a>.
					</p><p>
						The location path or paths supplied to
						an <tt class="interfacename">ApplicationContext</tt> constructor are
						actually resource strings that allow the container to load
						configuration metadata from a variety of external resources such
						as the local file system, from the Java <tt class="literal">CLASSPATH</tt>, etc.
					</p></div><p>Please be advised that in the vast majority of application scenarios,
				explicit user code is not required to instantiate one or more instances
				of a Spring IoC container. For example, in a web application scenario, a simple
				eight (or so) lines of absolutely boilerplate J2EE web descriptor XML in the
				attendant <tt class="literal">web.xml</tt> file of the application will typically
				suffice (see <a href="beans.html#context-create" title="3.8.4.&nbsp;Convenient ApplicationContext instantiation for web applications">Section&nbsp;3.8.4, &#8220;Convenient ApplicationContext instantiation for web applications&#8221;</a>).</p></div><p>At its most basic level, a Spring IoC container configuration consists of the
            definition of at least one bean that the container must manage, but typically there
            will be more than one bean definition. When using XML-based configuration metadata,
			these beans are configured as one or more <tt class="literal">&lt;bean/&gt;</tt> elements
			inside a top-level <tt class="literal">&lt;beans/&gt;</tt> element.</p><p>These bean definitions correspond to the actual objects that make up your
			application(s). Typically you will have bean definitions for your service layer
			objects, your data access objects (DAOs), presentation objects such as Struts
			<tt class="interfacename">Action</tt> instances, infrastructure objects such as
			Hibernate <tt class="interfacename">SessionFactory</tt> instances, JMS
			<tt class="interfacename">Queue</tt> references, etc. (the possibilities are of
			course endless and are limited only by the scope and complexity of your	application).</p><p>Find below an example of the basic structure of XML-based configuration
			metadata.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"&gt;
  &lt;bean id="..." class="..."&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></i>
  &lt;/bean&gt;
  &lt;bean id="..." class="..."&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></i>
  &lt;/bean&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- more bean definitions go here... --&gt;</span></i>
&lt;/beans&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1062"></a>3.2.2.&nbsp;Instantiating a container</h3></div></div><div></div></div><p>Instantiating a Spring IoC container is easy; find below some examples of how
				to do just that:</p><pre class="programlisting">Resource resource = new FileSystemResource("beans.xml");
BeanFactory factory = new XmlBeanFactory(resource);</pre><p>... or...</p><pre class="programlisting">ClassPathResource resource = new ClassPathResource("beans.xml");
BeanFactory factory = new XmlBeanFactory(resource);</pre><p>... or...</p><pre class="programlisting">ApplicationContext context = new ClassPathXmlApplicationContext(
        new String[] {"applicationContext.xml", "applicationContext-part2.xml"});
<i class="lineannotation"><span class="lineannotation">// of course, an <tt class="interfacename">ApplicationContext</tt> is just a <tt class="interfacename">BeanFactory</tt></span></i>
BeanFactory factory = (BeanFactory) context;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-xml-import"></a>3.2.2.1.&nbsp;Composing XML-based configuration metadata</h4></div></div><div></div></div><p>It can often be useful to split up container definitions into multiple
			        XML files. One way to then load an application context which is configured
			        from all these XML fragments is to use the application context constructor
			        which takes multiple <tt class="interfacename">Resource</tt> locations. With
			        a bean factory, a bean definition reader can be used multiple times to read
			        definitions from each file in turn.</p><p>Generally, the Spring team prefers the above approach, since it
			        keeps container configuration files unaware of the fact that they are
			        being combined with others. An alternate approach is to use one or more
			        occurrences of the <tt class="literal">&lt;import/&gt;</tt> element to load bean definitions
			        from another file (or files). Any <tt class="literal">&lt;import/&gt;</tt> elements must be
			        placed before <tt class="literal">&lt;bean/&gt;</tt> elements in the file doing the importing. 
			        Let's look at a sample:</p><pre class="programlisting">&lt;beans&gt;

    &lt;import resource="services.xml"/&gt;
    &lt;import resource="resources/messageSource.xml"/&gt;
    &lt;import resource="/resources/themeSource.xml"/&gt;

    &lt;bean id="bean1" class="..."/&gt;
    &lt;bean id="bean2" class="..."/&gt;

&lt;/beans&gt;</pre><p>In this example, external bean definitions are being loaded from 3
			    files, <tt class="literal">services.xml</tt>,
			    <tt class="literal">messageSource.xml</tt>, and
			    <tt class="literal">themeSource.xml</tt>. All location paths are considered
			    relative to the definition file doing the importing, so
			    <tt class="literal">services.xml</tt> in this case must be in the same directory
			    or classpath location as the file doing the importing, while
			    <tt class="literal">messageSource.xml</tt> and
			    <tt class="literal">themeSource.xml</tt> must be in a
			    <tt class="literal">resources</tt> location below the location of the importing
			    file. As you can see, a leading slash is actually ignored, but given that
			    these are considered relative paths, it is probably better form not to use
			    the slash at all.</p><p>The contents of the files being imported must be fully valid XML
			    bean definition files according to the Schema or DTD, including the
			    top level <tt class="literal">&lt;beans/&gt;</tt> element.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-definition"></a>3.2.3.&nbsp;The beans</h3></div></div><div></div></div><p>As mentioned previously, a Spring IoC container manages one or more
            <span class="emphasis"><em>beans</em></span>. These beans are created using the instructions
            defined in the configuration metadata that has been supplied to the container
            (typically in the form of XML <tt class="literal">&lt;bean/&gt;</tt> definitions).</p><p>Within the container itself, these bean definitions are represented as
            <tt class="interfacename">BeanDefinition</tt> objects, which contain (among other
            information) the following metadata:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>a package-qualified class name:</em></span> this is
					normally the actual implementation class of the bean being defined.
					However, if the bean is to be instantiated by invoking a
					<tt class="literal">static</tt> <span class="emphasis"><em>factory</em></span> method
					instead of using a normal constructor, this will actually be the
					class name of the factory class.</p></li><li><p>bean behavioral configuration elements, which state how the
					bean should behave in the container (i.e. prototype or singleton,
					autowiring mode, dependency checking mode, initialization and
					destruction methods)</p></li><li><p>constructor arguments and property values to set in the
					newly created bean. An example would be the number of connections
					to use in a bean that manages a connection pool (either specified
					as a property or as a constructor argument), or the pool size
					limit.</p></li><li><p>other beans which are needed for the bean to do its work, i.e.
                    <span class="emphasis"><em>collaborators</em></span> (also called dependencies).</p></li></ul></div><p>The concepts listed above directly translate to a set of properties
			that each bean definition consists of. Some of these properties are listed
			below, along with a link to further documentation about each of them.</p><div class="table"><a name="d0e1176"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;The bean definition</b></p><table summary="The bean definition" border="1"><colgroup><col><col></colgroup><thead><tr><th>Feature</th><th>Explained in...</th></tr></thead><tbody><tr><td>class</td><td><p><a href="beans.html#beans-factory-class" title="3.2.3.2.&nbsp;Instantiating beans">Section&nbsp;3.2.3.2, &#8220;Instantiating beans&#8221;</a></p></td></tr><tr><td>name</td><td><p><a href="beans.html#beans-beanname" title="3.2.3.1.&nbsp;Naming beans">Section&nbsp;3.2.3.1, &#8220;Naming beans&#8221;</a></p></td></tr><tr><td>scope</td><td><p><a href="beans.html#beans-factory-scopes" title="3.4.&nbsp;Bean scopes">Section&nbsp;3.4, &#8220;Bean scopes&#8221;</a></p></td></tr><tr><td>constructor arguments</td><td><p><a href="beans.html#beans-factory-collaborators" title="3.3.1.&nbsp;Injecting dependencies">Section&nbsp;3.3.1, &#8220;Injecting dependencies&#8221;</a></p></td></tr><tr><td>properties</td><td><p><a href="beans.html#beans-factory-collaborators" title="3.3.1.&nbsp;Injecting dependencies">Section&nbsp;3.3.1, &#8220;Injecting dependencies&#8221;</a></p></td></tr><tr><td>autowiring mode</td><td><p><a href="beans.html#beans-factory-autowire" title="3.3.6.&nbsp;Autowiring collaborators">Section&nbsp;3.3.6, &#8220;Autowiring collaborators&#8221;</a></p></td></tr><tr><td>dependency checking mode</td><td><p><a href="beans.html#beans-factory-dependencies" title="3.3.7.&nbsp;Checking for dependencies">Section&nbsp;3.3.7, &#8220;Checking for dependencies&#8221;</a></p></td></tr><tr><td>lazy-initialization mode</td><td><p><a href="beans.html#beans-factory-lazy-init" title="3.3.5.&nbsp;Lazily-instantiating beans">Section&nbsp;3.3.5, &#8220;Lazily-instantiating beans&#8221;</a></p></td></tr><tr><td>initialization method</td><td><p><a href="beans.html#beans-factory-lifecycle" title="3.5.1.&nbsp;Lifecycle interfaces">Section&nbsp;3.5.1, &#8220;Lifecycle interfaces&#8221;</a></p></td></tr><tr><td>destruction method</td><td><p><a href="beans.html#beans-factory-lifecycle" title="3.5.1.&nbsp;Lifecycle interfaces">Section&nbsp;3.5.1, &#8220;Lifecycle interfaces&#8221;</a></p></td></tr></tbody></table></div><p>Besides bean definitions which contain information on how to
			create a specific bean, certain <tt class="interfacename">BeanFactory</tt>
			implementations also permit the registration of existing objects that have
			been created outside the factory (by user code). The
			<tt class="classname">DefaultListableBeanFactory</tt> class supports this
			through the <tt class="methodname">registerSingleton(..)</tt> method. Typical applications
			solely work with beans defined through metadata bean definitions, though.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-beanname"></a>3.2.3.1.&nbsp;Naming beans</h4></div></div><div></div></div><div class="sidebar"><p class="title"><b>Bean naming conventions</b></p><p>The convention (at least amongst the Spring development team) is to use
				    the standard Java convention for instance field names when naming beans.
				    That is, bean names start with a lowercase letter, and are camel-cased
				    from then on. Examples of such names would be (without quotes)
				    <tt class="literal">'accountManager'</tt>, <tt class="literal">'accountService'</tt>,
				    <tt class="literal">'userDao'</tt>, <tt class="literal">'loginController'</tt>, etc.</p><p>Adopting a consistent way of naming your beans will go a long way towards
				    making your configuration easier to read and understand; adopting such
				    naming standards is not hard to do, and if you are using Spring AOP it
				    can pay off handsomely when it comes to applying advice to a set of
				    beans related by name.</p></div><p>Every bean has one or more ids (also called identifiers, or names;
				these terms refer to the same thing). These ids must be unique within
				the container the bean is hosted in. A bean will almost always have only one
				id, but if a bean has more than one id, the extra ones can essentially be
				considered aliases.</p><p>When using XML-based configuration metadata, you use the <tt class="literal">'id'</tt>
				or <tt class="literal">'name'</tt> attributes to specify the bean identifier(s). The
				<tt class="literal">'id'</tt> attribute allows you to specify exactly one id, and as
				it is a real XML element ID attribute, the XML parser is able to do
				some extra validation when other elements reference the id; as such, it is the
				preferred way to specify a bean id. However, the XML specification does limit
				the characters which are legal in XML IDs. This is usually not a constraint, but
				if you have a need to use one of these special XML characters, or want to introduce
				other aliases to the bean, you may also or instead specify one or more bean ids,
				separated by a comma (<tt class="literal">,</tt>), semicolon (<tt class="literal">;</tt>), or
				whitespace in the <tt class="literal">'name'</tt> attribute.</p><p>Please note that you are not required to supply a name for a bean. If
				no name is supplied explicitly, the container will generate a (unique) name
				for that bean. The motivations for not supplying a name for a bean will be
				discussed later (one use case is <a href="beans.html#beans-inner-beans" title="3.3.3.3.&nbsp;Inner beans">inner beans</a>).</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-beanname-alias"></a>3.2.3.1.1.&nbsp;Aliasing beans</h5></div></div><div></div></div><p>In a bean definition itself, you may supply more than one name for
                    the bean, by using a combination of up to one name specified via the
                    <tt class="literal">id</tt> attribute, and any number of other names via the
                    <tt class="literal">alias</tt> attribute. All these names can be considered
                    equivalent aliases to the same bean, and are useful for some situations,
                    such as allowing each component used in an application to refer to a
                    common dependency using a bean name that is specific to that component
                    itself.</p><p>Having to specify all aliases when the bean is actually defined is not
                    always adequate however. It is sometimes desirable to introduce an alias
                    for a bean which is defined elsewhere. In XML-based configuration metadata
                    this may be accomplished via the use of the standalone
                    <tt class="literal">&lt;alias/&gt;</tt> element. For example:</p><pre class="programlisting">&lt;alias name="fromName" alias="toName"/&gt;</pre><p>In this case, a bean in the same container which is named
                    <tt class="literal">'fromName'</tt>, may also after the use of this alias
                    definition, be referred to as <tt class="literal">'toName'</tt>.</p><p>As a concrete example, consider the case where component A defines a
                    DataSource bean called componentA-dataSource, in its XML fragment.
                    Component B would however like to refer to the DataSource as
                    componentB-dataSource in its XML fragment. And the main application,
                    MyApp, defines its own XML fragment and assembles the final application
                    context from all three fragments, and would like to refer to the
                    DataSource as myApp-dataSource. This scenario can be easily handled by
                    adding to the MyApp XML fragment the following standalone aliases:</p><pre class="programlisting">&lt;alias name="componentA-dataSource" alias="componentB-dataSource"/&gt;
&lt;alias name="componentA-dataSource" alias="myApp-dataSource" /&gt;</pre><p>Now each component and the main app can refer to the dataSource via
                    a name that is unique and guaranteed not to clash with any other
                    definition (effectively there is a namespace), yet they refer to the same
                    bean.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-class"></a>3.2.3.2.&nbsp;Instantiating beans</h4></div></div><div></div></div><p>So far as a Spring IoC container is concerned, a bean definition
                is basically a recipe for creating one or more actual objects. The 
                container looks at the recipe for a named bean when asked, and uses
                the configuration metadata encapsulated by that bean definition to
                go off and reflectively create an actual object. This section is thus
                concerned with communicating to you, the application developer, how you
                inform a Spring IoC container both what type (or class) of object to
                instantiate and how to instantiate the resulting object.</p><p>If you are using XML-based configuration metadata, you can specify
                the type (or class) of object that is to be instantiated using the
                <tt class="literal">'class'</tt> attribute of the <tt class="literal">&lt;bean/&gt;</tt>
                element. This <tt class="literal">'class'</tt> attribute (which internally
                eventually boils down to being a <tt class="classname">Class</tt> property on a
                <tt class="interfacename">BeanDefinition</tt> instance) is normally
                mandatory (see <a href="beans.html#beans-factory-class-instance-factory-method" title="3.2.3.2.3.&nbsp;Instantiation using an instance factory method">Section&nbsp;3.2.3.2.3, &#8220;Instantiation using an instance factory method&#8221;</a> and
			    <a href="beans.html#beans-child-bean-definitions" title="3.6.&nbsp;Bean definition inheritance">Section&nbsp;3.6, &#8220;Bean definition inheritance&#8221;</a> for the two exceptions)
			    and is used for one of two purposes. The class property specifies the
			    class of the bean to be constructed in the much more common case where the
			    container itself directly creates the bean by calling its constructor
			    reflectively (somewhat equivalent to Java code using the
			    <span class="emphasis"><em>'new'</em></span> operator). In the less common case where the
			    container invokes a <tt class="literal">static</tt>, <span class="emphasis"><em>factory</em></span>
			    method on a class to create the bean, the class property specifies the actual
			    class containing the <tt class="literal">static</tt> factory method that is to
			    be invoked to create the object (the type of the object returned from the
			    invocation of the <tt class="literal">static</tt> factory method may be the same
			    class or another class entirely, it doesn't	matter).</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-factory-class-ctor"></a>3.2.3.2.1.&nbsp;Instantiation using a constructor</h5></div></div><div></div></div><p>When creating a bean using the constructor approach, all normal
				    classes are usable by and compatible with Spring. That is, the
				    class being created does not need to implement any specific interfaces
				    or be coded in a specific fashion. Just specifying the bean class
				    should be enough. However, depending on what type of IoC you are going
				    to use for that specific bean, you may need a default (empty)
				    constructor.</p><p>Additionally, the Spring IoC container isn't limited to just managing
				    true JavaBeans, it is also able to manage virtually <span class="emphasis"><em>any</em></span>
				    class you want it to manage. Most people using Spring prefer to
				    have actual JavaBeans (having just a default (no-argument) constructor
				    and appropriate setters and getters modeled after the properties)
				    in the container, but it is also possible to have more exotic
				    non-bean-style classes in your container. If, for example, you
				    need to use a legacy connection pool that absolutely does not adhere
				    to the JavaBean specification, Spring can manage it as well.</p><p>When using XML-based configuration metadata you can specify your bean
				    class like so:</p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"/&gt;

&lt;bean name="anotherExample" class="examples.ExampleBeanTwo"/&gt;</pre><p>The mechanism for supplying arguments to the constructor (if required),
				    or setting properties of the object instance after it has been constructed,
				    will be described shortly.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-factory-class-static-factory-method"></a>3.2.3.2.2.&nbsp;Instantiation using a <tt class="literal">static</tt> factory method</h5></div></div><div></div></div><p>
					    When defining a bean which is to be created using a static
					    factory method, along with the <tt class="literal">class</tt> attribute
					    which specifies the class containing the <tt class="literal">static</tt> factory method,
					    another attribute named <tt class="literal">factory-method</tt> is needed to
					    specify the name of the factory method itself. Spring expects to be
					    able to call this method (with an optional list of arguments as
					    described later) and get back a live object, which from that point on
					    is treated as if it had been created normally via a constructor. One
					    use for such a bean definition is to call <tt class="literal">static</tt>
					    factories in legacy code.
				    </p><p>
					    The following example shows a bean definition which specifies
					    that the bean is to be created by calling a factory-method. Note that
					    the definition does not specify the type (class) of the returned
					    object, only the class containing the factory method. In this example,
					    the <tt class="methodname">createInstance()</tt> method must be a
					    <span class="emphasis"><em>static</em></span> method.
				    </p><pre class="programlisting">&lt;bean id="exampleBean"
      class="examples.ExampleBean2"
      factory-method="createInstance"/&gt;</pre><p>The mechanism for supplying (optional) arguments to the factory
				    method, or setting properties of the object instance after it has been
				    returned from the factory, will be described shortly.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-factory-class-instance-factory-method"></a>3.2.3.2.3.&nbsp;Instantiation using an instance factory method</h5></div></div><div></div></div><p>In a fashion similar to instantiation via a
                    <a href="beans.html#beans-factory-class-static-factory-method" title="3.2.3.2.2.&nbsp;Instantiation using a static factory method">static factory method</a>,
                    instantiation using an instance factory method is where the factory method of an
                    existing bean from the container is invoked to create the new bean.</p><p>To use this mechanism, the <tt class="literal">'class'</tt> attribute
				    must be left empty, and the <tt class="literal">'factory-bean'</tt> attribute
				    must specify the name of a bean in the current (or parent/ancestor) container
				    that contains the factory method. The factory method itself must still be set
				    via the <tt class="literal">'factory-method'</tt> attribute (as seen in the example
				    below).</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- the factory bean, which contains a method called <tt class="methodname">createInstance()</tt> --&gt;</span></i>
&lt;bean id="myFactoryBean" class="..."&gt;
  ...
&lt;/bean&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- the bean to be created via the factory bean --&gt;</span></i>
&lt;bean id="exampleBean"
      factory-bean="myFactoryBean"
      factory-method="createInstance"/&gt;</pre><p>Although the mechanisms for setting bean properties are still to
				    be discussed, one implication of this approach is that the factory
				    bean itself can be managed and configured via DI.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-client"></a>3.2.4.&nbsp;Using the container</h3></div></div><div></div></div><p>A <tt class="interfacename">BeanFactory</tt> is essentially nothing more
            than the interface for an advanced factory capable of maintaining a registry
            of different beans and their dependencies. The <tt class="interfacename">BeanFactory</tt>
            enables you to read bean definitions and access them using the bean factory.
            When using just the <tt class="interfacename">BeanFactory</tt> you would create
            one and read in some bean definitions in the XML format as follows:</p><pre class="programlisting">InputStream is = new FileInputStream("beans.xml");
BeanFactory factory = new XmlBeanFactory(is);</pre><p>Basically that's all there is to it. Using <tt class="methodname">getBean(String)</tt>
            you can retrieve instances of your beans; the client-side view of the
            <tt class="interfacename">BeanFactory</tt> is surprisingly simple. The
            <tt class="interfacename">BeanFactory</tt> interface has only six methods for
            client code to call:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">boolean containsBean(String)</tt>: returns true
                    if the <tt class="interfacename">BeanFactory</tt> contains a bean
                    definition or bean instance that matches the given name</p></li><li><p><tt class="methodname">Object getBean(String)</tt>: returns an instance
                    of the bean registered under the given name. Depending on how the
                    bean was configured by the <tt class="interfacename">BeanFactory</tt> configuration, either a
                    singleton and thus shared instance or a newly created bean will be
                    returned. A <tt class="exceptionname">BeansException</tt> will be thrown when
                    either the bean could not be found (in which case it'll be a
                    <tt class="exceptionname">NoSuchBeanDefinitionException</tt>), or an exception
                    occurred while instantiating and preparing the bean</p></li><li><p><tt class="methodname">Object getBean(String, Class)</tt>: returns a
                    bean, registered under the given name. The bean returned will be
                    cast to the given Class. If the bean could not be cast,
                    corresponding exceptions will be thrown
                    (<tt class="exceptionname">BeanNotOfRequiredTypeException</tt>). Furthermore,
                    all rules of the <tt class="methodname">getBean(String)</tt> method apply (see above)</p></li><li><p><tt class="methodname">Class getType(String name)</tt>: returns the
                    <tt class="classname">Class</tt> of the bean with the given name. If no bean
                    corresponding to the given name could be found, a
                    <tt class="exceptionname">NoSuchBeanDefinitionException</tt> will be thrown</p></li><li><p><tt class="methodname">boolean isSingleton(String)</tt>: determines
                    whether or not the bean definition or bean instance registered under
                    the given name is a singleton (bean scopes such as singleton are explained
                    <a href="beans.html#beans-factory-scopes" title="3.4.&nbsp;Bean scopes">later</a>). If no bean corresponding
                    to the given name could be found, a
                    <tt class="exceptionname">NoSuchBeanDefinitionException</tt> will be thrown</p></li><li><p><tt class="methodname">String[] getAliases(String)</tt>: Return the
                    aliases for the given bean name, if any were defined in the bean
                    definition</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-dependencies"></a>3.3.&nbsp;Dependencies</h2></div></div><div></div></div><p>Your typical enterprise application is not made up of a single object (or
        bean in the Spring parlance). Even the simplest of applications will no doubt
        have at least a handful of objects that work together to present what the
        end-user sees as a coherent application. This next section explains how you go
        from defining a number of bean definitions that stand-alone, each to themselves,
        to a fully realized application where objects work (or collaborate) together
        to achieve some goal (usually an application that does what the end-user wants).</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-collaborators"></a>3.3.1.&nbsp;Injecting dependencies</h3></div></div><div></div></div><p>
				The basic principle behind <span class="emphasis"><em>Dependency Injection</em></span> (DI)
				is that objects define their dependencies (i.e. the other objects they work
				with) only through constructor arguments, arguments to a factory method, or
				properties which are set on the object instance after it has been
				constructed or returned from a factory method. Then, it is the job of
				the container to actually <span class="emphasis"><em>inject</em></span> those dependencies
				when it creates the bean. This is fundamentally the inverse, hence the
				name <span class="emphasis"><em>Inversion of Control</em></span> (IoC), of the bean itself
				 being in control of instantiating or locating its dependencies on its
				 own using direct construction of classes, or something like the
				<span class="emphasis"><em>Service Locator</em></span> pattern.
			</p><p>
				It becomes evident upon usage that code gets much cleaner when the DI
				principle is applied, and reaching a higher grade of decoupling is much
				easier when beans do not look up their dependencies, but are provided
				with them (and additionally do not even know where the dependencies are
				located and of what actual class they are).
			</p><p>
				As touched on in the previous paragraph, DI exists in two major variants,
				namely <a href="beans.html#beans-setter-injection" title="3.3.1.1.&nbsp;Setter Injection">Setter Injection</a>, and
				<a href="beans.html#beans-constructor-injection" title="3.3.1.2.&nbsp;Constructor Injection">Constructor Injection</a>.
			</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-setter-injection"></a>3.3.1.1.&nbsp;Setter Injection</h4></div></div><div></div></div><p>
					<span class="emphasis"><em>Setter-based</em></span> DI is realized by calling setter methods
					on your beans after invoking a no-argument constructor or no-argument
					<tt class="literal">static</tt> factory method to instantiate your bean.
				</p><p>
					Find below an example of a class that can only be dependency injected
					using pure setter injection. Note that there is nothing
					<span class="emphasis"><em>special</em></span> about this class... it is plain old Java.
				</p><pre class="programlisting">public class SimpleMovieLister {

    <i class="lineannotation"><span class="lineannotation">// the <tt class="classname">SimpleMovieLister</tt> has a dependency on the <tt class="interfacename">MovieFinder</tt></span></i>
    private MovieFinder movieFinder;

    <i class="lineannotation"><span class="lineannotation">// a setter method so that the Spring container can 'inject' a <tt class="interfacename">MovieFinder</tt></span></i>
    public void setMoveFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
    
    <i class="lineannotation"><span class="lineannotation">// business logic that actually 'uses' the injected <tt class="interfacename">MovieFinder</tt> is omitted...</span></i>
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-constructor-injection"></a>3.3.1.2.&nbsp;Constructor Injection</h4></div></div><div></div></div><p>
					<span class="emphasis"><em>Constructor-based</em></span> DI
					is realized by invoking a constructor with a number of arguments,
					each representing a collaborator. Additionally,
					calling a <tt class="literal">static</tt> factory method with specific
					arguments to construct the bean, can be considered almost equivalent,
					and the rest of this text will consider arguments to a constructor and
					arguments to a <tt class="literal">static</tt> factory method similarly.
				</p><p>
					Find below an example of a class that could only be dependency injected
					using constructor injection. Again, note that there is nothing
					<span class="emphasis"><em>special</em></span> about this class.
				</p><pre class="programlisting">public class SimpleMovieLister {

    <i class="lineannotation"><span class="lineannotation">// the <tt class="classname">SimpleMovieLister</tt> has a dependency on the <tt class="interfacename">MovieFinder</tt></span></i>
    private MovieFinder movieFinder;

    <i class="lineannotation"><span class="lineannotation">// a constructor so that the Spring container can 'inject' a  <tt class="interfacename">MovieFinder</tt></span></i>
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
    
    <i class="lineannotation"><span class="lineannotation">// business logic that actually 'uses' the injected <tt class="interfacename">MovieFinder</tt> is omitted...</span></i>
}</pre></div><div class="sidebar"><p class="title"><b>Constructor- or Setter-based DI?</b></p><p>
					The Spring team generally advocates the usage of setter injection,
					since a large number of constructor arguments can get unwieldy,
					especially when some properties are optional. The presence of
					setter methods also makes objects of that class amenable to being
					re-configured (or re-injected) at some later time (for management
					via <a href="jmx.html" title="Chapter&nbsp;20.&nbsp;JMX">JMX MBeans</a> is a particularly
					compelling use case).
				</p><p>
					Constructor-injection is favored by some purists though (and with
					good reason). Supplying all of an object's dependencies means that
					that object is never returned to client (calling) code in a less than
					totally initialized state. The flipside is that the object becomes
					less amenable to re-configuration (or re-injection).
				</p><p>
					There is no hard and fast rule here. Use whatever type of DI makes
					the most sense for a particular class; sometimes, when dealing with
					third party classes to which you do not have the source, the choice
					will already have been made for you - a legacy class may not expose
					any setter methods, and so constructor injection will be the only type
					of DI available to you.
				</p></div><p>
				The <tt class="interfacename">BeanFactory</tt> supports both of these
				variants for injecting dependencies into beans it manages. (It in fact
				also supports injecting setter-based dependencies after some
				dependencies have already been supplied via the constructor approach.)
				The configuration for the dependencies comes in the form of a
				<tt class="interfacename">BeanDefinition</tt>, which is used together with
				<tt class="interfacename">PropertyEditor</tt> instances to know how to
				convert properties from one format to another. However, most users of
				Spring will not be dealing with these classes directly
				(i.e. programmatically), but rather with an XML definition file which
				will be converted internally into instances of these classes, and used
				to load an entire Spring IoC container instance.
			</p><p>
				Bean dependency resolution generally happens as follows:
			</p><div class="orderedlist"><ol type="1"><li><p>
						The <tt class="interfacename">BeanFactory</tt> is created
						and initialized with a configuration which describes all
						the beans. (Most Spring users use a
						<tt class="interfacename">BeanFactory</tt> or
						<tt class="interfacename">ApplicationContext</tt> implementation
						that supports XML format configuration files.)
					</p></li><li><p>
						Each bean has dependencies expressed in the form of
						properties, constructor arguments, or arguments to the
						static-factory method when that is used instead of a normal
						constructor. These dependencies will be provided to the bean,
						<span class="emphasis"><em>when the bean is actually created</em></span>.
					</p></li><li><p>
						Each property or constructor argument is either an actual
						definition of the value to set, or a reference to another bean in
						the container.
					</p></li><li><p>
						<a name="beans-factory-collaborators-propertyeditor"></a>
						Each property or constructor argument which is a value must
						be able to be converted from whatever format it was specified
						in, to the actual type of that property or constructor argument.
						By default Spring can convert a value supplied in string format
						to all built-in types, such as <tt class="literal">int</tt>,
						<tt class="literal">long</tt>, <tt class="literal">String</tt>,
						<tt class="literal">boolean</tt>, etc.
					</p></li></ol></div><p>
				It is important to realize that Spring validates the
				configuration of each bean in a container as the container
				is created, including the validation that properties which are
				bean references are actually referring to valid beans (i.e. the
				beans being referred to are also defined in the container.
				However, the bean properties themselves are not set until the
				bean <span class="emphasis"><em>is actually created</em></span>. For that which
				are singleton-scoped and set to be pre-instantiated (such as
				singleton beans in an <tt class="interfacename">ApplicationContext</tt>),
				creation happens at the time that the container is created, but
				otherwise this is only when the bean is requested. When a bean
				actually has to be created, this will potentially cause a graph
				of other beans to be created, as its dependencies and its
				dependencies' dependencies (and so on) are created and assigned.
			</p><div class="sidebar"><p class="title"><b>Circular dependencies</b></p><p>If you are using predominantly constructor injection it is
			    possible to write and configure your classes and beans such that
			    an unresolvable circular dependency scenario is created.</p><p>Consider the scenario where you have class A, which requires
			    an instance of class B to be provided via constructor injection,
			    and class B, which requires an instance of class A to be provided
			    via constructor injection. If you configure beans for classes A and B
			    to be injected into each other, the Spring IoC container will detect
			    this circular reference at runtime, and throw a
			    <tt class="classname">BeanCurrentlyInCreationException</tt>.</p><p>One possible solution to this issue is to edit the source code of
			    some of your classes to be configured via setters instead of via
			    constructors. Another solution is not to use constructor injection
			    and stick to setter injection only.</p></div><p>
				You can generally trust Spring to do the right thing. It
				will detect mis-configuration issues, such as references to
				non-existent beans and circular dependencies, at container
				load-time. It will actually set properties and resolve
				dependencies (i.e. create those dependencies if needed) as late as
				possible, which is when the bean is actually created. This means that
				a Spring container which has loaded correctly can later generate an
				exception when you request a bean if there is a problem creating that
				bean or one of its dependencies. This could happen if the bean throws
				an exception as a result of a missing or invalid property, for example.
				This potentially delayed visibility of some configuration issues is why
				<tt class="interfacename">ApplicationContext</tt> implementations by default
				pre-instantiate singleton beans. At the cost of some upfront time
				and memory to create these beans before they are actually needed,
				you find out about configuration issues when the
				<tt class="interfacename">ApplicationContext</tt> is created, not later.
				If you wish, you can still override this default behavior and set any of these
				singleton beans to lazy-initialize (i.e. not be pre-instantiated).
			</p><p>
				Finally, if it is not immediately apparent, it is worth mentioning that when
				one or more collaborating beans are being injected into a dependent bean, each
				collaborating bean is <span class="emphasis"><em>totally</em></span> configured prior to being
				passed (via one of the DI flavors) to the dependent bean.
				This means that if bean A has a dependency on bean B, the Spring IoC container
				will <span class="emphasis"><em>totally</em></span> configure bean B prior to invoking (for example)
				the attendant setter method on bean A; you can read '<span class="emphasis"><em>totally configure</em></span>'
				to mean that the bean will be instantiated (if not a pre-instantiated singleton),
				all of its dependencies will be set, and the relevant lifecycle methods (such as
				a <a href="beans.html#beans-factory-lifecycle-initializingbean" title="3.5.1.1.&nbsp;Initialization callbacks">configured init method</a>
				or the
				<a href="beans.html#beans-factory-lifecycle-initializingbean" title="3.5.1.1.&nbsp;Initialization callbacks">IntializingBean callback method</a>)
				will all be invoked.
			</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-some-examples"></a>3.3.1.3.&nbsp;Some examples</h4></div></div><div></div></div><p>First, an example of using XML-based configuration metadata for setter-based DI.
			Find below a small part of a Spring XML configuration file specifying some bean
			definitions.</p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- setter injection using the nested <tt class="literal">&lt;ref/&gt;</tt> element --&gt;</span></i>
  &lt;property name="beanOne"&gt;&lt;ref bean="anotherExampleBean"/&gt;&lt;/property&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- setter injection using the neater 'ref' attribute --&gt;</span></i>
  &lt;property name="beanTwo" ref="yetAnotherBean"/&gt;
  &lt;property name="integerProperty" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</pre><pre class="programlisting">public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }    
}</pre><p>As you can see, setters have been declared to match against the properties
			specified in the XML file.</p><p>Now, an example of using constructor-based DI. Find below a snippet from an XML
            configuration that specifies constructor arguments, and the corresponding Java class.</p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- constructor injection using the nested <tt class="literal">&lt;ref/&gt;</tt> element --&gt;</span></i>
  &lt;constructor-arg&gt;&lt;ref bean="anotherExampleBean"/&gt;&lt;/constructor-arg&gt;
  
  <i class="lineannotation"><span class="lineannotation">&lt;!-- constructor injection using the neater 'ref' attribute --&gt;</span></i>
  &lt;constructor-arg ref="yetAnotherBean"/&gt;
  
  &lt;constructor-arg type="int" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</pre><pre class="programlisting">public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;
    
    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}</pre><p>
				As you can see, the constructor arguments specified in the
				bean definition will be used to pass in as arguments to the constructor
				of the <tt class="classname">ExampleBean</tt>.
			</p><p>
				Now consider a variant of this where instead of using a
				constructor, Spring is told to call a <tt class="literal">static</tt> factory
				method to return an instance of the object:
			</p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"
      factory-method="createInstance"&gt;
  &lt;constructor-arg ref="anotherExampleBean"/&gt;
  &lt;constructor-arg ref="yetAnotherBean"/&gt;
  &lt;constructor-arg value="1"/&gt; 
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</pre><pre class="programlisting">public class ExampleBean {

    <i class="lineannotation"><span class="lineannotation">// a private constructor</span></i>
    private ExampleBean(...) {
      ...
    }
    
    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.
    public static ExampleBean createInstance (
            AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        ExampleBean eb = new ExampleBean (...);
        // some other operations
        ...
        return eb;
    }
}</pre><p>
				Note that arguments to the <tt class="literal">static</tt> factory method
				are supplied via <tt class="literal">constructor-arg</tt> elements, exactly
				the same as if a constructor had actually been used. Also, it is
				important to realize that the type of the class being returned by
				the factory method does not have to be of the same type as the class
				which contains the <tt class="literal">static</tt> factory method, although
				in this example it is. An instance (non-static) factory method would
				be used in an essentially identical fashion (aside from the use of the
				<tt class="literal">factory-bean</tt> attribute instead of the
				<tt class="literal">class</tt> attribute), so details will not be discussed here.
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1836"></a>3.3.2.&nbsp;Constructor Argument Resolution</h3></div></div><div></div></div><p>
				Constructor argument resolution matching occurs using the
				argument's type. If there is no potential for ambiguity in
				the constructor arguments of a bean definition, then the order
				in which the constructor arguments are defined in a bean definition
				is the order in which those arguments will be supplied to the
				appropriate constructor when it is being instantiated. Consider the
				following class...
			</p><pre class="programlisting">package x.y;

public class Foo {

    public Foo(Bar bar, Baz baz) {
        // ...
    }
}</pre><p>
				There is no potential for ambiguity here (assuming of course that <tt class="classname">Bar</tt>
				and <tt class="classname">Baz</tt> classes are not related in an inheritance hierarchy).
				Thus the following configuration will work just fine, and you do not need to
				specify the constructor argument indexes and / or types explicitly... it just plain
				works as you would expect it to.
			</p><pre class="programlisting">&lt;beans&gt;
    &lt;bean name="foo" class="x.y.Foo"&gt;
        &lt;constructor-arg&gt;
            &lt;bean class="x.y.Bar"/&gt;
        &lt;/constructor-arg&gt;
        &lt;constructor-arg&gt;
            &lt;bean class="x.y.Baz"/&gt;
        &lt;/constructor-arg&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>
				When another bean is referenced, the type is known, and
				matching can occur (as was the case with the preceding example).
				When a simple type is used, such as
				<tt class="literal">&lt;value&gt;true&lt;value&gt;</tt>, Spring cannot
				determine the type of the value, and so cannot match by type without
				help. Consider the following class, which is used for the following two
				sections:
			</p><pre class="programlisting">package examples;

public class ExampleBean {

    <i class="lineannotation"><span class="lineannotation">// No. of years to the calculate the Ultimate Answer</span></i>
    private int years;
    
    <i class="lineannotation"><span class="lineannotation">// The Answer to Life, the Universe, and Everything</span></i>
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1866"></a>3.3.2.1.&nbsp;Constructor Argument Type Matching</h4></div></div><div></div></div><p>The above scenario <span class="emphasis"><em>can</em></span> use type matching
				with simple types by explicitly specifying the type of the constructor
				argument using the <tt class="literal">'type'</tt> attribute. For example:</p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
  &lt;constructor-arg type="int" value="7500000"/&gt;
  &lt;constructor-arg type="java.lang.String" value="42"/&gt;
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1879"></a>3.3.2.2.&nbsp;Constructor Argument Index</h4></div></div><div></div></div><p>Constructor arguments can have their index specified explicitly by use of
                the <tt class="literal">index</tt> attribute. For example:</p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
  &lt;constructor-arg index="0" value="7500000"/&gt;
  &lt;constructor-arg index="1" value="42"/&gt;
&lt;/bean&gt;</pre><p>As well as solving the ambiguity problem of multiple simple values, specifying
				an index also solves the problem of	ambiguity where a constructor may have two
				arguments of the same type.	Note that the <span class="emphasis"><em>index is 0 based</em></span>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="http://static.springframework.org/spring/docs/2.0.x/images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>Specifying a constructor argument index is the preferred way of performing
                    constructor IoC.</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-properties-detailed"></a>3.3.3.&nbsp;Bean properties and constructor arguments detailed</h3></div></div><div></div></div><p>As mentioned in the previous section, bean properties and
            constructor arguments can be defined as either references to other
            managed beans (collaborators), or values defined inline. Spring's XML-based
            configuration metadata supports a number of sub-element types
            within its <tt class="literal">&lt;property/&gt;</tt> and
            <tt class="literal">&lt;constructor-arg/&gt;</tt> elements for just this purpose.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-value-element"></a>3.3.3.1.&nbsp;Straight values (primitives, <tt class="literal">Strings</tt>, etc.)</h4></div></div><div></div></div><p>The <tt class="literal">&lt;value/&gt;</tt> element specifies a property or
				constructor argument as a human-readable string representation. As
				mentioned in detail <a href="beans.html#beans-factory-collaborators-propertyeditor">previously</a>,
				JavaBeans <tt class="literal">PropertyEditors</tt> are used to convert these
				string values from a <tt class="classname">java.lang.String</tt> to the
				actual property or argument type.</p><pre class="programlisting">&lt;bean id="myDataSource" destroy-method="close"
    class="org.apache.commons.dbcp.BasicDataSource"&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- results in a <tt class="methodname">setDriverClassName(String)</tt> call --&gt;</span></i>
  &lt;property name="driverClassName"&gt;
    &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="url"&gt;
    &lt;value&gt;jdbc:mysql://localhost:3306/mydb&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="username"&gt;
    &lt;value&gt;root&lt;/value&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-idref-element"></a>3.3.3.1.1.&nbsp;The <tt class="literal">idref</tt> element</h5></div></div><div></div></div><p>
                The <tt class="literal">idref</tt> element is simply an error-proof way to
                pass the <span class="emphasis"><em>id</em></span> of another bean in the container (to
                a <tt class="literal">&lt;constructor-arg/&gt;</tt> or <tt class="literal">&lt;property/&gt;</tt>
                element).</p><pre class="programlisting">&lt;bean id="theTargetBean" class="..."/&gt;

&lt;bean id="theClientBean" class="..."&gt;
    &lt;property name="targetName"&gt;
        &lt;idref bean="theTargetBean" /&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>
            The above bean definition snippet is <span class="emphasis"><em>exactly</em></span> equivalent
            (at runtime) to the following snippet:
        </p><pre class="programlisting">&lt;bean id="theTargetBean" class="..."/&gt;

&lt;bean id="client" class="..."&gt;
    &lt;property name="targetName"&gt;
        &lt;value&gt;theTargetBean&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>The main reason the first form is preferable to
        the second is that using the <tt class="literal">idref</tt> tag allows the
        container to validate <span class="emphasis"><em>at deployment time</em></span> that the
        referenced, named bean actually exists. In the second variation,
        no validation is performed on the value that is passed to the
        <tt class="literal">'targetName'</tt> property of the <tt class="literal">'client'</tt>
        bean. Any typo will only be discovered (with most likely fatal results)
        when the <tt class="literal">'client'</tt> bean is actually instantiated.
        If the <tt class="literal">'client'</tt> bean is a
        <a href="beans.html#beans-factory-scopes" title="3.4.&nbsp;Bean scopes">prototype</a> bean, this typo
        (and the resulting exception) may only be discovered long after the
        container is actually deployed.</p><p>Additionally, if the bean being referred to is in the same XML unit, and
        the bean name is the bean <span class="emphasis"><em>id</em></span>, the <tt class="literal">'local'</tt>
        attribute may be used, which allows the XML parser itself to validate the bean
        id even earlier, at XML document parse time.</p><pre class="programlisting">&lt;property name="targetName"&gt;
   <i class="lineannotation"><span class="lineannotation">&lt;!-- a bean with an id of 'theTargetBean' must exist, else an XML exception will be thrown --&gt;</span></i>
   &lt;idref local="theTargetBean"/&gt;
&lt;/property&gt;</pre><p>By way of an example, one common place (at least in pre-Spring 2.0
        configuration) where the &lt;idref/&gt; element brings value is in the
        configuration of <a href="aop-api.html#aop-pfb-1" title="7.5.1.&nbsp;Basics">AOP interceptors</a> in a
        <tt class="classname">ProxyFactoryBean</tt> bean definition. If you use
        &lt;idref/&gt; elements when specifying the interceptor names, there is
        no chance of inadvertently misspelling an interceptor id.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-ref-element"></a>3.3.3.2.&nbsp;References to other beans (collaborators)</h4></div></div><div></div></div><p>The <tt class="literal">ref</tt> element is the final element allowed
                inside a <tt class="literal">&lt;constructor-arg/&gt;</tt> or
                <tt class="literal">&lt;property/&gt;</tt> definition element. It is used to
                set the value of the specified property to be a reference to another
                bean managed by the container (a collaborator). As
                mentioned in a previous section, the referred-to bean is considered to
                be a dependency of the bean who's property is being set, and will be
                initialized on demand as needed (if it is a singleton bean it may have
                already been initialized by the container) before the property is set.
                All references are ultimately just a reference to another object, but
                there are 3 variations on how the id/name of the other object may be
                specified, which determines how scoping and validation is handled.</p><p>Specifying the target bean by using the <tt class="literal">bean</tt>
                attribute of the <tt class="literal">&lt;ref/&gt;</tt> tag is the most general form,
                and will allow creating a reference to any bean in the same
                container (whether or not in the same XML file), or parent container.
                The value of the <tt class="literal">'bean'</tt> attribute may be the same as either the
                <tt class="literal">'id'</tt> attribute of the target bean, or one of the
                values in the <tt class="literal">'name'</tt> attribute of the target bean.</p><pre class="programlisting">&lt;ref bean="someBean"/&gt;</pre><p>Specifying the target bean by using the <tt class="literal">local</tt>
                attribute leverages the ability of the XML parser to validate XML id
                references within the same file. The value of the
                <tt class="literal">local</tt> attribute must be the same as the
                <tt class="literal">id</tt> attribute of the target bean. The XML parser
                will issue an error if no matching element is found in the same file.
                As such, using the local variant is the best choice (in order to know
                about errors are early as possible) if the target bean is in the same
                XML file.</p><pre class="programlisting">&lt;ref local="someBean"/&gt;</pre><p>Specifying the target bean by using the <tt class="literal">'parent'</tt>
                attribute allows a reference to be created to a bean which is in a
                parent container of the current container. The value of the
                <tt class="literal">'parent'</tt> attribute may be the same as either the
                <tt class="literal">'id'</tt> attribute of the target bean, or one of the
                values in the <tt class="literal">'name'</tt> attribute of the target bean,
                and the target bean must be in a parent container to the current one.
                The main use of this bean reference variant is when you have a hierarchy
                of containers and you want to wrap an existing bean in a parent container
                with some sort of proxy which will have the same name as the parent bean
                (i.e. the bean definition in the child context is overriding the parent
                bean).</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- in the parent context --&gt;</span></i>
&lt;bean id="accountService" class="com.foo.SimpleAccountService"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- insert dependencies as required as here --&gt;</span></i>
&lt;/bean&gt;</pre><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- in the child (descendant) context --&gt;</span></i>
&lt;bean id="accountService"  <i class="lineannotation"><span class="lineannotation">&lt;-- notice that the name of this bean is the <span class="bold"><b>same</b></span> as the name of the <tt class="literal">'parent'</tt> bean</span></i>
      class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
      &lt;property name="target"&gt;
          &lt;ref parent="accountService"/&gt;  <i class="lineannotation"><span class="lineannotation">&lt;-- notice how we refer to the <span class="bold"><b>parent</b></span> bean</span></i>
      &lt;/property&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- insert other configuration and dependencies as required as here --&gt;</span></i>
&lt;/bean&gt;</pre><p>(In all honesty the usage of the <tt class="literal">'parent'</tt> attribute
                is not at all common.)</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-inner-beans"></a>3.3.3.3.&nbsp;Inner beans</h4></div></div><div></div></div><p>A <tt class="literal">&lt;bean/&gt;</tt> element inside the
                <tt class="literal">&lt;property/&gt;</tt> or <tt class="literal">&lt;constructor-arg/&gt;</tt>
                elements is used to define a so-called <i class="firstterm">inner bean</i>. An
                inner bean definition does not need to have any id or name defined, and it is
                best not to even specify any id or name value because said id or name value
                will simply be ignored by the container.</p><p>Find below an example of an inner bean.</p><pre class="programlisting">&lt;bean id="outer" class="..."&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- instead of using a reference to a target bean, simply define the target inline --&gt;</span></i>
  &lt;property name="target"&gt;
    &lt;bean class="com.mycompany.Person"&gt; <i class="lineannotation"><span class="lineannotation">&lt;!-- this is the inner bean --&gt;</span></i>
      &lt;property name="name" value="Fiona Apple"/&gt;
      &lt;property name="age" value="25"/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that in the specific case of inner beans, the <tt class="literal">'singleton'</tt>
                flag and any <tt class="literal">'id'</tt> or <tt class="literal">'name'</tt> attribute are
                effectively ignored. Inner beans are <span class="emphasis"><em>always</em></span> anonymous and they
                are <span class="emphasis"><em>always</em></span> scoped as
                <a href="beans.html#beans-factory-scopes-prototype" title="3.4.2.&nbsp;The prototype scope">prototypes</a>. Please also note
                that it is <span class="emphasis"><em>not</em></span> possible to inject inner beans into
                collaborating beans other than into the enclosing bean.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-collection-elements"></a>3.3.3.4.&nbsp;Collections</h4></div></div><div></div></div><p>The <tt class="literal">&lt;list/&gt;</tt>, <tt class="literal">&lt;set/&gt;</tt>,
                <tt class="literal">&lt;map/&gt;</tt>, and <tt class="literal">&lt;props/&gt;</tt> elements
                allow properties and arguments of the Java <tt class="interfacename">Collection</tt>
                type <tt class="interfacename">List</tt>, <tt class="interfacename">Set</tt>,
                <tt class="interfacename">Map</tt>, and <tt class="interfacename">Properties</tt>,
                respectively, to be defined and set.</p><pre class="programlisting">&lt;bean id="moreComplexObject" class="example.ComplexObject"&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- results in a setAdminEmails(<tt class="classname">java.util.Properties</tt>) call --&gt;</span></i>
  &lt;property name="adminEmails"&gt;
    &lt;props&gt;
        &lt;prop key="administrator"&gt;administrator@somecompany.org&lt;/prop&gt;
        &lt;prop key="support"&gt;support@somecompany.org&lt;/prop&gt;
        &lt;prop key="development"&gt;development@somecompany.org&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- results in a setSomeList(<tt class="interfacename">java.util.List</tt>) call --&gt;</span></i>
  &lt;property name="someList"&gt;
    &lt;list&gt;
        &lt;value&gt;a list element followed by a reference&lt;/value&gt;
        &lt;ref bean="myDataSource" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- results in a setSomeMap(<tt class="interfacename">java.util.Map</tt>) call --&gt;</span></i>
  &lt;property name="someMap"&gt;
    &lt;map&gt;
        &lt;entry&gt;
            &lt;key&gt;
                &lt;value&gt;yup an entry&lt;/value&gt;
            &lt;/key&gt;
            &lt;value&gt;just some string&lt;/value&gt;
        &lt;/entry&gt;
        &lt;entry&gt;
            &lt;key&gt;
                &lt;value&gt;yup a ref&lt;/value&gt;
            &lt;/key&gt;
            &lt;ref bean="myDataSource" /&gt;
        &lt;/entry&gt;
    &lt;/map&gt;
  &lt;/property&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span></i>
  &lt;property name="someSet"&gt;
    &lt;set&gt;
        &lt;value&gt;just some string&lt;/value&gt;
        &lt;ref bean="myDataSource" /&gt;
    &lt;/set&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p><span class="emphasis"><em>Note that the value of a map key or value, or a set value,
                can also again be any of the following elements:</em></span></p><pre class="programlisting">bean | ref | idref | list | set | map | props | value | null</pre><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-collection-elements-merging"></a>3.3.3.4.1.&nbsp;Collection merging</h5></div></div><div></div></div><p>As of Spring 2.0, the container also supports the <span class="emphasis"><em>merging</em></span>
                    of collections. This allows an application developer to define a parent-style
                    <tt class="literal">&lt;list/&gt;</tt>, <tt class="literal">&lt;map/&gt;</tt>,
                    <tt class="literal">&lt;set/&gt;</tt> or <tt class="literal">&lt;props/&gt;</tt> element, and
                    have child-style <tt class="literal">&lt;list/&gt;</tt>, <tt class="literal">&lt;map/&gt;</tt>,
                    <tt class="literal">&lt;set/&gt;</tt> or <tt class="literal">&lt;props/&gt;</tt> elements
                    inherit and override values from the parent collection; i.e. the child collection's
                    values will be the result obtained from the merging of the elements of the parent
                    and child collections, with the child's collection elements overriding values
                    specified in the parent collection.</p><p><span class="emphasis"><em>Please note that this section on merging makes use of the
                    parent-child bean mechanism. This concept has not yet been introduced, so
                    readers unfamiliar with the concept of parent and child bean definitions
                    may wish to read the corresponding section before continuing (see the
                    section entitled <a href="beans.html#beans-child-bean-definitions" title="3.6.&nbsp;Bean definition inheritance">Section&nbsp;3.6, &#8220;Bean definition inheritance&#8221;</a>).</em></span></p><p>An example would perhaps serve best to illustrate this feature:</p><pre class="programlisting">&lt;beans&gt;
&lt;bean id="parent" abstract="true" class="example.ComplexObject"&gt;
    &lt;property name="adminEmails"&gt;
        &lt;props&gt;
            &lt;prop key="administrator"&gt;administrator@somecompany.com&lt;/prop&gt;
            &lt;prop key="support"&gt;support@somecompany.com&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id="child" parent="parent"&gt;
    &lt;property name="adminEmails"&gt;
        <i class="lineannotation"><span class="lineannotation">&lt;!-- the merge is specified on the *child* collection definition --&gt;</span></i>
        &lt;props merge="true"&gt;
            &lt;prop key="sales"&gt;sales@somecompany.com&lt;/prop&gt;
            &lt;prop key="support"&gt;support@somecompany.co.uk&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;beans&gt;</pre><p>Notice the use of the <tt class="literal">merge=true</tt> attribute on the
                    <tt class="literal">&lt;props/&gt;</tt> element of the
                    <tt class="literal">adminEmails</tt> property of the <tt class="literal">child</tt>
                    bean definition. When the <tt class="literal">child</tt> bean is actually resolved
                    and instantiated by the container, the resulting instance will have an
                    <tt class="literal">adminEmails</tt> <tt class="classname">Properties</tt> collection
                    that contains the result of the merging of the child's
                    <tt class="literal">adminEmails</tt> collection with the parent's
                    <tt class="literal">adminEmails</tt> collection.</p><pre class="programlisting">administrator=administrator@somecompany.com
sales=sales@somecompany.com
support=support@somecompany.co.uk</pre><p>Notice how the child <tt class="classname">Properties</tt> collection's
                    value set will have inherited all the property elements from the parent
                    <tt class="literal">&lt;props/&gt;</tt>. Notice also how the child's value for
                    the <tt class="literal">support</tt> value overrides the attendant value in the
                    parent collection.</p><p>This merging behavior applies similarly to the <tt class="literal">&lt;list/&gt;</tt>,
                    <tt class="literal">&lt;map/&gt;</tt>, and <tt class="literal">&lt;set/&gt;</tt> collection
                    types. In the specific case of the <tt class="literal">&lt;list/&gt;</tt> element, the
                    semantics associated with the <tt class="classname">List</tt> collection type, i.e. the
                    notion of an <tt class="literal">ordered</tt> collection of values, is maintained;
                    the parent's values will precede all of the child list's values. In the
                    case of the <tt class="interfacename">Map</tt>, <tt class="interfacename">Set</tt>,
                    and <tt class="interfacename">Properties</tt> collection types, there is no notion
                    of ordering and hence no ordering semantics are in effect for the collection types that
                    underlie the associated <tt class="interfacename">Map</tt>,
                    <tt class="interfacename">Set</tt> and <tt class="interfacename">Properties</tt>
                    implementation types used internally by the container.</p><p>Finally, some minor notes about the merging support are in order; you
                    cannot merge different collection types (e.g. a <tt class="interfacename">Map</tt> and
                    a <tt class="interfacename">List</tt>), and if you do attempt to do so an appropriate
                    <tt class="classname">Exception</tt> will be thrown; and in case it is not
                    immediately obvious, the <tt class="literal">'merge'</tt> attribute must be specified
                    on the lower level, inherited, child definition; specifying the
                    <tt class="literal">'merge'</tt> attribute on a parent collection definition is
                    redundant and will not result in the desired merging; and (lastly), please
                    note that this merging feature is only available in Spring 2.0 (and later
                    versions).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e2354"></a>3.3.3.4.2.&nbsp;Strongly-typed collection (Java5+ only)</h5></div></div><div></div></div><p>If you are one of the lucky few to be using Java5 (Tiger), you will be aware
                    that it is possible (and I daresay recommended) to have strongly typed collections.
                    That is, it is possible to declare a <tt class="interfacename">Collection</tt> type
                    such that it can only contain <tt class="classname">String</tt> elements (for example).</p><p>If you are using Spring to dependency inject a strongly-typed
                    <tt class="interfacename">Collection</tt> into a bean, you can take advantage
                    of Spring's type-conversion support such that the elements of your strongly-typed
                    <tt class="interfacename">Collection</tt> instances will be converted to the
                    appropriate type prior to being added to the
                    <tt class="interfacename">Collection</tt>.</p><p>An example will make this clear; consider the following class definition, and
                    it's attendant (XML) configuration...</p><pre class="programlisting">public class Foo {
                
    private Map&lt;String, Float&gt; accounts;
    
    public void setAccounts(Map&lt;String, Float&gt; accounts) {
        this.accounts = accounts;
    }

}</pre><pre class="programlisting">&lt;beans&gt;
    &lt;bean id="foo" class="x.y.Foo"&gt;
        &lt;property name="accounts"&gt;
            &lt;map&gt;
                &lt;entry key="one" value="9.99"/&gt;
                &lt;entry key="two" value="2.75"/&gt;
                &lt;entry key="six" value="3.99"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>When the <tt class="literal">'accounts'</tt> property of the <tt class="literal">'foo'</tt>
                    bean is being prepared for injection, the generics information about the element
                    type of the strongly-typed <tt class="classname">Map&lt;String, Float&gt;</tt> is
                    actually available via reflection, and so Spring's type conversion infrastructure
                    will actually recognize the various value elements as being of type
                    <tt class="classname">Float</tt>
                    and so the string values <tt class="literal">'9.99', '2.75'</tt>, and <tt class="literal">'3.99'</tt>
                    will be converted into an actual <tt class="classname">Float</tt> type.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-null-element"></a>3.3.3.5.&nbsp;<tt class="literal">Nulls</tt></h4></div></div><div></div></div><p>The <tt class="literal">&lt;null/&gt;</tt> element is used to handle
                <tt class="literal">null</tt> values. Spring treats empty arguments for
                properties and the like as empty <tt class="literal">Strings</tt>. The following
                XML-based configuration metadata snippet  results in the email property
                being set to the empty <tt class="classname">String</tt> value ("")</p><pre class="programlisting">&lt;bean class="ExampleBean"&gt;
  &lt;property name="email"&gt;&lt;value&gt;&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>This is equivalent to the following Java code:
                <tt class="literal">exampleBean.setEmail("")</tt>. The special
                <tt class="literal">&lt;null&gt;</tt> element may be used to indicate a
                <tt class="literal">null</tt> value. For example:</p><pre class="programlisting">&lt;bean class="ExampleBean"&gt;
  &lt;property name="email"&gt;&lt;null/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>The above configuration is equivalent to the following Java code:
                <tt class="literal">exampleBean.setEmail(null)</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2443"></a>3.3.3.6.&nbsp;XML-based configuration metadata shortcuts</h4></div></div><div></div></div><p>It is so common to need to configure a value or a bean
                reference, that there exist some shortcut forms which are less verbose
                than using the full <tt class="literal">&lt;value/&gt;</tt> and
                <tt class="literal">&lt;ref/&gt;</tt> elements. The <tt class="literal">&lt;property/&gt;</tt>,
                <tt class="literal">&lt;constructor-arg/&gt;</tt>, and <tt class="literal">&lt;entry/&gt;</tt>
                elements all support a <tt class="literal">'value'</tt> attribute which may be
                used instead of embedding a full <tt class="literal">&lt;value/&gt;</tt> element.
                Therefore, the following:</p><pre class="programlisting">&lt;property name="myProperty"&gt;
  &lt;value&gt;hello&lt;/value&gt;
&lt;/property&gt;</pre><pre class="programlisting">&lt;constructor-arg&gt;
  &lt;value&gt;hello&lt;/value&gt;
&lt;/constructor-arg&gt;</pre><pre class="programlisting">&lt;entry key="myKey"&gt;
  &lt;value&gt;hello&lt;/value&gt;
&lt;/entry&gt;</pre><p>are equivalent to:</p><pre class="programlisting">&lt;property name="myProperty" value="hello"/&gt;</pre><pre class="programlisting">&lt;constructor-arg value="hello"/&gt;</pre><pre class="programlisting">&lt;entry key="myKey" value="hello"/&gt;</pre><p>In general, when typing definitions by hand, you will probably prefer to
                use the less verbose shortcut form (the Spring team certainly does).</p><p>The <tt class="literal">&lt;property/&gt;</tt> and
                <tt class="literal">&lt;constructor-arg/&gt;</tt> elements support a similar
                shortcut <tt class="literal">'ref'</tt> attribute which may be used instead
                of a full nested <tt class="literal">&lt;ref/&gt;</tt> element. Therefore,
                the following:</p><pre class="programlisting">&lt;property name="myProperty"&gt;
  &lt;ref bean="myBean"&gt;
&lt;/property&gt;</pre><pre class="programlisting">&lt;constructor-arg&gt;
  &lt;ref bean="myBean"&gt;
&lt;/constructor-arg&gt;</pre><p>are equivalent to:</p><pre class="programlisting">&lt;property name="myProperty" ref="myBean"/&gt;</pre><pre class="programlisting">&lt;constructor-arg ref="myBean"/&gt;</pre><p>Note however that the shortcut form is equivalent to a
                <tt class="literal">&lt;ref bean="xxx"&gt;</tt> element; there is no
                shortcut for <tt class="literal">&lt;ref local="xxx"</tt>&gt;. To enforce a
                strict local reference, you must use the long form.</p><p>Finally, the entry element allows a shortcut form to specify the
                key and/or value of the map, in the form of the <tt class="literal">'key'</tt>
                / <tt class="literal">'key-ref'</tt> and <tt class="literal">'value'</tt> /
                <tt class="literal">'value-ref'</tt> attributes. Therefore, the following:</p><pre class="programlisting">&lt;entry&gt;
  &lt;key&gt;
    &lt;ref bean="myKeyBean" /&gt;
  &lt;/key&gt;
  &lt;ref bean="myValueBean" /&gt;
&lt;/entry&gt;</pre><p>is equivalent to:</p><pre class="programlisting">&lt;entry key-ref="myKeyBean" value-ref="myValueBean"/&gt;</pre><p>Again, the shortcut form is equivalent to a
                <tt class="literal">&lt;ref bean="xxx"&gt;</tt> element; there is no shortcut for
                <tt class="literal">&lt;ref local="xxx"</tt>&gt;.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2545"></a>3.3.3.7.&nbsp;Compound property names</h4></div></div><div></div></div><p>Compound or nested property names are perfectly legal
                when setting bean properties, as long as all components of the path
                except the final property name are non-null. For example, in this bean
                definition:</p><pre class="programlisting">&lt;bean id="foo" class="foo.Bar"&gt;
  &lt;property name="fred.bob.sammy" value="123" /&gt;
&lt;/bean&gt;</pre><p>The <tt class="literal">foo</tt> bean has a <tt class="literal">fred</tt> property
                which has a <tt class="literal">bob</tt> property, which has a 
                <tt class="literal">sammy</tt> property, and that final <tt class="literal">sammy</tt>
                property is being set to a scalar value of <tt class="literal">123</tt>. In order
                for this to work, the <tt class="literal">fred</tt> property of <tt class="literal">foo</tt>,
                and the <tt class="literal">bob</tt> property of <tt class="literal">fred</tt> must both
                be non-null after the bean is constructed, or a
                <tt class="exceptionname">NullPointerException</tt> will be thrown.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-dependson"></a>3.3.4.&nbsp;Using <tt class="literal">depends-on</tt></h3></div></div><div></div></div><p>For most situations, the fact that a bean is a dependency of another is 
            expressed simply by the fact that one bean is set as a property of another.
            This is typically accomplished with the <tt class="literal">&lt;ref/&gt;</tt> element
            in XML-based configuration metadata. In a variation of this, sometimes a bean
            which is aware of the container is simply given the id of its dependency (using
            a string value or alternately the <tt class="literal">&lt;idref/&gt;</tt> element,
            which evaluates the same as a string value). The first bean then programmatically
            asks the container for its dependency. In either case, the dependency is properly
            initialized before the dependent bean.</p><p>For the relatively infrequent situations where dependencies
			between beans are less direct (for example, when a static initializer in
			a class needs to be triggered, such as database driver registration),
			the <tt class="literal">'depends-on'</tt> attribute may be used to explicitly
			force one or more beans to be initialized before the bean using this
			element is initialized. Find below an example of using the
			<tt class="literal">'depends-on'</tt> attribute to express a dependency on a single bean.</p><pre class="programlisting">&lt;bean id="beanOne" class="ExampleBean" depends-on="manager"/&gt;

&lt;bean id="manager" class="ManagerBean" /&gt;</pre><p>If you need to express a dependency on multiple beans, you can supply a
            delimited list of bean names as the value of the <tt class="literal">'depends-on'</tt>
            attribute, with commas, whitespace and semi-colons all valid delimiters. Find
            below an example of using <tt class="literal">'depends-on'</tt> to express a dependency
            on a number of beans.</p><pre class="programlisting">&lt;bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao"&gt;
  &lt;property name="manager" ref="manager" /&gt;
&lt;/bean&gt;

&lt;bean id="manager" class="ManagerBean" /&gt;
&lt;bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" /&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-lazy-init"></a>3.3.5.&nbsp;Lazily-instantiating beans</h3></div></div><div></div></div><p>The default behavior for <tt class="interfacename">ApplicationContext</tt>
            implementations is to eagerly pre-instantiate all <tt class="literal">singleton</tt> beans
            at startup. Pre-instantiation means that an <tt class="interfacename">ApplicationContext</tt>
            implementation instance will eagerly create and configure all of it's singleton beans
            as part of its initialization process. This is generally <span class="emphasis"><em>a good thing</em></span>,
            because it means that any errors in the configuration or in the attendant environment
            will be discovered immediately (as opposed to possibly hours or even days down the line).</p><p>However, there are times when this behavior is <span class="emphasis"><em>not</em></span> what is wanted.
            If you do not want a singleton bean to be pre-instantiated when using
            an <tt class="interfacename">ApplicationContext</tt> implementation, you can (on
            a bean-definition by bean-definition basis) selectively control this by marking a
            bean definition as lazy-initialized. A lazily-initialized bean indicates to the
            IoC container whether or not a bean instance should be created at startup or when it
            is first requested.</p><p>When configuring beans via XML, this lazy loading is controlled by the
            <tt class="literal">'lazy-init'</tt> attribute on the <tt class="literal">&lt;bean/&gt;</tt>
            element; for example:</p><pre class="programlisting">&lt;bean id="lazy" class="com.foo.ExpensiveToCreateBean" <span class="bold"><b>lazy-init="true"</b></span>&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- various properties here... --&gt;</span></i>
&lt;/bean&gt;

&lt;bean name="not.lazy" class="com.foo.AnotherBean"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- various properties here... --&gt;</span></i>
&lt;/bean&gt;</pre><p>When the above configuration is consumed by an
            <tt class="interfacename">ApplicationContext</tt> implementation, the bean named
            <tt class="literal">'lazy'</tt> will <span class="emphasis"><em>not</em></span> be eagerly pre-instantiated
            when the <tt class="interfacename">ApplicationContext</tt> is starting up, whereas
            the <tt class="literal">'not.lazy'</tt> bean will be eagerly pre-instantiated.</p><p>One thing to understand about lazy-initialization is that even though a bean
            definition may be marked up as being lazy-initialized, if the lazy-initialized bean
            is the dependency of a singleton bean that is not lazy-initialized, when the
            <tt class="interfacename">ApplicationContext</tt> is eagerly pre-instantiating the
            singleton, it will (of course) have to satisfy all of said singletons dependencies,
            one of which will be the lazy-initialized bean! So don't be confused if the IoC
            container creates one of the beans that you have explicitly configured as
            lazy-initialized at startup; all that means is that the lazy-initialized bean
            probably is being injected into a non-lazy-initialized singleton bean elsewhere
            in your configuration.</p><p>It is also possible to control lazy-initialization at the container level by using
            the <tt class="literal">'default-lazy-init'</tt> attribute on the <tt class="literal">&lt;beans/&gt;</tt>
            element; for example:</p><pre class="programlisting">&lt;beans default-lazy-init="true"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- no beans will be eagerly pre-instantiated... --&gt;</span></i>
&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-autowire"></a>3.3.6.&nbsp;Autowiring collaborators</h3></div></div><div></div></div><p>A Spring IoC container is able to <span class="emphasis"><em>autowire</em></span>
            relationships between collaborating beans. This means that it is possible to
            automatically let Spring resolve collaborators (other beans) for your
            bean by inspecting the contents of the <tt class="interfacename">BeanFactory</tt>.
            The autowiring functionality has five modes. Autowiring is specified
            <span class="emphasis"><em>per</em></span> bean and can thus be enabled for some beans,
            while other beans won't be autowired. Using autowiring, it is possible
            to reduce or eliminate the need to specify properties or constructor
            arguments, saving a significant amount of typing.
            <sup>[<a name="d0e2713" href="#ftn.d0e2713">2</a>]</sup>
            When using XML-based configuration metadata, the autowire mode for a bean definition
            is specified by using the <tt class="literal">autowire</tt> attribute of the
            <tt class="literal">&lt;bean/&gt;</tt> element. The following values are allowed:</p><div class="table"><a name="d0e2724"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;Autowiring modes</b></p><table summary="Autowiring modes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Mode</th><th>Explanation</th></tr></thead><tbody><tr><td>no</td><td><p>No autowiring at all. Bean references must be defined
                                via a <tt class="literal">ref</tt> element. This is the default, and
                                changing this is discouraged for larger deployments, since
                                explicitly specifying collaborators gives greater control and
                                clarity. To some extent, it is a form of documentation about
                                the structure of a system.</p></td></tr><tr><td>byName</td><td><p>Autowiring by property name. This option will inspect
                                the container and look for a bean named exactly the same as
                                the property which needs to be autowired. For example, if you
                                have a bean definition which is set to autowire by name, and
                                it contains a <span class="emphasis"><em>master</em></span> property (that is,
                                it has a <span class="emphasis"><em>setMaster(..)</em></span> method), Spring
                                will look for a bean definition named <tt class="literal">master</tt>,
                                and use it to set the property.</p></td></tr><tr><td>byType</td><td><p>Allows a property to be autowired if there is exactly
                                one bean of the property type in the container. If there is
                                more than one, a fatal exception is thrown, and this indicates
                                that you may not use <span class="emphasis"><em>byType</em></span> autowiring
                                for that bean. If there are no matching beans, nothing
                                happens; the property is not set. If this is not desirable,
                                setting the <tt class="literal">dependency-check="objects"</tt>
                                attribute value specifies that an error should be thrown in
                                this case.</p></td></tr><tr><td>constructor</td><td><p>This is analogous to <span class="emphasis"><em>byType</em></span>, but
                                applies to constructor arguments. If there isn't exactly one
                                bean of the constructor argument type in the container, a
                                fatal error is raised.</p></td></tr><tr><td>autodetect</td><td><p>Chooses <span class="emphasis"><em>constructor</em></span> or
                                <span class="emphasis"><em>byType</em></span> through introspection of the bean
                                class. If a default constructor is found, the
                                <span class="emphasis"><em>byType</em></span> mode will be applied.</p></td></tr></tbody></table></div><p>Note that explicit dependencies in <tt class="literal">property</tt> and
            <tt class="literal">constructor-arg</tt> settings <tt class="interfacename">always</tt>
            override autowiring. Please also note that it is not currently possible to autowire
            so-called <span class="emphasis"><em>simple</em></span> properties such as primitives,
            <tt class="classname">Strings</tt>, and <tt class="classname">Classes</tt> (and arrays of such
            simple properties).(This is by-design and should be considered a <span class="emphasis"><em>feature</em></span>.)
            Autowire behavior can be combined with dependency checking, which will
            be performed after all autowiring has been completed.</p><p>It is important to understand the various advantages and disadvantages of autowiring.
            Some advantages of autowiring include:</p><div class="itemizedlist"><ul type="disc"><li><p>Autowiring can significantly reduce the volume of configuration
                    required. However, mechanisms such as the use of a bean template
                    (<a href="beans.html#beans-child-bean-definitions" title="3.6.&nbsp;Bean definition inheritance">discussed elsewhere in this chapter</a>)
                    are also valuable in this regard.</p></li><li><p>Autowiring can cause configuration to keep itself up to date
                    as your objects evolve. For example, if you need to add an additional
                    dependency to a class, that dependency can be satisfied
                    automatically without the need to modify configuration. Thus there
                    may be a strong case for autowiring during development, without
                    ruling out the option of switching to explicit wiring when the code
                    base becomes more stable.</p></li></ul></div><p>Some disadvantages of autowiring:</p><div class="itemizedlist"><ul type="disc"><li><p>Autowiring is more magical than explicit wiring. Although,
                    as noted in the above table, Spring is careful to avoid guessing
                    in case of ambiguity which might have unexpected results, the
                    relationships between your Spring-managed objects is no longer
                    explicitly documented.</p></li><li><p>Wiring information may not be available to tools that may
                    generate documentation from a Spring container.</p></li><li><p>Autowiring by type will only work when there is a single bean
                    definition of the type specified by the setter method or constructor
                    argument. You need to use explicit wiring if there is any potential
                    ambiguity.</p></li></ul></div><p>There is no "wrong" or "right" answer in all cases. A degree of
            consistency across a project is best though; for example, if autowiring is
            not used in general, it might be confusing to developers to use it just
            to wire one or two bean definitions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-autowire-candidate"></a>3.3.6.1.&nbsp;Excluding a bean from being available for autowiring</h4></div></div><div></div></div><p>You can also (on a per bean basis) totally exclude a bean from being an
                autowire candidate. When configuring beans using Spring's XML format, the
                <tt class="literal">'autowire-candidate'</tt> attribute of the
                <tt class="literal">&lt;bean/&gt;</tt> element can be set to
                <tt class="literal">'false'</tt>; this has the effect of making the container
                totally exclude that specific bean definition from being available
                to the autowiring infrastructure.</p><p>This can be useful when you have a bean that you absolutely never ever
                want to have injected into other beans via autowiring. It does not
                mean that the excluded bean cannot itself be configured using autowiring...
                it can, it is rather that it itself will not be considered as a candidate
                for autowiring other beans.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-dependencies"></a>3.3.7.&nbsp;Checking for dependencies</h3></div></div><div></div></div><p>The Spring IoC container also has the ability to try to check for the
			existence of unresolved dependencies of a bean deployed into the container.
			These are JavaBeans properties of the bean, which do not have actual values
			set for them in the bean definition, or alternately provided
			automatically by the autowiring feature.</p><p>This feature is sometimes useful when you want to ensure that all
			properties (or all properties of a certain type) are set on a bean. Of
			course, in many cases a bean class will have default values for many
			properties, or some properties do not apply to all usage scenarios, so
			this feature is of limited use. Dependency checking can also be enabled
			and disabled per bean, just as with the autowiring functionality. The
			default is to <span class="emphasis"><em>not</em></span> check dependencies. Dependency
			checking can be handled in several different modes. When using
			XML-based configuration metadata, this is specified via the
			<tt class="literal">'dependency-check'</tt> attribute in a bean definition,
			which may have the following values.</p><div class="table"><a name="d0e2875"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;Dependency checking modes</b></p><table summary="Dependency checking modes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Mode</th><th>Explanation</th></tr></thead><tbody><tr><td>none</td><td><p>No dependency checking. Properties of the bean which
                                have no value specified for them are simply not set.</p></td></tr><tr><td>simple</td><td><p>Dependency checking is performed for primitive types
                                and collections (everything except collaborators, i.e. other
                                beans)</p></td></tr><tr><td>object</td><td><p>Dependency checking is performed for collaborators only</p></td></tr><tr><td>all</td><td><p>Dependency checking is done for collaborators, primitive types
                                and collections</p></td></tr></tbody></table></div><p>If you are using Java 5 (Tiger) and thus have access to source level annotations,
			you may find the section entitled <a href="metadata.html#metadata-annotations-required" title="25.3.1.&nbsp;@Required">Section&nbsp;25.3.1, &#8220;@Required&#8221;</a>
			to be of interest.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-method-injection"></a>3.3.8.&nbsp;Method Injection</h3></div></div><div></div></div><p>For most application scenarios, the majority of the beans in the
            container will be singletons. When a singleton bean needs to collaborate
            with (use) another singleton bean, or a non-singleton bean needs to collaborate
            with another non-singleton bean, the typical and common approach of
            handling this dependency by defining one bean to be a property of the
            other, is quite adequate. There is however a problem when the bean
            lifecycles are different. Consider a singleton bean A which needs to use
            a non-singleton (prototype) bean B, perhaps on each method invocation on
            A. The container will only create the singleton bean A once, and thus
            only get the opportunity to set its properties once. There is no
            opportunity for the container to provide bean A with a new instance of
            bean B every time one is needed.</p><p>One solution to this issue is to forgo some inversion of
            control. Bean A can be
            <a href="beans.html#beans-factory-aware-beanfactoryaware" title="3.5.2.1.&nbsp;&#xA;                    BeanFactoryAware&#xA;                ">made aware of the container</a>
            by implementing the <tt class="interfacename">BeanFactoryAware</tt> interface, and
            <a href="beans.html#beans-factory-client" title="3.2.4.&nbsp;Using the container">use programmatic means</a> to
            ask the container via a <tt class="methodname">getBean("B")</tt> call for
            (a typically new) bean B instance every time it needs it. Find below an
            admittedly somewhat contrived example of this approach:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// a class that uses a stateful Command-style class to perform some processing</span></i>
package fiona.apple;

<i class="lineannotation"><span class="lineannotation">// lots of Spring-API imports</span></i>
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;

public class CommandManager implements BeanFactoryAware {

   private BeanFactory beanFactory;

   public Object process(Map commandState) {
      <i class="lineannotation"><span class="lineannotation">// grab a new instance of the appropriate <tt class="interfacename">Command</tt></span></i>
      Command command = createCommand();
      <i class="lineannotation"><span class="lineannotation">// set the state on the (hopefully brand new) <tt class="interfacename">Command</tt> instance</span></i>
      command.setState(commandState);
      return command.execute();
   }

   <i class="lineannotation"><span class="lineannotation">// the <tt class="interfacename">Command</tt> returned here could be an implementation that executes asynchronously, or whatever</span></i>
   protected Command createCommand() {
      return (Command) this.beanFactory.getBean("command"); <i class="lineannotation"><span class="lineannotation">// notice the Spring API dependency</span></i>
   }

   public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
   }
}</pre><p>The above example is generally is not a desirable solution since the
            business code is then aware of and coupled to the Spring Framework. Method Injection,
            a somewhat advanced feature of the Spring IoC container, allows this use case to be
            handled in a clean fashion.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2964"></a>3.3.8.1.&nbsp;Lookup method injection</h4></div></div><div></div></div><div class="sidebar"><p class="title"><b>Isn't this Method Injection...</b></p><p>... somewhat like Tapestry 4.0's pages, where folks wrote
                    <tt class="literal">abstract</tt> properties that Tapestry would override at
                    runtime with implementations that did stuff? It sure is (well, kinda).</p><p>You can read more about the motivation for Method Injection in
                    <a href="http://blog.springframework.com/rod/?p=1" target="_top">this blog entry</a>.</p></div><p>Lookup method injection refers to the ability of the container
                to override methods on <span class="emphasis"><em>container managed beans</em></span>, to
                return the result of looking up another named bean in the container.
                The lookup will typically be of a prototype bean as in the scenario
                described above (although it can also be a singleton of course - but in that
                case injecting the instance straight into the object would suffice). The
                Spring Framework implements this method injection by dynamically generating
                a subclass overriding the method, using bytecode generation via the CGLIB library.</p><p>So if you look at the code from previous code snippet (the
                <tt class="classname">CommandManager</tt> class), the Spring container
                is going to dynamically override the implementation of the
                <tt class="methodname">createCommand()</tt> method. Your
                <tt class="classname">CommandManager</tt> class is not going to have any
                Spring dependencies, as can be seen in this reworked example below:</p><pre class="programlisting">package fiona.apple;

<i class="lineannotation"><span class="lineannotation">// no more Spring imports! </span></i>

public class CommandManager {

   public Object process(Object command) {
      <i class="lineannotation"><span class="lineannotation">// grab a new instance of the appropriate <tt class="interfacename">Command</tt> interface</span></i>
      Command command = createCommand();
      <i class="lineannotation"><span class="lineannotation">// set the state on the (hopefully brand new) <tt class="interfacename">Command</tt> instance</span></i>
      command.setState(commandState);
      return command.execute();
   }

    <i class="lineannotation"><span class="lineannotation">// mmm, but where is the implementation of this method?</span></i>
   protected abstract CommandHelper createHelper();

}</pre><p>In the client class containing the method to be injected (the
                <tt class="classname">CommandManager</tt> in this case), the method that
                is to be 'injected' must have a signature of the following form:</p><pre class="programlisting">&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(<i class="lineannotation"><span class="lineannotation">no-arguments</span></i>);</pre><p>If the method is <tt class="literal">abstract</tt>, the dynamically-generated
                subclass will implement the method. Otherwise, the dynamically-generated subclass
                will override the concrete method defined in the original class. Let's look at an
                example:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span></i>
&lt;bean id="command" class="fiona.apple.AsyncCommand" scope="prototype"&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- inject dependencies here as required --&gt;</span></i>
&lt;/bean&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="literal">commandProcessor</tt> uses <tt class="literal">statefulCommandHelper</tt> --&gt;</span></i>
&lt;bean id="commandManager" class="fiona.apple.CommandManager"&gt;
  &lt;lookup-method name="createCommand" bean="command"/&gt;
&lt;/bean&gt;</pre><p>The bean identified as <span class="emphasis"><em>commandManager</em></span> will call its
                own method <tt class="literal">createCommand</tt> whenever it needs
                a new instance of the <span class="emphasis"><em>command</em></span> bean. It
                is important to note that the person deploying the beans must be
                careful to deploy the <tt class="literal">command</tt> bean as a
                prototype (if that is actually what is needed). If it is deployed
                as a singleton (either explicitly, or relying on the default
                <span class="emphasis"><em>true</em></span> setting for this flag), the same instance of
                the <tt class="literal">command</tt> bean will be returned each time!</p><p>Note that lookup method injection can be combined with
                both Constructor and Setter Injection.</p><p>Please be aware that in order for this dynamic subclassing to work,
                you will need to have the CGLIB jar(s) on your classpath. Additionally, the
                class that the Spring container is going to subclass cannot be
                <tt class="literal">final</tt>, and the method that is being overridden cannot be
                <tt class="literal">final</tt> either. Also, testing a class that has an
                <tt class="literal">abstract</tt> method can be somewhat odd in that you will have
                to subclass the class yourself and supply a stub implementation of the
                <tt class="literal">abstract</tt> method. Finally, beans that have been the target
                of method injection cannot be serialized.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="http://static.springframework.org/spring/docs/2.0.x/images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>The interested reader may also find the <tt class="classname">ServiceLocatorFactoryBean</tt>
                    (in the <tt class="literal">org.springframework.beans.factory.config</tt> package) to be
                    of use... the approach is similar to that of the
                    <tt class="classname">ObjectFactoryCreatingFactoryBean</tt>, but it allows you
                    to specify your own lookup interface as opposed to having to use a Spring-specific
                    lookup interface such as the <tt class="interfacename">ObjectFactory</tt>.
                    Consult the (copious) Javadocs for the <tt class="classname">ServiceLocatorFactoryBean</tt>
                    for a full treatment of this alternative approach (that <span class="emphasis"><em>does</em></span>
                    reduce the coupling to Spring).</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3104"></a>3.3.8.2.&nbsp;Arbitrary method replacement</h4></div></div><div></div></div><p>A less commonly useful form of method injection than Lookup
                Method Injection is the ability to replace arbitrary methods in a
                managed bean with another method implementation. Users may safely skip
                the rest of this section (which describes this somewhat advanced
                feature), until this functionality is actually needed.</p><p>When using XML-based configuration metadata, the <tt class="literal">replaced-method</tt>
                element may be used to replace an existing method implementation with
                another, for a deployed bean. Consider the following class, with a
                method computeValue, which we want to override:</p><pre class="programlisting">public class MyValueCalculator {

  public String computeValue(String input) {
    <i class="lineannotation"><span class="lineannotation">// some real code...</span></i>
  }

  <i class="lineannotation"><span class="lineannotation">// some other methods...</span></i>

}</pre><p>A class implementing the
                <tt class="interfacename">org.springframework.beans.factory.support.MethodReplacer</tt>
                interface provides the new method definition.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">/** meant to be used to override the existing computeValue
    implementation in <tt class="classname">MyValueCalculator</tt> */</span></i>
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        <i class="lineannotation"><span class="lineannotation">// get the input value, work with it, and return a computed result</span></i>
        String input = (String) args[0];
        ... 
        return ...;
}</pre><p>The bean definition to deploy the original class and specify the
                method override would look like this:</p><pre class="programlisting">&lt;bean id="myValueCalculator class="x.y.z.MyValueCalculator"&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- arbitrary method replacement --&gt;</span></i>
  &lt;replaced-method name="computeValue" replacer="replacementComputeValue"&gt;
    &lt;arg-type&gt;String&lt;/arg-type&gt;
  &lt;/replaced-method&gt;
&lt;/bean&gt;

&lt;bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/&gt;</pre><p>One or more contained <tt class="literal">&lt;arg-type/&gt;</tt> elements
                within the <tt class="literal">&lt;replaced-method/&gt;</tt> element may be used to
                indicate the method signature of the method being overridden. Note
                that the signature for the arguments is actually only needed in the
                case that the method is actually overloaded and there are multiple
                variants within the class. For convenience, the type string for an
                argument may be a substring of the fully qualified type name. For
                example, all the following would match <tt class="classname">java.lang.String</tt>.</p><pre class="programlisting">    java.lang.String
    String
    Str</pre><p>Since the number of arguments is often enough to distinguish between
                each possible choice, this shortcut can save a lot of typing, by allowing
                you to type just the shortest string that will match an argument type.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-factory-scopes"></a>3.4.&nbsp;Bean scopes</h2></div></div><div></div></div><p>When you create a bean definition (typically in an XML configuration file)
        what you are actually creating is (loosely speaking) a <span class="emphasis"><em>recipe</em></span>
        or template for creating actual instances of the objects defined by that
        bean definition. The fact that a bean definition is a recipe is important,
        because it means that, just like a class, you can potentially have many object
        instances created from a single recipe.</p><p>You can control not only the various dependencies and
        configuration values that are to be plugged into an object that is created
        from a particular bean definition, but also the <i class="firstterm">scope</i>
        of the objects created from a particular bean definition. This approach is very
        powerful and gives you the flexibility to <span class="emphasis"><em>choose</em></span> the scope
        of the objects you create through configuration instead of having to 'bake in' 
        the scope of an object at the Java class level. Beans can be defined to be 
        deployed in one of a number of scopes:
        out of the box, the Spring Framework supports exactly five scopes (of which 
        three are available only if you are using a web-aware Spring
        <tt class="interfacename">ApplicationContext</tt>).</p><p>The scopes supported out of the box are listed below:</p><div class="table"><a name="d0e3180"></a><p class="title"><b>Table&nbsp;3.4.&nbsp;Bean scopes</b></p><table summary="Bean scopes" border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Scope</th><th align="center">Description</th></tr></thead><tbody><tr><td><p><a href="beans.html#beans-factory-scopes-singleton" title="3.4.1.&nbsp;The singleton scope">singleton</a></p></td><td><p>Scopes a single bean definition to a single object instance per Spring IoC container.</p></td></tr><tr><td><p><a href="beans.html#beans-factory-scopes-prototype" title="3.4.2.&nbsp;The prototype scope">prototype</a></p></td><td><p>Scopes a single bean definition to any number of object instances.</p></td></tr><tr><td><p><a href="beans.html#beans-factory-scopes-request" title="3.4.3.2.&nbsp;The request scope">request</a></p></td><td><p>Scopes a single bean definition to the lifecycle of
							a single HTTP request; i.e. each and every HTTP request will
							have its own instance of a bean created off the back of a
							single bean definition. Only valid in the context of a
							web-aware Spring <tt class="interfacename">ApplicationContext</tt>.</p></td></tr><tr><td><p><a href="beans.html#beans-factory-scopes-global-session" title="3.4.3.4.&nbsp;The global session scope">session</a></p></td><td><p>Scopes a single bean definition to the lifecycle of
							a HTTP <tt class="interfacename">Session</tt>. Only valid in
							the context of a web-aware Spring
							<tt class="interfacename">ApplicationContext</tt>.</p></td></tr><tr><td><p><a href="beans.html#beans-factory-scopes-global-session" title="3.4.3.4.&nbsp;The global session scope">global session</a></p></td><td><p>Scopes a single bean definition to the lifecycle of a
							global HTTP <tt class="interfacename">Session</tt>. Typically
							only valid when used in a portlet context. Only valid in the
							context of a web-aware Spring
							<tt class="interfacename">ApplicationContext</tt>.</p></td></tr></tbody></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-scopes-singleton"></a>3.4.1.&nbsp;The singleton scope</h3></div></div><div></div></div><p>When a bean is a singleton, only one <span class="emphasis"><em>shared</em></span>
		    instance of the bean will be managed and all requests for beans with
		    an id or ids matching that bean definition will result in that one
		    specific bean instance being returned by the Spring container.</p><p>To put it another way, when you define a bean definition and it
		    is scoped as a singleton, then the Spring IoC container will create
		    <span class="emphasis"><em>exactly one</em></span> instance of the object defined by
		    that bean definition (or recipe). This single instance will be 
		    stored in a singleton cache, and <span class="emphasis"><em>all subsequent requests
		    and references</em></span> for that named bean will result in the cached
		    object instance being returned.</p><p>The following diagram illustrates the Spring singleton scope.</p><p>
			    </p><div class="mediaobject" align="center"><img src="images/singleton.png" align="middle"></div><p>
		    </p><p>Please be aware that Spring's concept of a singleton bean is quite
			different from the Singleton pattern as defined in the seminal Gang of
			Four (GoF) patterns book. The classic GoF Singleton hardcodes the scope of
			an object such that one <span class="emphasis"><em>and only one</em></span> instance of a
			particular class will ever be created<span class="emphasis"><em> per
			<tt class="classname">ClassLoader</tt></em></span>. The scope of the Spring singleton
			is best described as <span class="emphasis"><em>per <tt class="interfacename">container</tt>
			and per bean</em></span>. This means that if you define one bean for a particular
			class in a single Spring container, then the Spring container will create one
			<span class="emphasis"><em>and only one</em></span> instance of the class defined by that
			bean definition.</p><p><span class="emphasis"><em>The singleton scope is the default scope in Spring</em></span>.
		    To define a bean as a singleton in XML, you would write configuration like so:</p><pre class="programlisting">&lt;bean id="accountService" class="com.foo.DefaultAccountService"/&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;</span></i>
&lt;bean id="accountService" class="com.foo.DefaultAccountService" scope="singleton"/&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- the following is equivalent, though redundant (and preserved for backward compatibility) --&gt;</span></i>
&lt;bean id="accountService" class="com.foo.DefaultAccountService" singleton="true"/&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-scopes-prototype"></a>3.4.2.&nbsp;The prototype scope</h3></div></div><div></div></div><p>The non-singleton, prototype scope of bean deployment results in
			the <span class="emphasis"><em>creation of a new bean instance</em></span> every time a
			request for that specific bean is made (that is, it is injected into another
			bean or it is requested via a programmatic <tt class="literal">getBean()</tt>
			method call on the container). As a rule of thumb, you should
            use the prototype scope for all beans that are stateful, while the
            singleton scope should be used for stateless beans.</p><p>The following diagram illustrates the Spring prototype scope.
		    <span class="emphasis"><em>Please note that a DAO would not typically be configured as a
		    prototype, since a typical DAO would not hold any conversational state;
		    it was just easier for this author to reuse the core of the singleton
		    diagram.</em></span></p><p>
			    </p><div class="mediaobject" align="center"><img src="images/prototype.png" align="middle"></div><p>
		    </p><p>To define a bean as a prototype in XML, you would write configuration like so:</p><pre class="programlisting">&lt;bean id="accountService" class="com.foo.DefaultAccountService" scope="prototype"/&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- the following is equivalent too (and preserved for backward compatibility) --&gt;</span></i>
&lt;bean id="accountService" class="com.foo.DefaultAccountService" singleton="false"/&gt;</pre><p>There is one quite important thing to be aware of when deploying a bean
			in the prototype scope, in that the lifecycle of the bean changes slightly.
			Spring cannot (and hence does not) manage the complete lifecycle of a prototype
			bean: the container instantiates, configures, decorates and otherwise assembles a
			prototype object, hands it to the client and then has no further knowledge of that
			prototype instance. This means that while initialization lifecycle callback
			methods will be (and are) called on all objects regardless of scope, in the case
			of prototypes, any configured destruction lifecycle callbacks will <span class="emphasis"><em>not</em></span>
			be called. It is the responsibility of the client code to clean up
			prototype scoped objects and release any expensive resources that the prototype
			bean(s) are holding onto. (One possible way to get the Spring container
		    to release resources used by singleton-scoped beans is through the use
			of a bean post processor which would hold a reference to the beans that need to be cleaned
			up.)</p><p>In some respects, you can think of the Spring container's role when talking
			about a prototype-scoped bean as somewhat of a replacement for the Java
			<tt class="literal">'new'</tt> operator. Any lifecycle aspects past that point have to
			be handled by the client. The lifecycle of a bean in a Spring IoC container is
			further described in the section entitled
			<a href="beans.html#beans-factory-lifecycle" title="3.5.1.&nbsp;Lifecycle interfaces">Section&nbsp;3.5.1, &#8220;Lifecycle interfaces&#8221;</a>.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Backwards compatibility note: specifying the lifecycle scope in XML"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://static.springframework.org/spring/docs/2.0.x/images/admons/note.png"></td><th align="left">Backwards compatibility note: specifying the lifecycle scope in XML</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you are referencing the <tt class="filename">'spring-beans.dtd'</tt> DTD in
            a bean definition file(s), and you are being explicit about the lifecycle scope
            of your bean(s) you must use the "<tt class="literal">singleton</tt>" attribute to
            express the lifecycle scope (remembering that the
            <a href="#">singleton lifecycle scope</a> is
            the default). If you are referencing the <tt class="filename">'spring-beans-2.0.dtd'</tt>
            DTD or the Spring 2.0 XSD schema, then you will need to use the "<tt class="literal">scope</tt>"
            attribute (because the "<tt class="literal">singleton</tt>" attribute was removed from the
            definition of the new DTD and XSD files in favour of the "<tt class="literal">scope</tt>"
            attribute).</p><p>To be totally clear about this, this means that if you use the
            "<tt class="literal">singleton</tt>" attribute in an XML bean definition then you
            <span class="emphasis"><em>must</em></span> be referencing the <tt class="filename">'spring-beans.dtd'</tt>
            DTD <span class="emphasis"><em>in that file</em></span>. If you are using the "<tt class="literal">scope</tt>"
            attribute then you <span class="emphasis"><em>must</em></span> be referencing either the
            <tt class="filename">'spring-beans-2.0.dtd'</tt> DTD or the
            <tt class="filename">'spring-beans-2.0.xsd'</tt> XSD <span class="emphasis"><em>in that file</em></span>.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-scopes-other"></a>3.4.3.&nbsp;The other scopes</h3></div></div><div></div></div><p>The other scopes, namely <tt class="literal">request</tt>, <tt class="literal">session</tt>,
			and <tt class="literal">global session</tt> are for use only in web-based applications
			(and can be used irrespective of which particular web application framework you are
			using, if indeed any). In the interest of keeping related concepts together in
			one place in the reference documentation, these scopes are described here.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://static.springframework.org/spring/docs/2.0.x/images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The scopes that are described in the following paragraphs are
			    <span class="emphasis"><em>only</em></span> available if you are using a web-aware
			    Spring <tt class="interfacename">ApplicationContext</tt> implementation
			    (such as <tt class="classname">XmlWebApplicationContext</tt>).
			    If you try using these next scopes with regular Spring IoC containers such as
			    the <tt class="classname">XmlBeanFactory</tt> or
			    <tt class="classname">ClassPathXmlApplicationContext</tt>, you <span class="emphasis"><em>will</em></span>
			    get an <tt class="classname">IllegalStateException</tt> complaining about
			    an unknown bean scope.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-other-web-configuration"></a>3.4.3.1.&nbsp;Initial web configuration</h4></div></div><div></div></div><p>In order to effect the scoping of beans at the <tt class="literal">request</tt>,
                <tt class="literal">session</tt>, and <tt class="literal">global session</tt> level
                (i.e. web-scoped beans), some minor initial configuration is required
                before you can set about defining your bean definitions. Please note that
                this extra setup is <span class="emphasis"><em>not</em></span> required if you just want to use the
                'standard' scopes; i.e. singleton and prototype.</p><p>Now as things stand, there are a couple of ways to effect this
                initial setup depending on your particular servlet environment. If you are
                using a Servlet 2.4+ web container, then you need only add the following
                <tt class="interfacename">ContextListener</tt> to the XML declarations in
                your web applications <tt class="literal">'web.xml'</tt> file.</p><pre class="programlisting">&lt;web-app&gt;
  ...
  &lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;
  &lt;/listener&gt;
  ...
&lt;/web-app&gt;</pre><p>If you are using an older web container (before Servlet 2.4), you will need to use
                a (provided) <tt class="interfacename">javax.servlet.Filter</tt> implementation.
                Find below a snippet of XML configuration that has to be included
                in the <tt class="literal">'web.xml'</tt> file of your web application if you
                want to have access to web-scoped beans (the filter settings depend on
                the surrounding web application configuration and so you will have to change
                them as appropriate).</p><pre class="programlisting">&lt;web-app&gt;
  ..
  &lt;filter&gt; 
    &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt; 
    &lt;filter-class&gt;org.springframework.web.filter.RequestContextFilter&lt;/filter-class&gt;
  &lt;/filter&gt; 
  &lt;filter-mapping&gt; 
    &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt; 
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
  ...
&lt;/web-app&gt;</pre><p>That's it. The <tt class="classname">RequestContextListener</tt> and
                <tt class="classname">RequestContextFilter</tt> classes both do exactly the
                same thing, namely bind the HTTP request object to the
                <tt class="classname">Thread</tt> that is servicing that request. This makes
                beans that are request- and session-scoped available further down the
                call chain.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-request"></a>3.4.3.2.&nbsp;The request scope</h4></div></div><div></div></div><p>Consider the following bean definition:</p><pre class="programlisting">&lt;bean id="loginAction" class="com.foo.LoginAction" scope="request"/&gt;</pre><p>With the above bean definition in place, the Spring container will create
                a brand new instance of the <tt class="classname">LoginAction</tt> bean
                using the <tt class="literal">'loginAction'</tt> bean definition for each and
                every HTTP request. That is, the <tt class="literal">'loginAction'</tt> bean will be
                effectively scoped at the HTTP request level. You can change or dirty
                the internal state of the instance that is created as much as you want,
                safe in the knowledge that other requests that are also using instances created
                off the back of the same <tt class="literal">'loginAction'</tt> bean definition
                will not be seeing these changes in state since they are particular to an individual
                request. When the request is finished processing, the bean that is scoped
                to the request will be discarded.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-session"></a>3.4.3.3.&nbsp;The session scope</h4></div></div><div></div></div><p>Consider the following bean definition:</p><pre class="programlisting">&lt;bean id="userPreferences" class="com.foo.UserPreferences" scope="session"/&gt;</pre><p>With the above bean definition in place, the Spring container will create
                a brand new instance of the <tt class="classname">UserPreferences</tt> bean
                using the <tt class="literal">'userPreferences'</tt> bean definition for the
                lifetime of a single HTTP <tt class="interfacename">Session</tt>.
                In other words, the <tt class="literal">'userPreferences'</tt> bean will be
                effectively scoped at the HTTP <tt class="interfacename">Session</tt> level.
                Just like <tt class="literal">request-scoped</tt> beans, you can change the internal
                state of the instance that is created as much as you want, safe in the
                knowledge that other HTTP <tt class="interfacename">Session</tt> instances
                that are also using instances created off the back of the same
                <tt class="literal">'userPreferences'</tt> bean definition
                will not be seeing these changes in state since they are particular to an individual
                HTTP <tt class="interfacename">Session</tt>. When the HTTP
                <tt class="interfacename">Session</tt> is eventually discarded, the bean
                that is scoped to that particular HTTP <tt class="interfacename">Session</tt>
                will also be discarded.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-global-session"></a>3.4.3.4.&nbsp;The global session scope</h4></div></div><div></div></div><p>Consider the following bean definition:</p><pre class="programlisting">&lt;bean id="userPreferences" class="com.foo.UserPreferences" scope="globalSession"/&gt;</pre><p>The <tt class="literal">global session</tt> scope is similar to the
                standard HTTP <tt class="interfacename">Session</tt> scope
                (<a href="beans.html#beans-factory-scopes-session" title="3.4.3.3.&nbsp;The session scope">described immediately above</a>),
                and really only makes sense in the context of portlet-based web applications.
                The portlet specification defines the notion of a global
                <tt class="interfacename">Session</tt> that is shared amongst all
                of the various portlets that make up a single portlet web application.
                Beans defined at the <tt class="literal">global session</tt> scope are scoped
                (or bound) to the lifetime of the global portlet
                <tt class="interfacename">Session</tt>.</p><p>Please note that if you are writing a standard Servlet-based
                web application and you define one or more beans as having
                <tt class="literal">global session</tt> scope, the standard HTTP
                <tt class="interfacename">Session</tt> scope will be used, and no
                error will be raised.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-other-injection"></a>3.4.3.5.&nbsp;Scoped beans as dependencies</h4></div></div><div></div></div><p>Being able to define a bean scoped to a HTTP request or
			    <tt class="interfacename">Session</tt> (or indeed
			    <a href="beans.html#beans-factory-scopes-custom" title="3.4.4.&nbsp;Custom scopes">a custom scope</a>  of
			    your own devising) is all very well, but one of the
			    main value-adds of the Spring IoC container is that it manages
                not only the instantiation of your objects (beans), but also
			    the wiring up of collaborators (or dependencies). If you want to inject
			    a bean that, for the sake of argument is scoped at the HTTP request scope,
			    into another bean, you will need to inject an AOP proxy in place of the
			    scoped bean. That is to say, you need to inject a proxy object
			    that exposes the same public interface as the scoped object, but that is
			    smart enough to be able to retrieve the real, target object from
			    the relevant scope (for example a HTTP request) and delegate
			    method calls onto the real object.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://static.springframework.org/spring/docs/2.0.x/images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>You <span class="emphasis"><em>do not</em></span> need to use the
			        <tt class="literal">&lt;aop:scoped-proxy/&gt;</tt> in conjunction with
			        beans that are scoped as <tt class="literal">singletons</tt> or
			        <tt class="literal">prototypes</tt>. It is an error to try to create a
			        scoped proxy for a singleton bean (and the resulting
			        <tt class="classname">BeanCreationException</tt> will certainly set
			        you straight in this regard).</p></td></tr></table></div><p>Let's look at the configuration that is required to effect this;
                the configuration is not hugely complex (it takes just one line), but it
                is important to understand the &#8220;<span class="quote">why</span>&#8221; as well as the
                &#8220;<span class="quote">how</span>&#8221; behind it.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd"&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- a HTTP <tt class="interfacename">Session</tt>-scoped bean exposed as a proxy --&gt;</span></i>
    &lt;bean id="userPreferences" class="com.foo.UserPreferences" <span class="bold"><b>scope="session"</b></span>&gt;
          
          <i class="lineannotation"><span class="lineannotation">&lt;!-- this next element effects the proxying of the surrounding bean --&gt;</span></i>
          <span class="bold"><b>&lt;aop:scoped-proxy/&gt;</b></span>
    &lt;/bean&gt;
    
    <i class="lineannotation"><span class="lineannotation">&lt;!-- a singleton-scoped bean <span class="bold"><b>injected with a proxy to the above bean</b></span> --&gt;</span></i>
    &lt;bean id="userService" class="com.foo.SimpleUserService"&gt;
    
        <i class="lineannotation"><span class="lineannotation">&lt;!-- a reference to the <span class="bold"><b>proxied</b></span> <tt class="literal">'userPreferences'</tt> bean --&gt;</span></i>
        &lt;property name="userPreferences" ref="userPreferences"/&gt;

    &lt;/bean&gt;
&lt;/beans&gt;
</pre><p>To create a proxy to a scoped bean using XML-based configuration, you need
                only to insert a child <tt class="literal">&lt;aop:scoped-proxy/&gt;</tt> element into a
                scoped bean definition (you may also need the CGLIB library on your classpath
                so that the container can effect class-based proxying; you will also need to be
				using XSD based configuration). The above XML configuration
                demonstrated the &#8220;<span class="quote">how</span>&#8221;; now for the &#8220;<span class="quote">why</span>&#8221;. So, just why
                do you need this <tt class="literal">&lt;aop:scoped-proxy/&gt;</tt> element in the
                definition of beans scoped at the <tt class="literal">request</tt>,
                <tt class="literal">session</tt>, and <tt class="literal">globalSession</tt> level? The
                reason is best explained by picking apart the following bean definition 
								(please note that the following <tt class="literal">'userPreferences'</tt> bean 
								definition as it stands is <span class="emphasis"><em>incomplete</em></span>):</p><pre class="programlisting">&lt;bean id="userPreferences" class="com.foo.UserPreferences" scope="session"/&gt;

&lt;bean id="userManager" class="com.foo.UserManager"&gt;
    &lt;property name="userPreferences" ref="userPreferences"/&gt;
&lt;/bean&gt;</pre><p>From the above configuration it is evident that the singleton bean
                <tt class="literal">'userManager'</tt> is being injected with a reference to the HTTP
                <tt class="interfacename">Session</tt>-scoped bean <tt class="literal">'userPreferences'</tt>.
                The salient point here is that the <tt class="literal">'userManager'</tt> bean is a
                singleton... it will be instantiated <span class="emphasis"><em>exactly once</em></span> per container,
                and its dependencies (in this case only one, the <tt class="literal">'userPreferences'</tt>
                bean) will also only be injected once. This means that the
                <tt class="literal">'userManager'</tt> will (conceptually) only ever operate on the exact
                same <tt class="literal">'userPreferences'</tt> object, i.e. the one that it was originally
                injected with. This is not what you want when you inject a HTTP
                <tt class="interfacename">Session</tt>-scoped bean as a dependency into a
                collaborating object. What we do want is a single <tt class="literal">'userManager'</tt> object,
                and then, for the lifetime of a HTTP <tt class="interfacename">Session</tt>, we want to
                see and use a <tt class="literal">'userPreferences'</tt> object that is specific to said
                HTTP <tt class="interfacename">Session</tt>.</p><p>Rather what you need then is to inject some sort of object that exposes the
                exact same public interface as the <tt class="classname">UserPreferences</tt> class (ideally
                an object that <span class="emphasis"><em>is a</em></span> <tt class="classname">UserPreferences</tt> instance)
                and that is smart enough to be able to go off and fetch the
                <tt class="interfacename">real</tt> <tt class="classname">UserPreferences</tt> object from
                whatever underlying scoping mechanism we have chosen (HTTP request,
                <tt class="interfacename">Session</tt>, etc.). We can then safely inject this proxy
                object into the <tt class="literal">'userManager'</tt> bean, which will be blissfully unaware
                that the <tt class="classname">UserPreferences</tt> reference that it is holding onto is a
                proxy. In the case of this example, when a <tt class="interfacename">UserManager</tt>
                instance invokes a method on the dependency-injected <tt class="classname">UserPreferences</tt>
                object, it is really invoking a method on the proxy... the proxy will then go off and
                fetch the real <tt class="classname">UserPreferences</tt> object from (in this case) the HTTP
                <tt class="interfacename">Session</tt>, and delegate the method invocation onto the
                retrieved real <tt class="classname">UserPreferences</tt> object.</p><p>That is why you need the following, correct and complete, configuration
                when injecting <tt class="literal">request-</tt>, <tt class="literal">session-</tt>, and
                <tt class="literal">globalSession-scoped</tt> beans into collaborating objects:</p><pre class="programlisting">&lt;bean id="userPreferences" class="com.foo.UserPreferences" scope="session"&gt;
    <span class="bold"><b><tt class="literal">&lt;aop:scoped-proxy/&gt;</tt></b></span>
&lt;/bean&gt;

&lt;bean id="userManager" class="com.foo.UserManager"&gt;
    &lt;property name="userPreferences" ref="userPreferences"/&gt;
&lt;/bean&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-scopes-custom"></a>3.4.4.&nbsp;Custom scopes</h3></div></div><div></div></div><p>As of Spring 2.0, the bean scoping mechanism in Spring is extensible.
			This means that you are not limited to just the bean scopes that Spring
			provides out of the box; you can define your own scopes, or even redefine
			the existing scopes (although that last one would probably be considered
			bad practice - please note that you <span class="emphasis"><em>cannot</em></span> override the
			built-in <tt class="literal">singleton</tt> and <tt class="literal">prototype</tt> scopes).</p><p>Scopes are defined by the
			<tt class="interfacename">org.springframework.beans.factory.config.Scope</tt>
			interface. This is the interface that you will need to implement in order
			to integrate your own custom scope(s) into the Spring container. The interface
			itself is quite simple, with two methods to get and remove an object from
			an underlying storage mechanism respectively. Possible custom scopes are
			beyond the scope of this reference manual. You may wish to look at the
			<tt class="interfacename">Scope</tt> implementations that are supplied with
			Spring for an idea of how to go about implementing your own.</p><p>The remainder of this section details how, after you have written and
			tested one or more custom <tt class="interfacename">Scope</tt> implementations,
			you then go about making the Spring container aware of your new scope. The
			central method to register a new <tt class="interfacename">Scope</tt> with the
			Spring container is declared on the <tt class="interfacename">ConfigurableBeanFactory</tt>
			interface (implemented by most of the concrete <tt class="interfacename">BeanFactory</tt>
			implementations that ship with Spring); this central method is displayed below:</p><pre class="programlisting">void registerScope(String scopeName, Scope scope);</pre><p>The first argument to the <tt class="methodname">registerScope(..)</tt> method is the
			unique name associated with a scope; examples of such names in the Spring container
			itself are <tt class="literal">'singleton'</tt> and <tt class="literal">'prototype'</tt>.
			The second argument to the <tt class="methodname">registerScope(..)</tt> method is an
			actual instance of the custom <tt class="interfacename">Scope</tt> implementation
			that you wish to register and use.</p><p>Let's assume that you have written your own custom
			<tt class="interfacename">Scope</tt> implementation, and you have registered it
			like so:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// note: the <tt class="classname">ThreadScope</tt> class does <span class="bold"><b>not</b></span> exist; I made it up for the sake of this example</span></i>
Scope customScope = new ThreadScope();
beanFactory.registerScope("<span class="bold"><b>thread</b></span>", scope);</pre><p>You can then create bean definitions that adhere to the scoping rules of your
            custom <tt class="interfacename">Scope</tt> like so:</p><pre class="programlisting">&lt;bean id="..." class="..." <span class="bold"><b>scope="thread"</b></span>/&gt;</pre><p>If you have your own custom <tt class="interfacename">Scope</tt> implementation(s),
            you are not just limited to only programmatic registration of said custom scope(s).
            You can also do the <tt class="interfacename">Scope</tt> registration declaratively,
            using a custom <tt class="interfacename">BeanFactoryPostProcessor</tt>
            implementation, the <tt class="classname">CustomScopeConfigurer</tt> class. The
            <tt class="interfacename">BeanFactoryPostProcessor</tt> interface is one of the
            primary means of extending the Spring IoC container, and is described in a
            <a href="beans.html#beans-factory-extension-factory-postprocessors" title="3.7.2.&nbsp;Customizing configuration metadata with BeanFactoryPostProcessors">later section</a>
            of this very chapter.</p><p>The declarative registration of custom <tt class="interfacename">Scope</tt>
            implementations using the <tt class="classname">CustomScopeConfigurer</tt> class is
            shown below:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd"&gt;

    &lt;bean class="org.springframework.beans.factory.config.CustomScopeConfigurer"&gt;
        &lt;property name="scopes"&gt;
            &lt;map&gt;
                <span class="bold"><b>&lt;entry key="thread" value="com.foo.ThreadScope"/&gt;</b></span>
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="bar" class="x.y.Bar" <span class="bold"><b>scope="thread"</b></span>&gt;
        &lt;property name="name" value="Rick"/&gt;
        &lt;aop:scoped-proxy/&gt;
    &lt;/bean&gt;

    &lt;bean id="foo" class="x.y.Foo"&gt;
        &lt;property name="bar" ref="bar"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The <tt class="classname">CustomScopeConfigurer</tt> also allows you to specify
            actual <tt class="classname">Class</tt> instances as entry values, as well as
            actual <tt class="interfacename">Scope</tt> implementation instances; see the
            Javadocs for the <tt class="classname">CustomScopeConfigurer</tt> class for details.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-factory-nature"></a>3.5.&nbsp;Customizing the nature of a bean</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-lifecycle"></a>3.5.1.&nbsp;Lifecycle interfaces</h3></div></div><div></div></div><p>Spring provides several marker interfaces to change the behavior
            of your bean in the container; they include
            <tt class="interfacename">InitializingBean</tt> and
            <tt class="interfacename">DisposableBean</tt>. Implementing these interfaces will
            result in the container calling
            <tt class="methodname">afterPropertiesSet()</tt> for the former and
            <tt class="methodname">destroy()</tt> for the latter to allow the bean to perform
            certain actions upon initialization and destruction.</p><p>Internally, Spring uses <tt class="interfacename">BeanPostProcessor</tt> implementations to
            process any marker interfaces it can find and call the appropriate
            methods. If you need custom features or other lifecycle behavior Spring
            doesn't offer out-of-the-box, you can implement a
            <tt class="interfacename">BeanPostProcessor</tt> yourself. More information about
            this can be found in <a href="beans.html#beans-factory-extension" title="3.7.&nbsp;Container extension points">Section&nbsp;3.7, &#8220;Container extension points&#8221;</a>.</p><p>All the different lifecycle marker interfaces are described below.
            In one of the appendices, you can find diagram that show how Spring
            manages beans and how those lifecycle features change the nature of your
            beans and how they are managed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-lifecycle-initializingbean"></a>3.5.1.1.&nbsp;Initialization callbacks</h4></div></div><div></div></div><p>Implementing the
                <tt class="literal">org.springframework.beans.factory.InitializingBean</tt>
                allows a bean to perform initialization work after all necessary
                properties on the bean are set by the container. The
                <tt class="interfacename">InitializingBean</tt> interface specifies exactly one
                method:</p><pre class="programlisting">void afterPropertiesSet() throws Exception;</pre><p>Generally, the use of the <tt class="interfacename">InitializingBean</tt>
                interface can be avoided (and is discouraged since it unnecessarily couples
                the code to Spring). A bean definition provides support for a generic
                initialization method to be specified. In the case of XML-based configuration
                metadata, this is done using the <tt class="literal">'init-method'</tt> attribute.
                For example, the following definition:</p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/&gt;</pre><pre class="programlisting">public class ExampleBean {
    
    public void init() {
        <i class="lineannotation"><span class="lineannotation">// do some initialization work</span></i>
    }
}</pre><p>Is exactly the same as...</p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;</pre><pre class="programlisting">public class AnotherExampleBean implements InitializingBean {
    
    public void afterPropertiesSet() {
        <i class="lineannotation"><span class="lineannotation">// do some initialization work</span></i>
    }
}</pre><p>... but does not couple the code to Spring.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-lifecycle-disposablebean"></a>3.5.1.2.&nbsp;Destruction callbacks</h4></div></div><div></div></div><p>Implementing the
                <tt class="interfacename">org.springframework.beans.factory.DisposableBean</tt>
                interface allows a bean to get a callback when the container
                containing it is destroyed. The <tt class="interfacename">DisposableBean</tt> interface specifies one
                method:</p><pre class="programlisting">void destroy() throws Exception;</pre><p>Generally, the use of the
                <tt class="interfacename">DisposableBean</tt> marker interface can be avoided (and
                is discouraged since it unnecessarily couples the code to Spring). A
                bean definition provides support for a generic destroy method to be
                specified. When using XML-based configuration metadata this is done via the
                <tt class="literal">'destroy-method'</tt> attribute on the <tt class="literal">&lt;bean/&gt;</tt>.
                For example, the following definition: </p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/&gt;</pre><pre class="programlisting">public class ExampleBean {

    public void cleanup() {
        <i class="lineannotation"><span class="lineannotation">// do some destruction work (like releasing pooled connections)</span></i>
    }
}</pre><p>Is exactly the same as...</p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;</pre><pre class="programlisting">public class AnotherExampleBean implements DisposableBean {

    public void destroy() {
        <i class="lineannotation"><span class="lineannotation">// do some destruction work (like releasing pooled connections)</span></i>
    }
}</pre><p>... but does not couple the code to Spring.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-factory-lifecycle-default-init-destroy-methods"></a>3.5.1.2.1.&nbsp;Default initialization &amp; destroy methods</h5></div></div><div></div></div><p>
                        When you are writing initialization and destroy method callbacks that do not
                        use the Spring-specific <tt class="interfacename">InitializingBean</tt>
                        and <tt class="interfacename">DisposableBean</tt> callback interfaces,
                        one (in the experience of this author) typically finds oneself writing
                        methods with names such as <tt class="literal">init()</tt>,
                        <tt class="literal">initialize()</tt>, <tt class="literal">dispose()</tt>, etc. The
                        names of such lifecycle callback methods are (hopefully!) standardized
                        across a project so that developers on a team all use the same method
                        names and thus ensure some level of consistency.
                    </p><p>
                        The Spring container can now be configured to <tt class="literal">'look'</tt>
                        for named initialization and destroy callback method names on
                        <span class="emphasis"><em>every</em></span> bean. This means that you as an application developer
                        can simply write your application classes, use a convention of having an
                        initialization callback called <tt class="literal">init()</tt>, and then
                        (without having to configure each and every bean with, in the case of XML-based
                        configuration, an <tt class="literal">'init-method="init"'</tt> attribute)
                        be safe in the knowledge that the Spring IoC container <span class="emphasis"><em>will</em></span>
                        call that method when the bean is being created (and in accordance with the
                        standard lifecycle callback contract described previously).
                    </p><p>
                        Let's look at an example to make the use of this feature completely clear.
                        For the sake of the example, let us say that one of the coding conventions on a
                        project is that all initialization callback methods are to be named
                        <tt class="literal">init()</tt> and that destroy callback methods are to be called
                        <tt class="literal">destroy()</tt>. This leads to classes like so...
                    </p><pre class="programlisting">public class DefaultBlogService implements BlogService {

    private BlogDao blogDao;

    public void setBlogDao(BlogDao blogDao) {
        this.blogDao = blogDao;
    }

    <i class="lineannotation"><span class="lineannotation">// this is (unsurprisingly) the initialization callback method</span></i>
    public void init() {
        if (this.blogDao == null) {
            throw new IllegalStateException("The [blogDao] property must be set.");
        }
    }
}</pre><p>
                The attendant XML configuration for the above class, and making use of the
                by-convention initialization callback method configuration, would look like
                so:
            </p><pre class="programlisting">&lt;beans <span class="bold"><b>default-init-method="init"</b></span>&gt;

    &lt;bean id="blogService" class="com.foo.DefaultBlogService"&gt;
        &lt;property name="blogDao" ref="blogDao" /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>
                        Notice the use of the <tt class="literal">'default-init-method'</tt> attribute on the
                        top-level <tt class="literal">&lt;beans/&gt;</tt> element. The presence of this
                        attribute means that the Spring IoC container will recognize a method called
                        <tt class="literal">'init'</tt> on beans as being the initialization method callback,
                        and when a bean is being created and assembled, if the bean's class has such
                        a method, it will be invoked at the appropriate time.
                    </p><p>
                        Destroy method callbacks are configured similarly (in XML that is) using the
                        <tt class="literal">'default-destroy-method'</tt> attribute on the top-level
                        <tt class="literal">&lt;beans/&gt;</tt> element.
                    </p><p>
                        The use of this feature can save you the (small) housekeeping chore of specifying
                        an initialization and destroy method callback on each and every bean, and it is
                        great for enforcing a consistent naming convention for initialization and destroy
                        method callbacks (and consistency is something that should always be aimed for).
                    </p><p>
                        One final word... let's say you want to use this feature, but you have some
                        existing beans where the underlying classes already have for example initialization
                        callback methods that are named at variance with the convention. You can
                        <span class="emphasis"><em>always</em></span> override the default by specifying (in XML that is)
                        the method name using the <tt class="literal">'init-method'</tt> and
                        <tt class="literal">'destroy-method'</tt> attributes on the <tt class="literal">&lt;bean/&gt;</tt>
                        element itself.
                    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e4121"></a>3.5.1.2.2.&nbsp;Shutting down the Spring IoC container gracefully in non-web applications</h5></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://static.springframework.org/spring/docs/2.0.x/images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>This next section does not apply to web applications (in case the title of this section
                        did not make that abundantly clear). Spring's web-based <tt class="interfacename">ApplicationContext</tt>
                        implementations already have code in place to handle shutting down the Spring
                        IoC container gracefully when the relevant web application is being shutdown.</p></td></tr></table></div><p>If you are using Spring's IoC container in a non-web application environment, for
                    example in a rich client desktop environment, and you want the container to shutdown
                    gracefully and call the relevant destroy callbacks on your singleton beans, you will
                    need to register a shutdown hook with the JVM. This is quite easy to do (see below),
                    and will ensure that your Spring IoC container shuts down gracefully and that all
                    resources held by your singletons are released (of course it is still up to you to both
                    configure the destroy callbacks for your singletons and implement such
                    destroy callbacks correctly).</p><p>So to register a shutdown hook that enables the graceful shutdown of the relevant
                    Spring IoC container, you simply need to call the
                    <tt class="methodname">registerShutdownHook()</tt> method that is declared on the
                    <tt class="classname">AbstractApplicationContext</tt> class. To wit...</p><pre class="programlisting">import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        AbstractApplicationContext ctx
            = new ClassPathXmlApplicationContext(new String []{"beans.xml"});

        <i class="lineannotation"><span class="lineannotation">// add a shutdown hook for the above context... </span></i>
        ctx.registerShutdownHook();

        <i class="lineannotation"><span class="lineannotation">// app runs here...</span></i>

        <i class="lineannotation"><span class="lineannotation">// main method exits, hook is called prior to the app shutting down...</span></i>
    }
}</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-aware"></a>3.5.2.&nbsp;Knowing who you are</h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-aware-beanfactoryaware"></a>3.5.2.1.&nbsp;
                    <tt class="interfacename">BeanFactoryAware</tt>
                </h4></div></div><div></div></div><p>A class which implements the
        <tt class="interfacename">org.springframework.beans.factory.BeanFactoryAware</tt>
        interface is provided with a reference to the <tt class="interfacename">BeanFactory</tt> that created
        it, when it is created by that <tt class="interfacename">BeanFactory</tt>.
        </p><pre class="programlisting">public interface BeanFactoryAware {

    void setBeanFactory(BeanFactory beanFactory) throws BeansException;
}</pre><p>
            This allows beans to manipulate the <tt class="interfacename">BeanFactory</tt>
            that created them programmatically, through the <tt class="interfacename">BeanFactory</tt>
            interface, or by casting the reference to a known subclass of this
            which exposes additional functionality. Primarily this would consist
            of programmatic retrieval of other beans. While there are cases when
            this capability is useful, it should generally be avoided, since it
            couples the code to Spring, and does not follow the Inversion of
            Control style, where collaborators are provided to beans as properties.
        </p><p>An alternative option that is equivalent in effect to the
                <tt class="interfacename">BeanFactoryAware</tt>-based approach is to use the
                <tt class="classname">org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean</tt>.
                (It should be noted that this approach still does not reduce the coupling to Spring,
                but it does not violate the central principal of IoC as much as the
                <tt class="interfacename">BeanFactoryAware</tt>-based approach.)</p><p>The <tt class="classname">ObjectFactoryCreatingFactoryBean</tt> is a
                <a href="beans.html#beans-factory-extension-factorybean" title="3.7.3.&nbsp;Customizing instantiation logic using FactoryBeans"><tt class="interfacename">FactoryBean</tt></a>
                implementation that returns a reference to an object (factory) that can in turn be used to
                effect a bean lookup. The <tt class="classname">ObjectFactoryCreatingFactoryBean</tt> class
                does itself implement the <tt class="interfacename">BeanFactoryAware</tt> interface;
                what client beans are actually injected with is an instance of the
                <tt class="interfacename">ObjectFactory</tt> interface. This is a Spring-specific
                interface (and hence there is still no total decoupling from Spring), but clients
                can then use the <tt class="interfacename">ObjectFactory</tt>'s
                <tt class="methodname">getObject()</tt> method to effect the bean lookup (under the hood the
                <tt class="interfacename">ObjectFactory</tt> implementation instance that is returned
                simply delegates down to a <tt class="interfacename">BeanFactory</tt> to actually
                lookup a bean by name). All that you need to do is supply
                the <tt class="classname">ObjectFactoryCreatingFactoryBean</tt> with the name of the
                bean that is to be looked up. Let's look at an example:</p><pre class="programlisting">package x.y;

public class NewsFeed {
    
    private String news;

    public void setNews(String news) {
        this.news = news;
    }

    public String getNews() {
        return this.toString() + ": '" + news + "'";
    }
}</pre><pre class="programlisting">package x.y;

import org.springframework.beans.factory.ObjectFactory;

public class NewsFeedManager {

    private ObjectFactory factory;

    public void setFactory(ObjectFactory factory) {
        this.factory = factory;
    }

    public void printNews() {
        // here is where the lookup is performed; note that there is no
        // need to hardcode the name of the bean that is being looked up...
        NewsFeed news = (NewsFeed) factory.getObject();
        System.out.println(news.getNews());
    }
}</pre><p>
            Find below the XML configuration to wire together the above classes
            using the <tt class="classname">ObjectFactoryCreatingFactoryBean</tt> approach.
        </p><pre class="programlisting">&lt;beans&gt;
    &lt;bean id="newsFeedManager" class="x.y.NewsFeedManager"&gt;
        &lt;property name="factory"&gt;
            &lt;bean
class="org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean"&gt;
                &lt;property name="targetBeanName"&gt;
                    &lt;idref local="newsFeed" /&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id="newsFeed" class="x.y.NewsFeed" scope="prototype"&gt;
        &lt;property name="news" value="... that's fit to print!" /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>
            And here is a small driver program to test the fact that new (prototype)
            instances of the <tt class="literal">newsFeed</tt> bean are actually being returned for
            each call to the injected <tt class="interfacename">ObjectFactory</tt> inside the
            <tt class="classname">NewsFeedManager</tt>'s <tt class="methodname">printNews()</tt> method.
        </p><pre class="programlisting">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import x.y.NewsFeedManager;

public class Main {

    public static void main(String[] args) throws Exception {

        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
        NewsFeedManager manager = (NewsFeedManager) ctx.getBean("newsFeedManager");
        manager.printNews();
        manager.printNews();
    }
}</pre><p>
            The output from running the above program will look like so (results will of course vary
            on your machine).
        </p><pre class="programlisting">x.y.NewsFeed@1292d26: '... that's fit to print!'
x.y.NewsFeed@5329c5: '... that's fit to print!'</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-aware-beannameaware"></a>3.5.2.2.&nbsp;<tt class="interfacename">BeanNameAware</tt></h4></div></div><div></div></div><p>If a bean implements the
                <tt class="interfacename">org.springframework.beans.factory.BeanNameAware</tt>
                interface and is deployed in a <tt class="interfacename">BeanFactory</tt>, the
                <tt class="interfacename">BeanFactory</tt> will call the bean through this
                interface to inform the bean of the <span class="emphasis"><em>id</em></span> it was deployed
                under. The callback will be invoked after population of normal bean properties
                but before an initialization callback like <tt class="interfacename">InitializingBean</tt>'s
                <span class="emphasis"><em>afterPropertiesSet</em></span> or a custom init-method.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-child-bean-definitions"></a>3.6.&nbsp;Bean definition inheritance</h2></div></div><div></div></div><p>A bean definition potentially contains a large amount of
        configuration information, including container specific information (i.e.
        initialization method, static factory method name, etc.) and constructor
        arguments and property values. A child bean definition is a bean
        definition which inherits configuration data from a parent definition. It
        is then able to override some values, or add others, as needed. Using
        parent and child bean definitions can potentially save a lot of typing.
        Effectively, this is a form of templating.</p><p>When working with a <tt class="interfacename">BeanFactory</tt> programmatically, child bean
        definitions are represented by the <tt class="classname">ChildBeanDefinition</tt>
        class. Most users will never work with them on this level, instead
        configuring bean definitions declaratively in something like the
        <tt class="classname">XmlBeanFactory</tt>. When using XML-based configuration metadata a child bean
        definition is indicated simply by using the <tt class="literal">'parent'</tt>
        attribute, specifying the parent bean as the value of this attribute.</p><pre class="programlisting">&lt;bean id="inheritedTestBean" abstract="true"
    class="org.springframework.beans.TestBean"&gt;
  &lt;property name="name" value="parent"/&gt;
  &lt;property name="age" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithDifferentClass"
      class="org.springframework.beans.DerivedTestBean"
      <span class="bold"><b>parent="inheritedTestBean"</b></span> init-method="initialize"&gt;
    
  &lt;property name="name" value="override"/&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- the age property value of 1 will be inherited from  parent --&gt;</span></i>

&lt;/bean&gt;</pre><p>A child bean definition will use the bean class from the parent
        definition if none is specified, but can also override it. In the latter
        case, the child bean class must be compatible with the parent, i.e. it
        must accept the parent's property values.</p><p>A child bean definition will inherit constructor argument values,
        property values and method overrides from the parent, with the option to
        add new values. If any init-method, destroy-method and/or <tt class="literal">static</tt>
        factory method settings are specified, they will override the corresponding parent
        settings.</p><p>The remaining settings will <span class="emphasis"><em>always</em></span> be taken
        from the child definition: <span class="emphasis"><em>depends on</em></span>,
        <span class="emphasis"><em>autowire mode</em></span>, <span class="emphasis"><em>dependency check</em></span>,
        <span class="emphasis"><em>singleton</em></span>, <span class="emphasis"><em>scope</em></span>,
		<span class="emphasis"><em>lazy init</em></span>.</p><p>Note that in the example above, we have explicitly marked the parent
        bean definition as abstract by using the <tt class="literal">abstract</tt>
        attribute. In the case that the parent definition does not specify a
        class, and so explicitly marking the parent bean definition as
        <tt class="literal">abstract</tt> is required:</p><pre class="programlisting">&lt;bean id="inheritedTestBeanWithoutClass" abstract="true"&gt;
    &lt;property name="name" value="parent"/&gt;
    &lt;property name="age" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
    parent="inheritedTestBeanWithoutClass" init-method="initialize"&gt;
  &lt;property name="name" value="override"/&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- age will inherit the value of <tt class="literal">1</tt> from the parent bean definition--&gt;</span></i>
&lt;/bean&gt;</pre><p>The parent bean cannot get instantiated on its own since it is
        incomplete, and it is also explicitly marked as <tt class="literal">abstract</tt>.
        When a definition is defined to be <tt class="literal">abstract</tt> like this,
        it is usable only as a pure template bean definition that will serve as a
        parent definition for child definitions. Trying to use such an
        <tt class="literal">abstract</tt> parent bean on its own (by referring to it as
        a ref property of another bean, or doing an explicit
        <tt class="methodname">getBean()</tt> call with the parent bean id), will
        result in an error. Similarly, the container's internal
        <tt class="methodname">preInstantiateSingletons()</tt> method will completely
        ignore bean definitions which are defined as abstract.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://static.springframework.org/spring/docs/2.0.x/images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p><tt class="literal">ApplicationContexts</tt> (but <span class="emphasis"><em>not</em></span>
            <tt class="literal">BeanFactories</tt>) will by default pre-instantiate
            all singletons. Therefore it is important (at least for singleton beans)
            that if you have a (parent) bean definition which you intend to use only
            as a template, and this definition specifies a class, you must make sure
            to set the <span class="emphasis"><em>'abstract'</em></span> attribute to <span class="emphasis"><em>'true'</em></span>,
            otherwise the application context will actually (attempt to) pre-instantiate
            the <tt class="literal">abstract</tt> bean.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-factory-extension"></a>3.7.&nbsp;Container extension points</h2></div></div><div></div></div><p>The IoC component of the Spring Framework has been designed for extension.
        There is typically no need for an application developer to subclass any of the various
        <tt class="interfacename">BeanFactory</tt> or <tt class="interfacename">ApplicationContext</tt>
        implementation classes. The Spring IoC container can be infinitely extended by
        plugging in implementations of special integration interfaces. The next few sections are
        devoted to detailing all of these various integration interfaces.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-extension-bpp"></a>3.7.1.&nbsp;Customizing beans using <tt class="literal">BeanPostProcessors</tt></h3></div></div><div></div></div><p>The first extension point that we will look at is the
            <tt class="interfacename">BeanPostProcessor</tt> interface. This interface defines
            a number of <i class="firstterm">callback methods</i> that you as an application
            developer can implement in order to provide your own (or override the containers default)
            instantiation logic, dependency-resolution logic, and so forth. If you want to do
            some custom logic after the Spring container has finished instantiating, configuring
            and otherwise initializing a bean, you can plug in one or more
            <tt class="interfacename">BeanPostProcessor</tt> implementations.</p><p>You can configure multiple <tt class="literal">BeanPostProcessors</tt> if you wish.
            You can control the order in which these <tt class="literal">BeanPostProcessors</tt>
            execute by setting the <tt class="literal">'order'</tt> property (you can only set this property 
            if the <tt class="interfacename">BeanPostProcessor</tt>
            implements the <tt class="interfacename">Ordered</tt> interface; if you write your own
            <tt class="interfacename">BeanPostProcessor</tt> you should consider implementing the
            <tt class="interfacename">Ordered</tt> interface too); consult the Javadocs for the
            <tt class="interfacename">BeanPostProcessor</tt> and <tt class="interfacename">Ordered</tt>
            interfaces for more details.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://static.springframework.org/spring/docs/2.0.x/images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p><tt class="literal">BeanPostProcessors</tt> operate on bean (or object)
                <span class="emphasis"><em>instances</em></span>; that is to say, the Spring IoC container will
                have instantiated a bean instance for you, and <span class="emphasis"><em>then</em></span>
                <tt class="literal">BeanPostProcessors</tt> get a chance to do their stuff.</p><p>If you want to change the actual bean definition (i.e. the recipe that
                defines the bean), then you rather need to use a
                <tt class="interfacename">BeanFactoryPostProcessor</tt> (described below in the
                section entitled <a href="beans.html#beans-factory-extension-factory-postprocessors" title="3.7.2.&nbsp;Customizing configuration metadata with BeanFactoryPostProcessors">Section&nbsp;3.7.2, &#8220;Customizing configuration metadata with BeanFactoryPostProcessors&#8221;</a>.</p><p>Also, <tt class="literal">BeanPostProcessors</tt> are scoped <span class="emphasis"><em>per-container</em></span>.
                This is only relevant if you are using container hierarchies. If you define a
                <tt class="interfacename">BeanPostProcessor</tt> in one container, it will
                <span class="emphasis"><em>only</em></span> do its stuff on the beans in that container. Beans that
                are defined in another container will not be post-processed by
                <tt class="literal">BeanPostProcessors</tt> in another container, even if both containers
                are part of the same hierarchy.</p></td></tr></table></div><p>The <tt class="interfacename">org.springframework.beans.factory.config.BeanPostProcessor</tt>
            interface consists of exactly two callback methods. When such a class is
            registered as a post-processor with the container (see below for how this registration
            is effected), for each bean instance that is created by the container, the post-processor
            will get a callback from the container both <span class="emphasis"><em>before</em></span> any container
            initialization methods (such as <span class="emphasis"><em>afterPropertiesSet</em></span> and any declared
            init method) are called, and also afterwards. The post-processor is free to do what it
            wishes with the bean instance, including ignoring the callback completely. A bean
            post-processor will typically check for marker interfaces, or do something such as wrap
            a bean with a proxy; some of the Spring AOP infrastructure classes are implemented as bean
            post-processors and they do this proxy-wrapping logic.</p><p>It is important to know that a <tt class="interfacename">BeanFactory</tt> treats bean
            post-processors slightly differently than an <tt class="interfacename">ApplicationContext</tt>.
            An <tt class="interfacename">ApplicationContext</tt> will <span class="emphasis"><em>automatically detect</em></span>
            any beans which are defined in the configuration metadata which is supplied to it that
            implement the <tt class="interfacename">BeanPostProcessor</tt> interface, and register them
            as post-processors, to be then called appropriately by the container on bean creation. Nothing
            else needs to be done other than deploying the post-processor in a similar fashion to any
            other bean. On the other hand, when using a <tt class="interfacename">BeanFactory</tt>
            implementation, bean post-processors explicitly have to be registered, with code like this:</p><pre class="programlisting">ConfigurableBeanFactory factory = new XmlBeanFactory(...);
            
    <i class="lineannotation"><span class="lineannotation">// now register any needed <tt class="interfacename">BeanPostProcessor</tt> instances</span></i>
    MyBeanPostProcessor postProcessor = new MyBeanPostProcessor();
    factory.addBeanPostProcessor(postProcessor);

    <i class="lineannotation"><span class="lineannotation">// now start using the factory</span></i></pre><p>This explicit registration step is not convenient, and this is one of the
            reasons why the various <tt class="interfacename">ApplicationContext</tt>
            implementations are preferred above plain <tt class="interfacename">BeanFactory</tt>
            implementations in the vast majority of Spring-backed applications, especially
            when using <tt class="literal">BeanPostProcessors</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://static.springframework.org/spring/docs/2.0.x/images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>You typically don't want to have <tt class="literal">BeanPostProcessors</tt>
                marked as being lazily-initialized. If they are marked as such, then the Spring
                container will never instantiate them, and thus they won't get a chance
                to apply their custom logic. If you are using the
                <tt class="literal">'default-lazy-init'</tt> attribute on the declaration of your
                <tt class="literal">&lt;beans/&gt;</tt> element, be sure to mark your various
                <tt class="interfacename">BeanPostProcessor</tt> bean definitions with
                <tt class="literal">'lazy-init="false"'</tt>.
                </p></td></tr></table></div><p>Find below some examples of how to write, register, and use
            <tt class="literal">BeanPostProcessors</tt> in the context of an
            <tt class="interfacename">ApplicationContext</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-extension-bpp-examples-hw"></a>3.7.1.1.&nbsp;Example: Hello World, <tt class="interfacename">BeanPostProcessor</tt>-style</h4></div></div><div></div></div><p>This first example is hardly compelling, but serves to illustrate basic
                usage. All we are going to do is code a custom <tt class="interfacename">BeanPostProcessor</tt>
                implementation that simply invokes the <tt class="methodname">toString()</tt>
                method of each bean as it is created by the container and prints the resulting
                string to the system console. Yes, it is not hugely useful, but serves to get
                the basic concepts across before we move into the second example which
                <span class="emphasis"><em>is</em></span> actually useful.</p><p>Find below the custom <tt class="interfacename">BeanPostProcessor</tt>
                implementation class definition:</p><pre class="programlisting">package scripting;

import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.beans.BeansException;

public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {

    <i class="lineannotation"><span class="lineannotation">// simply return the instantiated bean as-is</span></i>
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        return bean; <i class="lineannotation"><span class="lineannotation">// we could potentially return <span class="emphasis"><em>any</em></span> object reference here...</span></i>
    }

    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("Bean '" + beanName + "' created : " + bean.toString());
        return bean;
    }
}</pre><p>Here is the attendant XML-based configuration:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:lang="http://www.springframework.org/schema/lang"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang-2.0.xsd"&gt;

    &lt;lang:groovy id="messenger"
          script-source="classpath:org/springframework/scripting/groovy/Messenger.groovy"&gt;
        &lt;lang:property name="message" value="Fiona Apple Is Just So Dreamy."/&gt; 
    &lt;/lang:groovy&gt;
    
    <i class="lineannotation"><span class="lineannotation">&lt;!-- 
        when the above bean ('messenger') is instantiated, this custom
        <tt class="interfacename">BeanPostProcessor</tt> implementation will output the fact to the system console
     --&gt;</span></i>
    &lt;bean class="scripting.InstantiationTracingBeanPostProcessor"/&gt;

&lt;/beans&gt;</pre><p>Notice how the <tt class="classname">InstantiationTracingBeanPostProcessor</tt> is
                simply defined; it doesn't even have a name, and because it is a bean it can be
                dependency injected just like any other bean. (The above configuration also just so
                happens to define a bean that is backed by a Groovy script. The Spring 2.0 dynamic
                language support is detailed in the chapter entitled
                <a href="dynamic-language.html" title="Chapter&nbsp;24.&nbsp;Dynamic language support">Chapter&nbsp;24, <i>Dynamic language support</i></a>.)</p><p>Find below a small driver script to exercise the above code and
                configuration;</p><pre class="programlisting">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.scripting.Messenger;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("scripting/beans.xml");
        Messenger messenger = (Messenger) ctx.getBean("messenger");
        System.out.println(messenger);
    }
}</pre><p>The output of executing the above program will be (something like) this:</p><pre class="programlisting">Bean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961
org.springframework.scripting.groovy.GroovyMessenger@272961</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-extension-bpp-examples-rabpp"></a>3.7.1.2.&nbsp;Example: The <tt class="classname">RequiredAnnotationBeanPostProcessor</tt></h4></div></div><div></div></div><p>Using marker interfaces or annotations in conjunction with a custom
                <tt class="interfacename">BeanPostProcessor</tt> implementation is a common
                means of extending the Spring IoC container. This next example is a bit of
                a cop-out, in that you are directed to the section entitled
                <a href="metadata.html#metadata-annotations-required" title="25.3.1.&nbsp;@Required">Section&nbsp;25.3.1, &#8220;@Required&#8221;</a> which demonstrates the usage of a
                custom <tt class="interfacename">BeanPostProcessor</tt> implementation that
                ships with the Spring distribution which ensures that JavaBean properties on
                beans that are marked with an (arbitrary) annotation are actually (configured to
                be) dependency-injected with a value.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-extension-factory-postprocessors"></a>3.7.2.&nbsp;Customizing configuration metadata with <tt class="literal">BeanFactoryPostProcessors</tt></h3></div></div><div></div></div><p>The next extension point that we will look at is the
            <tt class="interfacename">org.springframework.beans.factory.config.BeanFactoryPostProcessor</tt>.
            The semantics of this interface are similar to the <tt class="interfacename">BeanPostProcessor</tt>,
            with one major difference. <tt class="literal">BeanFactoryPostProcessors</tt> operate on
            bean definitions (i.e. the configuration metadata that is supplied to a container); that is to say,
            the Spring IoC container will allow <tt class="literal">BeanFactoryPostProcessors</tt> to read the
            configuration metadata and potentially change it <span class="emphasis"><em>before</em></span> the
            container has actually instantied any other beans.</p><p>You can configure multiple <tt class="literal">BeanFactoryPostProcessors</tt> if you wish.
            You can control the order in which these <tt class="literal">BeanFactoryPostProcessors</tt>
            execute by setting the <tt class="literal">'order'</tt> property (you can only set this property 
            if the <tt class="interfacename">BeanFactoryPostProcessor</tt>
            implements the <tt class="interfacename">Ordered</tt> interface; if you write your own
            <tt class="interfacename">BeanFactoryPostProcessor</tt> you should consider
            implementing the <tt class="interfacename">Ordered</tt> interface too); consult
            the Javadocs for the <tt class="interfacename">BeanFactoryPostProcessor</tt>
            and <tt class="interfacename">Ordered</tt> interfaces for more details.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://static.springframework.org/spring/docs/2.0.x/images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you want to change the actual bean <span class="emphasis"><em>instances</em></span>
                (i.e. the objects that are created from the configuration metadata), then
                you rather need to use a <tt class="interfacename">BeanPostProcessor</tt>
                (described above in the section entitled
                <a href="beans.html#beans-factory-extension-bpp" title="3.7.1.&nbsp;Customizing beans using BeanPostProcessors">Section&nbsp;3.7.1, &#8220;Customizing beans using BeanPostProcessors&#8221;</a>.</p><p>Also, <tt class="literal">BeanFactoryPostProcessors</tt> are scoped
                <span class="emphasis"><em>per-container</em></span>. This is only relevant if you are
                using container hierarchies. If you define a
                <tt class="interfacename">BeanFactoryPostProcessor</tt> in one container,
                it will <span class="emphasis"><em>only</em></span> do its stuff on the bean definitions in
                that container. Bean definitions in another container will not be
                post-processed by <tt class="literal">BeanFactoryPostProcessors</tt> in another
                container, even if both containers are part of the same hierarchy.</p></td></tr></table></div><p>A bean factory post-processor is executed manually (in the case of a
            <tt class="interfacename">BeanFactory</tt>) or automatically (in the case of a
            <tt class="interfacename">ApplicationContext</tt>) to apply changes of
            some sort to the configuration metadata that defines a container. Spring
            includes a number of pre-existing bean factory post-processors, such as
            <tt class="classname">PropertyResourceConfigurer</tt> and
            <tt class="classname">PropertyPlaceholderConfigurer</tt>, both described below,
            and <tt class="classname">BeanNameAutoProxyCreator</tt>, which is very useful for wrapping
            other beans transactionally or with any other kind of proxy, as described
            later in this manual. The <tt class="interfacename">BeanFactoryPostProcessor</tt>
            can be used to add custom property editors.</p><p>In a <tt class="interfacename">BeanFactory</tt>, the process of applying a
            <tt class="interfacename">BeanFactoryPostProcessor</tt> is manual, and will be
            similar to this:</p><pre class="programlisting">XmlBeanFactory factory = new XmlBeanFactory(new FileSystemResource("beans.xml"));

<i class="lineannotation"><span class="lineannotation">// bring in some property values from a <tt class="classname">Properties</tt> file</span></i>
PropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));

<i class="lineannotation"><span class="lineannotation">// now actually do the replacement</span></i>
cfg.postProcessBeanFactory(factory);</pre><p>This explicit registration step is not convenient, and this is one of the
            reasons why the various <tt class="interfacename">ApplicationContext</tt>
            implementations are preferred above plain <tt class="interfacename">BeanFactory</tt>
            implementations in the vast majority of Spring-backed applications, especially
            when using <tt class="literal">BeanFactoryPostProcessors</tt>.</p><a name="beans-factory-autodetect-beanfactorypostprocessors"></a><p>An <tt class="interfacename">ApplicationContext</tt> will detect any beans which
            are deployed into it which implement the <tt class="interfacename">BeanFactoryPostProcessor</tt>
            interface, and automatically use them as bean factory post-processors, at the appropriate
            time. Nothing else needs to be done other than deploying these post-processor in a similar
            fashion to any other bean.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://static.springframework.org/spring/docs/2.0.x/images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Just as in the case of <tt class="literal">BeanPostProcessors</tt>, you typically
                don't want to have <tt class="literal">BeanFactoryPostProcessors</tt>
                marked as being lazily-initialized. If they are marked as such, then the Spring
                container will never instantiate them, and thus they won't get a chance
                to apply their custom logic. If you are using the
                <tt class="literal">'default-lazy-init'</tt> attribute on the declaration of your
                <tt class="literal">&lt;beans/&gt;</tt> element, be sure to mark your various
                <tt class="interfacename">BeanFactoryPostProcessor</tt> bean definitions with
                <tt class="literal">'lazy-init="false"'</tt>.
                </p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-placeholderconfigurer"></a>3.7.2.1.&nbsp;Example: the <tt class="interfacename">PropertyPlaceholderConfigurer</tt></h4></div></div><div></div></div><p>The <tt class="interfacename">PropertyPlaceholderConfigurer</tt>, implemented
                as a bean factory post-processor, is used to externalize some property
                values from a <tt class="interfacename">BeanFactory</tt> definition, into another
                separate file in the standard Java <tt class="classname">Properties</tt> format.
                This is useful to allow the person deploying an application to customize some key
                properties (for example database URLs, usernames and passwords), without the
                complexity or risk of modifying the main XML definition file or files for the
                container.</p><p>Consider the following XML-based configuration metadata fragment, where a
                <tt class="interfacename">DataSource</tt> with placeholder values is defined. We
                will configure some properties from an external <tt class="classname">Properties</tt>
                file, and at runtime, we will apply a
                <tt class="classname">PropertyPlaceholderConfigurer</tt> to the metadata which will
                replace some properties of the datasource:</p><pre class="programlisting">&lt;bean id="dataSource" destroy-method="close"
      class="org.apache.commons.dbcp.BasicDataSource"&gt;
    &lt;property name="driverClassName" value="<span class="bold"><b>${jdbc.driverClassName}</b></span>"/&gt;
    &lt;property name="url" value="<span class="bold"><b>${jdbc.url}</b></span>"/&gt;
    &lt;property name="username" value="<span class="bold"><b>jdbc.username</b></span>"/&gt;
    &lt;property name="password" value="<span class="bold"><b>${jdbc.password}</b></span>"/&gt;
&lt;/bean&gt;</pre><p>The actual values come from another file in the standard Java
                <tt class="classname">Properties</tt> format:</p><pre class="programlisting">jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root</pre><p>The <tt class="classname">PropertyPlaceholderConfigurer</tt> doesn't only
				look for properties in the <tt class="classname">Properties</tt> file you
				specify, but also checks against the Java <tt class="classname">System</tt>
				properties if it cannot find a property you are trying to use. This
				behavior can be customized by setting the <tt class="literal">systemPropertiesMode</tt>
				property of the configurer. It has three values, one to tell the configurer
				to always override, one to let it <span class="emphasis"><em>never</em></span> override and
				one to let it override only if the property cannot be found in the
				properties file specified. Please consult the Javadoc for the
				<tt class="classname">PropertiesPlaceholderConfigurer</tt> for more information.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-overrideconfigurer"></a>3.7.2.2.&nbsp;Example: the <tt class="classname">PropertyOverrideConfigurer</tt></h4></div></div><div></div></div><p>The <tt class="classname">PropertyOverrideConfigurer</tt>, another bean
                factory post-processor, is similar to the
                <tt class="interfacename">PropertyPlaceholderConfigurer</tt>, but in contrast to the
                latter, the original definitions can have default values or no values at
                all for bean properties. If an overriding <tt class="classname">Properties</tt> file
                does not have an entry for a certain bean property, the default context definition
                is used.</p><p>Note that the bean factory definition is <span class="emphasis"><em>not</em></span>
                aware of being overridden, so it is not immediately obvious when looking
                at the XML definition file that the override configurer is being used.
                In case that there are multiple <tt class="classname">PropertyOverrideConfigurer</tt>
                instances that define different values for the same bean property, the last one
                will win (due to the overriding mechanism).</p><p>Properties file configuration lines are expected to be in the format:</p><pre class="programlisting">beanName.property=value</pre><p>An example properties file might look like this:</p><pre class="programlisting">dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb</pre><p>This example file would be usable against a container definition
                which contains a bean called <span class="emphasis"><em>dataSource</em></span>,
                which has <span class="emphasis"><em>driver</em></span> and <span class="emphasis"><em>url</em></span>
                properties.</p><p>Note that compound property names are also supported, as long as
                every component of the path except the final property being overridden is
                already non-null (presumably initialized by the constructors). In this
                example...</p><pre class="programlisting">foo.fred.bob.sammy=123</pre><p>... the <tt class="literal">sammy</tt> property of the <tt class="literal">bob</tt> property
                of the <tt class="literal">fred</tt> property of the <tt class="literal">foo</tt>
                bean is being set to the scalar value <tt class="literal">123</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-extension-factorybean"></a>3.7.3.&nbsp;Customizing instantiation logic using <tt class="literal">FactoryBeans</tt></h3></div></div><div></div></div><p>The <tt class="interfacename">org.springframework.beans.factory.FactoryBean</tt>
            interface is to be implemented by objects that <span class="emphasis"><em>are themselves
            factories</em></span>.</p><p>The <tt class="interfacename">FactoryBean</tt> interface is a point of pluggability
            into the Spring IoC containers instantiation logic. If you have some complex
            initialization code that is better expressed in Java as opposed to a (potentially)
            verbose amount of XML, you can create your own <tt class="interfacename">FactoryBean</tt>,
            write the complex initialization inside that class, and then plug your custom
            <tt class="interfacename">FactoryBean</tt> into the container.</p><p>The <tt class="interfacename">FactoryBean</tt> interface provides three methods:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">Object getObject()</tt>: has to return an
                    instance of the object this factory creates. The instance can
                    possibly be shared (depending on whether this factory returns
                    singletons or prototypes).</p></li><li><p><tt class="methodname">boolean isSingleton()</tt>: has to return
                    <tt class="literal">true</tt> if this <tt class="interfacename">FactoryBean</tt>
                    returns singletons, <tt class="literal">false</tt> otherwise</p></li><li><p><tt class="methodname">Class getObjectType()</tt>: has to return
                    either the object type returned by the
                    <tt class="methodname">getObject()</tt> method or <tt class="literal">null</tt>
                    if the type isn't known in advance</p></li></ul></div><p>The <tt class="interfacename">FactoryBean</tt> concept and interface
            is used in a number of places within the Spring Framework; at the time of writing
            there are over 50 implementations of the <tt class="interfacename">FactoryBean</tt>
            interface that ship with Spring itself.</p><p>Finally, there is sometimes a need to ask a container for an actual
            <tt class="interfacename">FactoryBean</tt> instance itself, not the bean it produces.
            This may be achieved by prepending the bean id with <tt class="literal">'&amp;'</tt>
            (sans quotes) when calling the <tt class="methodname">getBean</tt> method of
            the <tt class="interfacename">BeanFactory</tt> (including
            <tt class="interfacename">ApplicationContext</tt>). So for a given
            <tt class="interfacename">FactoryBean</tt> with an id of <tt class="literal">myBean</tt>,
            invoking <tt class="literal">getBean("myBean")</tt> on the container will return the
            product of the <tt class="interfacename">FactoryBean</tt>, but invoking
            <tt class="literal">getBean("&amp;myBean")</tt> will return the
            <tt class="interfacename">FactoryBean</tt> instance itself.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="context-introduction"></a>3.8.&nbsp;The <tt class="interfacename">ApplicationContext</tt></h2></div></div><div></div></div><p>While the <tt class="literal">beans</tt> package provides basic
        functionality for managing and manipulating beans, often in a programmatic
        way, the <tt class="literal">context</tt> package adds
        <tt class="literal"><a href="http://www.springframework.org/docs/api/org/springframework/context/ApplicationContext.html" target="_top">ApplicationContext</a></tt>,
        which enhances <tt class="interfacename">BeanFactory</tt> functionality in a more
        <span class="emphasis"><em>framework-oriented style</em></span>. Many users will use
        <tt class="interfacename">ApplicationContext</tt> in a completely declarative fashion,
        not even having to create it manually, but instead relying on support classes such as
        <tt class="classname">ContextLoader</tt> to automatically start an <tt class="interfacename">ApplicationContext</tt> as part of the
        normal startup process of a J2EE web-app. Of course, it is still possible
        to programmatically create an ApplicationContext.</p><p>The basis for the context package is the
        <tt class="interfacename">ApplicationContext</tt> interface, located in the
        <tt class="literal">org.springframework.context</tt> package. Deriving from the
        <tt class="interfacename">BeanFactory</tt> interface, it provides all the functionality of
        <tt class="interfacename">BeanFactory</tt>. To allow working in a more framework-oriented
        fashion, using layering and hierarchical contexts, the context package also provides the
        following functionality:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="interfacename">MessageSource</tt>, providing access to
                    messages in i18n-style</p></li><li><p><span class="emphasis"><em>Access to resources</em></span>, such as URLs and files</p></li><li><p><span class="emphasis"><em>Event propagation</em></span> to beans implementing
                    the <tt class="interfacename">ApplicationListener</tt> interface</p></li><li><p><span class="emphasis"><em>Loading of multiple (hierarchical)
                    contexts</em></span>, allowing each to be focused on one particular
                    layer, for example the web layer of an application</p></li></ul></div><p>As the <tt class="interfacename">ApplicationContext</tt> includes all functionality of the
        <tt class="interfacename">BeanFactory</tt>, it is generally recommended that it be used over the
        <tt class="interfacename">BeanFactory</tt>, except for a few limited situations such as perhaps in an
        <tt class="classname">Applet</tt>, where memory consumption might be critical, and a few extra
        kilobytes might make a difference. The following sections describe
        functionality that <tt class="interfacename">ApplicationContext</tt> adds to basic <tt class="interfacename">BeanFactory</tt>
        capabilities.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-functionality-messagesource"></a>3.8.1.&nbsp;Internationalization using <tt class="literal">MessageSources</tt></h3></div></div><div></div></div><p>The <tt class="interfacename">ApplicationContext</tt> interface extends an interface called
            <tt class="interfacename">MessageSource</tt>, and therefore provides messaging (i18n
            or internationalization) functionality. Together with the
            <tt class="classname">HierarchicalMessageSource</tt>, capable of resolving
            hierarchical messages, these are the basic interfaces Spring provides to
            do message resolution. Let's quickly review the methods defined there:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">String getMessage(String code, Object[] args,
                        String default, Locale loc)</tt>: the basic method used to
                        retrieve a message from the <tt class="interfacename">MessageSource</tt>. When no message is
                        found for the specified locale, the default message is used. Any
                        arguments passed in are used as replacement values, using the
                        <tt class="literal">MessageFormat</tt> functionality provided by the
                        standard library.</p></li><li><p><tt class="literal">String getMessage(String code, Object[] args,
                        Locale loc)</tt>: essentially the same as the previous
                        method, but with one difference: no default message can be
                        specified; if the message cannot be found, a
                        <tt class="classname">NoSuchMessageException</tt> is thrown.</p></li><li><p><tt class="literal">String getMessage(MessageSourceResolvable
						resolvable, Locale locale)</tt>: all properties used in the
						methods above are also wrapped in a class named
						<tt class="interfacename">MessageSourceResolvable</tt>, which you can use via
						this method.</p></li></ul></div><p>
				When an <tt class="interfacename">ApplicationContext</tt> gets loaded, it automatically searches
				for a <tt class="interfacename">MessageSource</tt> bean defined in the context. The bean has to have
				the name <tt class="literal">messageSource</tt>. If such a bean is found, all
				calls to the methods described above will be delegated to the message
				source that was found. If no message source was found, the
				<tt class="interfacename">ApplicationContext</tt> attempts to see if it has a parent containing a bean
				with the same name. If so, it uses that bean as the <tt class="interfacename">MessageSource</tt>. If it
				can't find any source for messages, an empty
				<tt class="classname">StaticMessageSource</tt> will be instantiated in order to
				be able to accept calls to the methods defined above.
			</p><p>
				Spring currently provides two <tt class="interfacename">MessageSource</tt>
				implementations. These are the
				<tt class="classname">ResourceBundleMessageSource</tt> and the
				<tt class="classname">StaticMessageSource</tt>. Both implement
				<tt class="classname">NestingMessageSource</tt> in order to do nested messaging.
				The <tt class="classname">StaticMessageSource</tt> is hardly ever used but provides programmatic
				ways to add messages to the source. The <tt class="classname">ResourceBundleMessageSource</tt> is
				more interesting and is the one we will provide an example for:
      </p><pre class="programlisting">&lt;beans&gt;
  &lt;bean id="messageSource"
        class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
    &lt;property name="basenames"&gt;
      &lt;list&gt;
        &lt;value&gt;format&lt;/value&gt;
        &lt;value&gt;exceptions&lt;/value&gt;
        &lt;value&gt;windows&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</pre><p>This assumes you have three resource bundles defined on your
      classpath called <tt class="literal">format</tt>,
      <tt class="literal">exceptions</tt> and <tt class="literal">windows</tt>. Using the
      JDK standard way of resolving messages through ResourceBundles, any
      request to resolve a message will be handled. For the purposes of the example,
      lets assume the contents of two of the above resource bundle files are...</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation"># in 'format.properties'</span></i>
message=Alligators rock!</pre><pre class="programlisting"><i class="lineannotation"><span class="lineannotation"># in 'exceptions.properties'</span></i>
argument.required=The '{0}' argument is required.</pre><p>Some (admittedly trivial) driver code to exercise the
        <tt class="classname">MessageSource</tt> functionality can be found below. Remember
        that all <tt class="classname">ApplicationContext</tt> implementations are also
        <tt class="classname">MessageSource</tt> implementations and so can be cast to the
        <tt class="classname">MessageSource</tt> interface.</p><pre class="programlisting">public static void main(String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("message", null, "Default", null);
    System.out.println(message);
}</pre><p>The resulting output from the above program will be...</p><pre class="programlisting">Alligators rock!</pre><p>So to summarize, the <tt class="classname">MessageSource</tt> is defined in a file
        called <tt class="literal">'beans.xml'</tt> (this file exists at the root of your classpath).
        The <tt class="literal">'messageSource'</tt> bean definition refers to a number
        of resource bundles via it's <tt class="literal">basenames</tt> property; the three files
        that are passed in the list to the <tt class="literal">basenames</tt> property exist as files
        at the root of your classpath (and are called
        <tt class="literal">format.properties</tt>, <tt class="literal">exceptions.properties</tt>,
        and <tt class="literal">windows.properties</tt> respectively).</p><p>Lets look at another example, and this time we will look at passing arguments
        to the message lookup; these arguments will be converted into strings and inserted
        into placeholders in the lookup message. This is perhaps best explained with an
        example:</p><pre class="programlisting">&lt;beans&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- this <tt class="interfacename">MessageSource</tt> is being used in a web application --&gt;</span></i>
    &lt;bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
        &lt;property name="baseName" value="WEB-INF/test-messages"/&gt;
    &lt;/bean&gt;
    
    <i class="lineannotation"><span class="lineannotation">&lt;!-- let's inject the above <tt class="interfacename">MessageSource</tt> into this POJO --&gt;</span></i>
    &lt;bean id="example" class="com.foo.Example"&gt;
        &lt;property name="messages" ref="messageSource"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class Example {

    private MessageSource messages;

    public void setMessages(MessageSource messages) {
        this.messages = messages;
    }

    public void execute() {
        String message = this.messages.getMessage("argument.required",
            new Object [] {"userDao"}, "Required", null);
        System.out.println(message);
    }

}</pre><p>The resulting output from the invocation of the <tt class="methodname">execute()</tt>
            method will be...</p><pre class="programlisting">The 'userDao' argument is required.</pre><p>With regard to internationalization (i18n), Spring's various
        <tt class="classname">MessageResource</tt> implementations follow the same locale resolution
        and fallback rules as the standard JDK ResourceBundle. In short, and continuing with
        the example <tt class="literal">'messageSource'</tt> defined previously, if you want to resolve
        messages against the British (en-GB) locale, you would create files called
        <tt class="literal">format_en_GB.properties</tt>, <tt class="literal">exceptions_en_GB.properties</tt>,
        and <tt class="literal">windows_en_GB.properties</tt> respectively.</p><p>Locale resolution is typically going to be managed by the surrounding environment
        of the application. For the purpose of this example though, we'll just manually
        specify the locale that we want to resolve our (British) messages against.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation"># in 'exceptions_en_GB.properties'</span></i>
argument.required=Ebagum lad, the '{0}' argument is required, I say, required.</pre><pre class="programlisting">public static void main(final String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("argument.required",
        new Object [] {"userDao"}, "Required", Locale.UK);
    System.out.println(message);
}</pre><p>The resulting output from the running of the above program will be...</p><pre class="programlisting">Ebagum lad, the 'userDao' argument is required, I say, required.</pre><p>The <tt class="classname">MessageSourceAware</tt> interface can also be used to acquire
            a reference to any <tt class="classname">MessageSource</tt> that has been defined. Any bean
            that is defined in an <tt class="classname">ApplicationContext</tt> that implements the
            <tt class="classname">MessageSourceAware</tt> interface will be injected with the
            application context's <tt class="classname">MessageSource</tt> when it (the bean) is being
            created and configured.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-functionality-events"></a>3.8.2.&nbsp;Events</h3></div></div><div></div></div><p>Event handling in the <tt class="interfacename">ApplicationContext</tt> is provided
			through the <tt class="classname">ApplicationEvent</tt> class and
			<tt class="interfacename">ApplicationListener</tt> interface. If a bean which
			implements the <tt class="interfacename">ApplicationListener</tt> interface is
			deployed into the context, every time an <tt class="classname">ApplicationEvent</tt>
			gets published to the <tt class="interfacename">ApplicationContext</tt>, that
			bean will be notified. Essentially, this is the standard <span class="emphasis"><em>Observer</em></span>
			design pattern. Spring provides	three standard events:</p><div class="table"><a name="d0e5367"></a><p class="title"><b>Table&nbsp;3.5.&nbsp;Built-in Events</b></p><table summary="Built-in Events" border="1"><colgroup><col><col></colgroup><thead><tr><th>Event</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="classname">ContextRefreshedEvent</tt></td><td><p>Event published when the
                                <tt class="interfacename">ApplicationContext</tt> is
                                initialized or refreshed. Initialized here means that all
                                beans are loaded, singletons are pre-instantiated and the
                                <tt class="interfacename">ApplicationContext</tt> is ready
                                for use</p></td></tr><tr><td><tt class="classname">ContextClosedEvent</tt></td><td><p>Event published when the <tt class="interfacename">ApplicationContext</tt> is closed,
                                using the <tt class="methodname">close()</tt> method on the
                                <tt class="interfacename">ApplicationContext</tt>. Closed here means
                                that singleton beans are destroyed</p></td></tr><tr><td><tt class="classname">RequestHandledEvent</tt></td><td><p>A web-specific event telling all beans that a HTTP
                                request has been serviced (i.e. this will be published
                                <span class="emphasis"><em>after</em></span> the request has been finished).
                                Note that this event is only applicable for web applications
                                using Spring's <tt class="classname">DispatcherServlet</tt></p></td></tr></tbody></table></div><p>Implementing custom events can be done as well. Simply call the
			<tt class="methodname">publishEvent()</tt> method on the <tt class="interfacename">ApplicationContext</tt>,
			specifying a parameter which is an instance of your custom event class
			implementing <tt class="classname">ApplicationEvent</tt>. Event listeners receive events
			synchronously. This means the <tt class="methodname">publishEvent()</tt> method blocks until all
			listeners have finished processing the event (it is possible to supply
			an alternate event publishing strategy via a
			<tt class="interfacename">ApplicationEventMulticaster</tt> implementation).
			Furthermore, when a listener receives an event it operates inside the transaction context of
			the publisher, if a transaction context is available.</p><p>Let's look at an example. First, the <tt class="interfacename">ApplicationContext</tt>:</p><pre class="programlisting">&lt;bean id="emailer" class="example.EmailBean"&gt;
  &lt;property name="blackList"&gt;
    &lt;list&gt;
      &lt;value&gt;black@list.org&lt;/value&gt;
      &lt;value&gt;white@list.org&lt;/value&gt;
      &lt;value&gt;john@doe.org&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="blackListListener" class="example.BlackListNotifier"&gt;
  &lt;property name="notificationAddress" value="spam@list.org"/&gt;
&lt;/bean&gt;</pre><p>Now, let's look at the actual classes:</p><pre class="programlisting">public class EmailBean implements ApplicationContextAware {

    private List blackList;
	private ApplicationContext ctx;

    public void setBlackList(List blackList) {
        this.blackList = blackList;
    }

    public void setApplicationContext(ApplicationContext ctx) {
        this.ctx = ctx;
    }

    public void sendEmail(String address, String text) {
        if (blackList.contains(address)) {
            BlackListEvent evt = new BlackListEvent(address, text);
            ctx.publishEvent(evt);
            return;
        }
        <i class="lineannotation"><span class="lineannotation">// send email...</span></i>
    }
}</pre><pre class="programlisting">public class BlackListNotifier implement ApplicationListener {

    private String notificationAddress;
    
    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(ApplicationEvent evt) {
        if (evt instanceof BlackListEvent) {
            <i class="lineannotation"><span class="lineannotation">// notify appropriate person...</span></i>
        }
    }
}</pre><p>Of course, this particular example could probably be
			implemented in better ways (perhaps by using AOP features), but it
			should be sufficient to illustrate the basic event mechanism.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-functionality-resources"></a>3.8.3.&nbsp;Convenient access to low-level resources</h3></div></div><div></div></div><p>For optimal usage and understanding of application contexts, users
			should generally familiarize themselves with Spring's
			<tt class="interfacename">Resource</tt> abstraction, as described
			in the chapter entitled <a href="resources.html" title="Chapter&nbsp;4.&nbsp;Resources">Chapter&nbsp;4, <i>Resources</i></a>.</p><p>
				An application context is a <tt class="interfacename">ResourceLoader</tt>,
				able to be used to load <tt class="interfacename">Resource</tt>s. A
				<tt class="interfacename">Resource</tt> is essentially a
				<tt class="literal">java.net.URL</tt> on steroids (in fact, it just wraps and
				uses a URL where appropriate), which can be used to obtain low-level
				resources from almost any location in a transparent fashion, including
				from the classpath, a filesystem location, anywhere describable with a
				standard URL, and some other variations. If the resource location string
				is a simple path without any special prefixes, where those resources
				come from is specific and appropriate to the actual application context
				type.
			</p><p>A bean deployed into the application context may implement the
			special marker interface, <tt class="interfacename">ResourceLoaderAware</tt>, to be
			automatically called back at initialization time with the application
			context itself passed in as the <tt class="interfacename">ResourceLoader</tt>.</p><p>
				A bean may also expose properties of type
				<tt class="interfacename">Resource</tt>, to be used to access static resources, and
				expect that they will be injected into it like any other properties. The
				person deploying the bean may specify those <tt class="interfacename">Resource</tt>
				properties as simple String paths, and rely on a special JavaBean
				<tt class="interfacename">PropertyEditor</tt> that is automatically registered
				by the context, to convert those text strings to actual <tt class="interfacename">Resource</tt>
				objects.
			</p><p>The location path or paths supplied to an <tt class="interfacename">ApplicationContext</tt>
			constructor are actually resource strings, and in simple form are
			treated appropriately to the specific context implementation (i.e.
			<tt class="classname">ClassPathXmlApplicationContext</tt> treats a simple location path as a
			classpath location), but may also be used with special prefixes to force
			loading of definitions from the classpath or a URL, regardless of the
			actual context type.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-create"></a>3.8.4.&nbsp;Convenient <tt class="interfacename">ApplicationContext</tt> instantiation for web applications</h3></div></div><div></div></div><p>As opposed to the <tt class="interfacename">BeanFactory</tt>, which will
			often be created programmatically, <tt class="interfacename">ApplicationContext</tt>
			instances can be created declaratively using for example a
			<tt class="interfacename">ContextLoader</tt>. Of course you can also create
			<tt class="interfacename">ApplicationContext</tt> instances programmatically
			using one of the <tt class="interfacename">ApplicationContext</tt> implementations.
			First, let's examine the <tt class="interfacename">ContextLoader</tt> interface
			and its implementations.</p><p>The <tt class="interfacename">ContextLoader</tt> interface has two
            implementations: the <tt class="classname">ContextLoaderListener</tt> and the
			<tt class="classname">ContextLoaderServlet</tt>. They both have the same
			functionality but differ in that the listener version cannot be used in Servlet
			2.2 compatible containers. Since the Servlet 2.4 specification, servlet context
			listeners are required to execute immediately after the servlet context for the
			web application has been created and is available to service the first request
			(and also when the servlet context is about to be shut down): as such a 
			servlet context listener is an ideal place to initialize the Spring
			<tt class="interfacename">ApplicationContext</tt>. It is up to you
			as to which one you use, but all things being equal you should probably
			prefer <tt class="classname">ContextLoaderListener</tt>; for more information on
			compatibility, have a look at the Javadoc for the
			<tt class="classname">ContextLoaderServlet</tt>.</p><p>You can register an <tt class="interfacename">ApplicationContext</tt> using the
			<tt class="classname">ContextLoaderListener</tt> as follows:</p><pre class="programlisting">&lt;context-param&gt;
  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
  &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- or use the <tt class="classname">ContextLoaderServlet</tt> instead of the above listener</span></i><span class="emphasis"><em>
&lt;servlet&gt;
  &lt;servlet-name&gt;context&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.springframework.web.context.ContextLoaderServlet&lt;/servlet-class&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
--</em></span>&gt;</pre><p>The listener inspects the
			<tt class="literal">contextConfigLocation</tt> parameter. If it doesn't exist,
			it'll use <tt class="literal">/WEB-INF/applicationContext.xml</tt> as a default.
			When it <span class="emphasis"><em>does</em></span> exist, it'll separate the String using
			predefined delimiters (comma, semi-colon and whitespace) and use the values as
			locations where application contexts will be searched for. The
			<tt class="classname">ContextLoaderServlet</tt> can - as said - be used
			instead of the <tt class="classname">ContextLoaderListener</tt>. The servlet
			will use the <tt class="literal">'contextConfigLocation'</tt> parameter just
			as the listener does.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5597"></a>3.9.&nbsp;Glue code and the evil singleton</h2></div></div><div></div></div><p>The majority of the code inside an application is best written in a
		DI style, where that code is served out of a Spring IoC container, has its own
		dependencies supplied by the container when it is created, and is
		completely unaware of the container. However, for the small glue layers of
		code that are sometimes needed to tie other code together, there is
		sometimes a need for singleton (or quasi-singleton) style access to a
		Spring IoC container. For example,
		third party code may try to construct new objects directly (<tt class="literal">Class.forName()</tt>
		style), without the ability to force it to get these objects out of a
		Spring IoC container. If the object constructed by the
		third party code is just a small stub or proxy, which then uses a singleton style access to a
		Spring IoC container to get a real object to delegate to, then inversion of control has
		still been achieved for the majority of the code (the object coming out of the
		container); thus most code is still	unaware of the container or how it is accessed, and
		remains uncoupled from other code, with all ensuing benefits. EJBs may also use this stub/proxy
		approach to delegate to a plain Java implementation object, coming out of
		a Spring IoC container. While the Spring IoC container itself ideally does not have to be a
		singleton, it may be unrealistic in terms of memory usage or initialization times (when
		using beans in the Spring IoC container such as a Hibernate
		<tt class="interfacename">SessionFactory</tt>) for each bean to use its own, non-singleton
		Spring IoC container.</p><p>As another example, in a complex J2EE apps with multiple layers
        (i.e. various JAR files, EJBs, and WAR files packaged as an EAR),
        with each layer having its own Spring IoC container definition
        (effectively forming a hierarchy), the preferred approach when
        there is only one web-app (WAR) in the top hierarchy is to simply
        create one composite Spring IoC container from the multiple XML definition
        files from each layer. All of the various Spring IoC container implementations
        may be constructed from multiple definition files in this fashion.
        However, if there are multiple sibling web-applications at the root
        of the hierarchy, it is problematic to create a
        Spring IoC container for each web-application
        which consists of mostly identical bean definitions from lower layers,
        as there may be issues due to increased memory usage, issues with
        creating multiple copies of beans which take a long time to initialize
        (e.g. a Hibernate <tt class="interfacename">SessionFactory</tt>), and
        possible issues due to side-effects. As an alternative, classes such as
        <tt class="literal"><a href="http://www.springframework.org/docs/api/org/springframework/context/access/ContextSingletonBeanFactoryLocator.html" target="_top">ContextSingletonBeanFactoryLocator</a></tt>
        or
        <tt class="literal"><a href="http://www.springframework.org/docs/api/org/springframework/beans/factory/access/SingletonBeanFactoryLocator.html" target="_top">SingletonBeanFactoryLocator</a></tt>
        may be used to demand-load multiple hierarchical (i.e. one is a parent of
        another) Spring IoC container instances in an effectively singleton fashion,
        which may then be used as the parents of the web-application Spring IoC
        container instances. The result is that bean definitions for lower layers are
        loaded only as needed, and loaded only once.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5621"></a>3.9.1.&nbsp;Using the Singleton-helper classes</h3></div></div><div></div></div><p>You can see a detailed example of their usage in
            <a href="http://www.springframework.org/docs/api/org/springframework/beans/factory/access/SingletonBeanFactoryLocator.html" target="_top">SingletonBeanFactoryLocator</a>
            and
            <a href="http://www.springframework.org/docs/api/org/springframework/context/access/ContextSingletonBeanFactoryLocator.html" target="_top">ContextSingletonBeanFactoryLocator</a>
            by viewing their respective Javadocs.
            </p><p>As mentioned in the <a href="ejb.html" title="Chapter&nbsp;18.&nbsp;Enterprise Java Bean (EJB) integration">chapter on EJBs</a>, the
            Spring convenience base classes for EJBs normally use a non-singleton
            <tt class="interfacename">BeanFactoryLocator</tt> implementation, which is
            easily replaced by the use of <tt class="classname">SingletonBeanFactoryLocator</tt>
            and <tt class="classname">ContextSingletonBeanFactoryLocator</tt> if there is
            a need.</p></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e814" href="#d0e814">1</a>] </sup>See the section entitled <a href="introduction.html#background-ioc" title="Background">Background</a></p></div><div class="footnote"><p><sup>[<a name="ftn.d0e2713" href="#d0e2713">2</a>] </sup>See the section entitled <a href="beans.html#beans-factory-collaborators" title="3.3.1.&nbsp;Injecting dependencies">Section&nbsp;3.3.1, &#8220;Injecting dependencies&#8221;</a></p></div></div></div><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pt01.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="resources.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part&nbsp;I.&nbsp;Core Technologies&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.interface21.com/" title="Interface21 - Spring from the Source">Sponsored by Interface21</a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;4.&nbsp;Resources</td></tr></table></div></body>
<!-- Mirrored from static.springframework.org/spring/docs/2.0.x/reference/beans.html by HTTrack Website Copier/3.x [XR&CO'2005], Tue, 17 Oct 2006 17:45:43 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
