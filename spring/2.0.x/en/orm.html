<html>
<!-- Mirrored from static.springframework.org/spring/docs/2.0.x/reference/orm.html by HTTrack Website Copier/3.x [XR&CO'2005], Tue, 17 Oct 2006 17:46:00 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;12.&nbsp;Object Relational Mapping (ORM) data access</title><link rel="stylesheet" href="http://static.springframework.org/spring/docs/2.0.x/styles/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><link rel="home" href="index.html" title="The Spring Framework - Reference Documentation"><link rel="up" href="pt02.html" title="Part&nbsp;II.&nbsp;Middle Tier Data Access"><link rel="previous" href="jdbc.html" title="Chapter&nbsp;11.&nbsp;Data access using JDBC"><link rel="next" href="pt03.html" title="Part&nbsp;III.&nbsp;The Web"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns="http://www.w3.org/TR/xhtml1/transitional" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://www.springframework.org/" title="The Spring Framework"><img style="border:none;" src="images/xdev-spring_logo.jpg"></a><a style="border:none;" href="http://www.interface21.com/" title="Interface21 - Spring from the Source"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/i21-banner-rhs.jpg"></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="orm"></a>Chapter&nbsp;12.&nbsp;Object Relational Mapping (ORM) data access</h2></div></div>
   <table align="center">
<tr>
<td>
<script type="text/javascript"><!--
google_ad_client = "pub-2627642070897863";
google_ad_width = 336;
google_ad_height = 280;
google_ad_format = "336x280_as";
google_ad_type = "text_image";
//2006-10-13: com_336x280
google_ad_channel = "7652836435";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
<td>
<script type="text/javascript"><!--
google_ad_client = "pub-2627642070897863";
google_ad_width = 336;
google_ad_height = 280;
google_ad_format = "336x280_as";
google_ad_type = "text_image";
//2006-10-13: com_336x280
google_ad_channel = "7652836435";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</tr>
</table>
   <div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-introduction"></a>12.1.&nbsp;Introduction</h2></div></div><div></div></div><p>Spring provides integration with <span class="emphasis"><em>Hibernate, JDO, Oracle
    TopLink, iBATIS SQL Maps</em></span> and <span class="emphasis"><em>JPA</em></span>: in terms
    of resource management, DAO implementation support, and transaction
    strategies. For example for Hibernate, there is first-class support with
    lots of IoC convenience features, addressing many typical Hibernate
    integration issues. All of these support packages for O/R mappers comply
    with Spring's generic transaction and DAO exception hierarchies. There are
    usually two integration styles: either using Spring's DAO 'templates' or
    coding DAOs against plain Hibernate/JDO/TopLink/etc APIs. In both cases,
    DAOs can be configured through Dependency Injection and participate in
    Spring's resource and transaction management.</p><p>Spring's adds significant support when using the O/R mapping layer
    of your choice to create data access applications. First of all, you
    should know that once you started using Spring's support for O/R mapping,
    you don't have to go all the way. No matter to what extent, you're invited
    to review and leverage the Spring approach, before deciding to take the
    effort and risk of building a similar infrastructure in-house. Much of the
    O/R mapping support, no matter what technology you're using may be used in
    a library style, as everything is designed as a set of reusable JavaBeans.
    Usage inside a Spring IoC container does provide additional benefits in
    terms of ease of configuration and deployment; as such, most examples in
    this section show configuration inside a Spring
    <tt class="interfacename">ApplicationContext</tt>.</p><p>Some of the benefits of using Spring to create your O/R mapping DAOs
    include:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Ease of testing.</em></span> Spring's inversion of
        control approach makes it easy to swap the implementations and config
        locations of Hibernate <tt class="interfacename">SessionFactory</tt>
        instances, JDBC <tt class="interfacename">DataSource</tt> instances,
        transaction managers, and mapper object implementations (if needed).
        This makes it much easier to isolate and test each piece of
        persistence-related code in isolation.</p></li><li><p><span class="emphasis"><em>Common data access exceptions.</em></span> Spring can
        wrap exceptions from you O/R mapping tool of choice, converting them
        from proprietary (potentially checked) exceptions to a common runtime
        DataAccessException hierarchy. This allows you to handle most
        persistence exceptions, which are non-recoverable, only in the
        appropriate layers, without annoying boilerplate catches/throws, and
        exception declarations. You can still trap and handle exceptions
        anywhere you need to. Remember that JDBC exceptions (including DB
        specific dialects) are also converted to the same hierarchy, meaning
        that you can perform some operations with JDBC within a consistent
        programming model.</p></li><li><p><span class="emphasis"><em>General resource management.</em></span> Spring
        application contexts can handle the location and configuration of
        Hibernate <tt class="interfacename">SessionFactory</tt> instances,
        JDBC <tt class="interfacename">DataSource</tt> instances, iBATIS SQL
        Maps configuration objects, and other related resources. This makes
        these values easy to manage and change. Spring offers efficient, easy
        and safe handling of persistence resources. For example: related code
        using Hibernate generally needs to use the same Hibernate
        <tt class="interfacename">Session</tt> for efficiency and proper
        transaction handling. Spring makes it easy to transparently create and
        bind a <tt class="interfacename">Session</tt> to the current thread,
        either by using an explicit 'template' wrapper class at the Java code
        level or by exposing a current <tt class="interfacename">Session</tt>
        through the Hibernate <tt class="interfacename">SessionFactory</tt>
        (for DAOs based on plain Hibernate3 API). Thus Spring solves many of
        the issues that repeatedly arise from typical Hibernate usage, for any
        transaction environment (local or JTA).</p></li><li><p><span class="emphasis"><em>Integrated transaction management.</em></span> Spring
        allows you to wrap your O/R mapping code with either a declarative,
        AOP style method interceptor, or an explicit 'template' wrapper class
        at the Java code level. In either case, transaction semantics are
        handled for you, and proper transaction handling (rollback, etc) in
        case of exceptions is taken care of. As discussed below, you also get
        the benefit of being able to use and swap various transaction
        managers, without your Hibernate/JDO related code being affected: for
        example, between local transactions and JTA, with the same full
        services (such as declarative transactions) available in both
        scenarios. As an additional benefit, JDBC-related code can fully
        integrate transactionally with the code you use to do O/R mapping.
        This is useful for data access that's not suitable for O/R mapping,
        such as batch processing or streaming of BLOBs, which still needs to
        share common transactions with O/R mapping operations.</p></li><li><p><span class="emphasis"><em>To avoid vendor lock-in, and allow mix-and-match
        implementation strategies.</em></span> While Hibernate is powerful,
        flexible, open source and free, it still uses a proprietary API.
        Furthermore one could argue that iBATIS is a bit lightweight, although
        it's excellent for use in application that don't require complex O/R
        mapping strategies. Given the choice, it's usually desirable to
        implement major application functionality using standard or abstracted
        APIs, in case you need to switch to another implementation for reasons
        of functionality, performance, or any other concerns. For example,
        Spring's abstraction of Hibernate transactions and exceptions, along
        with its IoC approach which allows you to easily swap in mapper/DAO
        objects implementing data access functionality, makes it easy to
        isolate all Hibernate-specific code in one area of your application,
        <span class="emphasis"><em>without sacrificing any of the power of
        Hibernate</em></span>. Higher level service code dealing with the DAOs
        has no need to know anything about their implementation. This approach
        has the additional benefit of making it easy to intentionally
        implement data access with a mix-and-match approach (i.e. some data
        access performed using Hibernate, and some using JDBC, others using
        iBATIS) in a non-intrusive fashion, potentially providing great
        benefits in terms of continuing to use legacy code or leveraging the
        strength of each technology.</p></li></ul></div><p>The PetClinic sample in the Spring distribution offers alternative
    DAO implementations and application context configurations for JDBC,
    Hibernate, Oracle TopLink, and JPA. PetClinic can therefore serve as
    working sample app that illustrates the use of Hibernate, TopLink and JPA
    in a Spring web application. It also leverages declarative transaction
    demarcation with different transaction strategies.</p><p>The JPetStore sample illustrates the use of iBATIS SQL Maps in a
    Spring environment. It also features two web tier versions: one based on
    Spring Web MVC, one based on Struts.</p><p>Beyond the samples shipped with Spring, there is a variety of
    Spring-based O/R mapping samples provided by specific vendors: for
    example, the JDO implementations JPOX (<a href="http://www.jpox.org/" target="_top">http://www.jpox.org/</a>) and Kodo (<a href="http://www.bea.com/kodo" target="_top">http://www.bea.com/kodo</a>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-hibernate"></a>12.2.&nbsp;Hibernate</h2></div></div><div></div></div><p>We will start with a coverage of Hibernate (<a href="http://www.hibernate.org/" target="_top">http://www.hibernate.org/</a>) in a Spring environment, using
    it to demonstrate the approach that Spring takes towards integrating O/R
    mappers. This section will cover many issues in detail and show different
    variations of DAO implementations and transaction demarcations. Most of
    these patterns can be directly translated to all other supported O/R
    mapping tools. The following sections in this chapter will then cover the
    other O/R mappers, showing briefer examples there.</p><p>The following discussion focuses on Hibernate 3: this is the current
    major production ready version of Hibernate. Hibernate 2.x, which has been
    supported in Spring since its inception continues to be supported... it is
    just that the following examples all use the Hibernate 3 classes and
    configuration. All of this can (pretty much) be applied to Hibernate 2.x
    as-is, using the analogous Hibernate 2.x support package:
    <tt class="literal">org.springframework.orm.hibernate</tt>, mirroring
    <tt class="literal">org.springframework.orm.hibernate3</tt> with analogous
    support classes for Hibernate 2.x. Furthermore, all references to the
    <tt class="literal">org.hibernate</tt> package need to be replaced with
    <tt class="literal">net.sf.hibernate</tt>, following the root package change in
    Hibernate 3. Simply adapt the package names (as used in the examples)
    accordingly.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14616"></a>12.2.1.&nbsp;Resource management</h3></div></div><div></div></div><p>Typical business applications are often cluttered with repetitive
      resource management code. Many projects try to invent their own
      solutions for this issue, sometimes sacrificing proper handling of
      failures for programming convenience. Spring advocates strikingly simple
      solutions for proper resource handling: Inversion of control via
      templating, i.e. infrastructure classes with callback interfaces, or
      applying AOP interceptors. The infrastructure cares for proper resource
      handling, and for appropriate conversion of specific API exceptions to
      an unchecked infrastructure exception hierarchy. Spring introduces a DAO
      exception hierarchy, applicable to any data access strategy. For direct
      JDBC, the <tt class="classname">JdbcTemplate</tt> class mentioned in a
      previous section cares for connection handling, and for proper
      conversion of <tt class="classname">SQLException</tt> to the
      <tt class="classname">DataAccessException</tt> hierarchy, including
      translation of database-specific SQL error codes to meaningful exception
      classes. It supports both JTA and JDBC transactions, via respective
      Spring transaction managers.</p><p>Spring also offers Hibernate and JDO support, consisting of a
      <tt class="classname">HibernateTemplate</tt> /
      <tt class="classname">JdoTemplate</tt> analogous to
      <tt class="classname">JdbcTemplate</tt>, a
      <tt class="classname">HibernateInterceptor</tt> /
      <tt class="classname">JdoInterceptor</tt>, and a Hibernate / JDO transaction
      manager. The major goal is to allow for clear application layering, with
      any data access and transaction technology, and for loose coupling of
      application objects. No more business service dependencies on the data
      access or transaction strategy, no more hard-coded resource lookups, no
      more hard-to-replace singletons, no more custom service registries. One
      simple and consistent approach to wiring up application objects, keeping
      them as reusable and free from container dependencies as possible. All
      the individual data access features are usable on their own but
      integrate nicely with Spring's application context concept, providing
      XML-based configuration and cross-referencing of plain JavaBean
      instances that don't need to be Spring-aware. In a typical Spring app,
      many important objects are JavaBeans: data access templates, data access
      objects (that use the templates), transaction managers, business
      services (that use the data access objects and transaction managers),
      web view resolvers, web controllers (that use the business services),
      etc.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14647"></a>12.2.2.&nbsp;<tt class="interfacename">SessionFactory</tt> setup in a Spring
      application context</h3></div></div><div></div></div><p>To avoid tying application objects to hard-coded resource lookups,
      Spring allows you to define resources like a JDBC DataSource or a
      Hibernate <tt class="interfacename">SessionFactory</tt> as beans in an
      application context. Application objects that need to access resources
      just receive references to such pre-defined instances via bean
      references (the DAO definition in the next section illustrates this).
      The following excerpt from an XML application context definition shows
      how to set up a JDBC <tt class="classname">DataSource</tt> and a Hibernate
      <tt class="interfacename">SessionFactory</tt> on top of it:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="org.hsqldb.jdbcDriver"/&gt;
    &lt;property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/&gt;
    &lt;property name="username" value="sa"/&gt;
    &lt;property name="password" value=""/&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="myDataSource"/&gt;
    &lt;property name="mappingResources"&gt;
      &lt;list&gt;
        &lt;value&gt;product.hbm.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
      &lt;value&gt;
        hibernate.dialect=org.hibernate.dialect.MySQLDialect
      &lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

   ...
&lt;/beans&gt;</pre><p>Note that switching from a local Jakarta Commons DBCP
      <tt class="classname">BasicDataSource</tt> to a JNDI-located
      <tt class="interfacename">DataSource</tt> (usually managed by the J2EE
      server) is just a matter of configuration:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myDataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="java:comp/env/jdbc/myds"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</pre><p>You can also access a JNDI-located
      <tt class="interfacename">SessionFactory</tt>, using Spring's
      <tt class="classname">JndiObjectFactoryBean</tt> to retrieve and expose it.
      However, that is typically not necessary outside an EJB context.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14683"></a>12.2.3.&nbsp;The <tt class="classname">HibernateTemplate</tt></h3></div></div><div></div></div><p>The basic programming model for templating looks as follows, for
      methods that can be part of any custom data access object or business
      service. There are no restrictions on the implementation of the
      surrounding object at all, it just needs to provide a Hibernate
      <tt class="interfacename">SessionFactory</tt>. It can get the latter
      from anywhere, but preferably as bean reference from a Spring
      application context - via a simple
      <tt class="literal">setSessionFactory(..)</tt> bean property setter. The
      following snippets show a DAO definition in a Spring application
      context, referencing the above defined
      <tt class="interfacename">SessionFactory</tt>, and an example for a DAO
      method implementation.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        HibernateTemplate ht = new HibernateTemplate(this.sessionFactory);
        return (Collection) ht.execute(new HibernateCallback() {
            public Object doInHibernate(Session session) throws HibernateException {
                Query query = session.createQuery(
                    "from test.Product product where product.category=?");
                query.setString(0, category);
                return query.list();
            }
        });
    }
}</pre><p>A callback implementation can effectively be used for any
      Hibernate data access. <tt class="classname">HibernateTemplate</tt> will
      ensure that <tt class="interfacename">Session</tt> instances are
      properly opened and closed, and automatically participate in
      transactions. The template instances are thread-safe and reusable, they
      can thus be kept as instance variables of the surrounding class. For
      simple single step actions like a single find, load, saveOrUpdate, or
      delete call, <tt class="classname">HibernateTemplate</tt> offers alternative
      convenience methods that can replace such one line callback
      implementations. Furthermore, Spring provides a convenient
      <tt class="classname">HibernateDaoSupport</tt> base class that provides a
      <tt class="literal">setSessionFactory(..)</tt> method for receiving a
      <tt class="interfacename">SessionFactory</tt>, and
      <tt class="literal">getSessionFactory()</tt> and
      <tt class="literal">getHibernateTemplate()</tt> for use by subclasses. In
      combination, this allows for very simple DAO implementations for typical
      requirements:</p><pre class="programlisting">public class ProductDaoImpl extends HibernateDaoSupport implements ProductDao {

    public Collection loadProductsByCategory(String category) throws DataAccessException {
        return getHibernateTemplate().find(
            "from test.Product product where product.category=?", category);
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14731"></a>12.2.4.&nbsp;Implementing Spring-based DAOs without callbacks</h3></div></div><div></div></div><p>As alternative to using Spring's
      <tt class="classname">HibernateTemplate</tt> to implement DAOs, data access
      code can also be written in a more traditional fashion, without wrapping
      the Hibernate access code in a callback, while still complying to
      Spring's generic <tt class="classname">DataAccessException</tt> hierarchy.
      Spring's <tt class="classname">HibernateDaoSupport</tt> base class offers
      methods to access the current transactional
      <tt class="interfacename">Session</tt> and to convert exceptions in such
      a scenario; similar methods are also available as static helpers on the
      <tt class="classname">SessionFactoryUtils</tt> class. Note that such code
      will usually pass "false" into <tt class="literal">getSession(..)</tt>'s
      "allowCreate" argument, to enforce running within a transaction (which
      avoids the need to close the returned
      <tt class="interfacename">Session</tt>, as its lifecycle is managed by
      the transaction).</p><pre class="programlisting">public class ProductDaoImpl extends HibernateDaoSupport implements ProductDao {

    public Collection loadProductsByCategory(String category)
            throws DataAccessException, MyException {

        Session session = getSession(getSessionFactory(), false);
        try {
            List result = session.find(
                "from test.Product product where product.category=?",
                category, Hibernate.STRING);
            if (result == null) {
                throw new MyException("invalid search result");
            }
            return result;
        }
        catch (HibernateException ex) {
            throw convertHibernateAccessException(ex);
        }
    }
}</pre><p>The major advantage of such direct Hibernate access code is that
      it allows any checked application exception to be thrown within the data
      access code, while <tt class="classname">HibernateTemplate</tt> is
      restricted to unchecked exceptions within the callback. Note that one
      can often defer the corresponding checks and the throwing of application
      exceptions to after the callback, which still allows working with
      <tt class="classname">HibernateTemplate</tt>. In general,
      <tt class="classname">HibernateTemplate</tt>'s convenience methods are
      simpler and more convenient for many scenarios.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14770"></a>12.2.5.&nbsp;Implementing DAOs based on plain Hibernate3 API</h3></div></div><div></div></div><p>Hibernate 3.0.1 introduced a feature called "contextual Sessions",
      where Hibernate itself manages one current
      <tt class="interfacename">Session</tt> per transaction. This is roughly
      equivalent to Spring's synchronization of one Hibernate
      <tt class="interfacename">Session</tt> per transaction. A corresponding
      DAO implementation looks like as follows, based on plain Hibernate
      API:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public Collection loadProductsByCategory(String category) {
        return this.sessionFactory.getCurrentSession()
                .createQuery("from test.Product product where product.category=?")
                .setParameter(0, category)
                .list();
    }
}</pre><p>This Hibernate access style is very similar to what you will find
      in the Hibernate documentation and examples, except for holding the
      <tt class="interfacename">SessionFactory</tt> in an instance variable.
      We strongly recommend such an instance-based setup over the old-school
      <tt class="literal">static</tt> <tt class="classname">HibernateUtil</tt> class
      from Hibernate's CaveatEmptor sample application (In general, do not
      keep any resources in <tt class="literal">static</tt> variables unless
      <span class="emphasis"><em>absolutely</em></span> necessary.)</p><p>Our DAO above follows the Dependency Injection pattern: it still
      fits nicely into a Spring application context, just like it would if
      coded against Spring's <tt class="classname">HibernateTemplate</tt>.
      Concretely, it uses Setter Injection; if desired, it could use
      Constructor Injection instead. Of course, such a DAO can also be set up
      in plain Java (for example, in unit tests): simply instantiate it and
      call <tt class="literal">setSessionFactory(..)</tt> with the desired factory
      reference. As a Spring bean definition, it would look as follows:</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The main advantage of this DAO style is that it depends on
      Hibernate API only; no import of any Spring class is required. This is
      of course appealing from a non-invasiveness perspective, and might feel
      more natural to Hibernate developers.</p><p>However, the DAO throws plain
      <tt class="classname">HibernateException</tt> (which is unchecked, so does
      not have to be declared or caught), which means that callers can only
      treat exceptions as generally fatal - unless they want to depend on
      Hibernate's own exception hierarchy. Catching specific causes such as an
      optimistic locking failure is not possible without tieing the caller to
      the implementation strategy. This tradeoff might be acceptable to
      applications that are strongly Hibernate-based and/or do not need any
      special exception treatment.</p><p>Fortunately, Spring's
      <tt class="classname">LocalSessionFactoryBean</tt> supports Hibernate's
      <tt class="literal">SessionFactory.getCurrentSession()</tt> method for any
      Spring transaction strategy, returning the current Spring-managed
      transactional <tt class="interfacename">Session</tt> even with
      <tt class="classname">HibernateTransactionManager</tt>. Of course, the
      standard behavior of that method remains: returning the current
      <tt class="interfacename">Session</tt> associated with the ongoing JTA
      transaction, if any (no matter whether driven by Spring's
      <tt class="classname">JtaTransactionManager</tt>, by EJB CMT, or by plain
      JTA).</p><p>In summary: DAOs can be implemented based on the plain Hibernate3
      API, while still being able to participate in Spring-managed
      transactions. This might in particular appeal to people already familiar
      with Hibernate, feeling more natural to them. However, such DAOs will
      throw plain <tt class="classname">HibernateException</tt>; conversion to
      Spring's <tt class="classname">DataAccessException</tt> would have to happen
      explicitly (if desired).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14845"></a>12.2.6.&nbsp;Programmatic transaction demarcation</h3></div></div><div></div></div><p>On top of such lower-level data access services, transactions can
      be demarcated in a higher level of the application, spanning any number
      of operations. There are no restrictions on the implementation of the
      surrounding business service here as well, it just needs a Spring
      <tt class="classname">PlatformTransactionManager</tt>. Again, the latter can
      come from anywhere, but preferably as bean reference via a
      <tt class="methodname">setTransactionManager(..)</tt> method - just like
      the <tt class="classname">productDAO</tt> should be set via a
      <tt class="methodname">setProductDao</tt> method. The following snippets
      show a transaction manager and a business service definition in a Spring
      application context, and an example for a business method
      implementation.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductServiceImpl implements ProductService {

    private PlatformTransactionManager transactionManager;
    private ProductDao productDao;

    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    public void increasePriceOfAllProductsInCategory(final String category) {
        TransactionTemplate transactionTemplate = new TransactionTemplate(this.transactionManager);
        transactionTemplate.execute(
            new TransactionCallbackWithoutResult() {
                public void doInTransactionWithoutResult(TransactionStatus status) {
                    List productsToChange = productDAO.loadProductsByCategory(category);
                    <i class="lineannotation"><span class="lineannotation">// do the price increase... </span></i>
                }
            }
        );
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14869"></a>12.2.7.&nbsp;Declarative transaction demarcation</h3></div></div><div></div></div><p>Alternatively, one can use Spring's declarative transaction
      support, which essentially enables you to replace explicit transaction
      demarcation API calls in your Java code with an AOP transaction
      interceptor configured in a Spring container XML file. This allows you
      to keep business services free of repetitive transaction demarcation
      code, and allows you to focus on adding business logic which is where
      the real value of your application lies. Furthermore, transaction
      semantics like propagation behavior and isolation level can be changed
      in a configuration file and do not affect the business service
      implementations.</p><pre class="programlisting">&lt;beans&gt;
    ...

  &lt;bean id="myTxManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="proxyInterfaces" value="product.ProductService"/&gt;
    &lt;property name="target"&gt;
        &lt;bean class="product.DefaultProductService"&gt;
            &lt;property name="productDao" ref="myProductDao"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="interceptorNames"&gt;
      &lt;list&gt;
        &lt;value&gt;myTxInterceptor&lt;/value&gt; <i class="lineannotation"><span class="lineannotation">&lt;!-- the transaction interceptor (configured elsewhere) --&gt;</span></i>
      &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductServiceImpl implements ProductService {

    private ProductDao productDao;

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    <i class="lineannotation"><span class="lineannotation">// notice the absence of transaction demarcation code in this method </span></i>
    <i class="lineannotation"><span class="lineannotation">// Spring's declarative transaction infrastructure will be demarcating transactions on your behalf </span></i>
    public void increasePriceOfAllProductsInCategory(final String category) {
        List productsToChange = this.productDAO.loadProductsByCategory(category);
        ...
    }

    ...
}</pre><p>Spring's <tt class="classname">TransactionInterceptor</tt> allows any
      checked application exception to be thrown with the callback code, while
      <tt class="classname">TransactionTemplate</tt> is restricted to unchecked
      exceptions within the callback.
      <tt class="classname">TransactionTemplate</tt> will trigger a rollback in
      case of an unchecked application exception, or if the transaction has
      been marked rollback-only by the application (via
      <tt class="classname">TransactionStatus</tt>).
      <tt class="classname">TransactionInterceptor</tt> behaves the same way by
      default but allows configurable rollback policies per method.</p><p>The following higher level approach to declarative transactions
      doesn't use the <tt class="classname">ProxyFactoryBean</tt>, and as such may
      be easier to use if you have a large number of service objects that you
      wish to make transactional.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://static.springframework.org/spring/docs/2.0.x/images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>You are strongly encouraged to read the section entitled <a href="transaction.html#transaction-declarative" title="9.5.&nbsp;Declarative transaction management">Section&nbsp;9.5, &#8220;Declarative transaction management&#8221;</a> if you have not done so already
        prior to continuing.</p></td></tr></table></div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd"&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="interfacename">SessionFactory</tt>, <tt class="interfacename">DataSource</tt>, etc. omitted --&gt;</span></i>

  &lt;bean id="myTxManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;
  
  &lt;aop:config&gt;
    &lt;aop:pointcut id="productServiceMethods" expression="execution(* product.ProductService.*(..))"/&gt;
    &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="productServiceMethods"/&gt;
  &lt;/aop:config&gt;

  &lt;tx:advice id="txAdvice" transaction-manager="myTxManager"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="increasePrice*" propagation="REQUIRED"/&gt;
      &lt;tx:method name="someOtherBusinessMethod" propagation="REQUIRES_NEW"/&gt;
      &lt;tx:method name="*" propagation="SUPPORTS" read-only="true"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

  &lt;bean id="myProductService" class="product.SimpleProductService"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14925"></a>12.2.8.&nbsp;Transaction management strategies</h3></div></div><div></div></div><p>Both <tt class="classname">TransactionTemplate</tt> and
      <tt class="classname">TransactionInterceptor</tt> delegate the actual
      transaction handling to a
      <tt class="classname">PlatformTransactionManager</tt> instance, which can be
      a <tt class="classname">HibernateTransactionManager</tt> (for a single
      Hibernate <tt class="interfacename">SessionFactory</tt>, using a
      <tt class="classname">ThreadLocal</tt>
      <tt class="interfacename">Session</tt> under the hood) or a
      <tt class="classname">JtaTransactionManager</tt> (delegating to the JTA
      subsystem of the container) for Hibernate applications. You could even
      use a custom <tt class="classname">PlatformTransactionManager</tt>
      implementation. So switching from native Hibernate transaction
      management to JTA, i.e. when facing distributed transaction requirements
      for certain deployments of your application, is just a matter of
      configuration. Simply replace the Hibernate transaction manager with
      Spring's JTA transaction implementation. Both transaction demarcation
      and data access code will work without changes, as they just use the
      generic transaction management APIs.</p><p>For distributed transactions across multiple Hibernate session
      factories, simply combine <tt class="classname">JtaTransactionManager</tt>
      as a transaction strategy with multiple
      <tt class="classname">LocalSessionFactoryBean</tt> definitions. Each of your
      DAOs then gets one specific
      <tt class="interfacename">SessionFactory</tt> reference passed into its
      respective bean property. If all underlying JDBC data sources are
      transactional container ones, a business service can demarcate
      transactions across any number of DAOs and any number of session
      factories without special regard, as long as it is using
      <tt class="classname">JtaTransactionManager</tt> as the strategy.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myDataSource1" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName value="java:comp/env/jdbc/myds1"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myDataSource2" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="java:comp/env/jdbc/myds2"/&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory1" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="myDataSource1"/&gt;
    &lt;property name="mappingResources"&gt;
      &lt;list&gt;
        &lt;value&gt;product.hbm.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
      &lt;value&gt;
        hibernate.dialect=org.hibernate.dialect.MySQLDialect
        hibernate.show_sql=true
      &lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory2" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="myDataSource2"/&gt;
    &lt;property name="mappingResources"&gt;
      &lt;list&gt;
        &lt;value&gt;inventory.hbm.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
      &lt;value&gt;
        hibernate.dialect=org.hibernate.dialect.OracleDialect
      &lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="myTxManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory1"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myInventoryDao" class="product.InventoryDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory2"/&gt;
  &lt;/bean&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- this shows the Spring 1.x style of declarative transaction configuration --&gt;</span></i>
  <i class="lineannotation"><span class="lineannotation">&lt;!-- it is totally supported, 100% legal in Spring 2.x, but see also above for the sleeker, Spring 2.0 style --&gt;</span></i>
  &lt;bean id="myProductService"
      class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="target"&gt;
      &lt;bean class="product.ProductServiceImpl"&gt;
        &lt;property name="productDao" ref="myProductDao"/&gt;
        &lt;property name="inventoryDao" ref="myInventoryDao"/&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_REQUIRES_NEW&lt;/prop&gt;
        &lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Both <tt class="classname">HibernateTransactionManager</tt> and
      <tt class="classname">JtaTransactionManager</tt> allow for proper JVM-level
      cache handling with Hibernate - without container-specific transaction
      manager lookup or JCA connector (as long as not using EJB to initiate
      transactions).</p><p><tt class="classname">HibernateTransactionManager</tt> can export the
      JDBC <tt class="interfacename">Connection</tt> used by Hibernate to
      plain JDBC access code, for a specific
      <tt class="interfacename">DataSource</tt>. This allows for high-level
      transaction demarcation with mixed Hibernate/JDBC data access completely
      without JTA, as long as you are just accessing one database!
      <tt class="classname">HibernateTransactionManager</tt> will automatically
      expose the Hibernate transaction as JDBC transaction if the passed-in
      <tt class="interfacename">SessionFactory</tt> has been set up with a
      <tt class="interfacename">DataSource</tt> (through the "dataSource"
      property of the <tt class="classname">LocalSessionFactoryBean</tt> class).
      Alternatively, the <tt class="interfacename">DataSource</tt> that the
      transactions are supposed to be exposed for can also be specified
      explicitly, through the "dataSource" property of the
      <tt class="classname">HibernateTransactionManager</tt> class.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15015"></a>12.2.9.&nbsp;Container resources versus local resources</h3></div></div><div></div></div><p>Spring's resource management allows for simple switching between a
      JNDI <tt class="interfacename">SessionFactory</tt> and a local one,
      without having to change a single line of application code. The decision
      as to whether to keep the resource definitions in the container or
      locally within the application, is mainly a matter of the transaction
      strategy being used. Compared to a Spring-defined local
      <tt class="interfacename">SessionFactory</tt>, a manually registered
      JNDI <tt class="interfacename">SessionFactory</tt> does not provide any
      benefits. Deploying a <tt class="interfacename">SessionFactory</tt>
      through Hibernate's JCA connector provides the added value of
      participating in the J2EE server's management infrastructure, but does
      not add actual value beyond that.</p><p>An important benefit of Spring's transaction support is that it
      isn't bound to a container at all. Configured to any other strategy than
      JTA, it will work in a standalone or test environment too. Especially
      for the typical case of single-database transactions, this is a very
      lightweight and powerful alternative to JTA. When using local EJB
      Stateless Session Beans to drive transactions, you depend both on an EJB
      container and JTA - even if you just access a single database anyway,
      and just use SLSBs for declarative transactions via CMT. The alternative
      of using JTA programmatically requires a J2EE environment as well. JTA
      does not just involve container dependencies in terms of JTA itself and
      of JNDI <tt class="interfacename">DataSource</tt> instances. For
      non-Spring JTA-driven Hibernate transactions, you have to use the
      Hibernate JCA connector, or extra Hibernate transaction code with the
      TransactionManagerLookup being configured - for proper JVM-level
      caching.</p><p>Spring-driven transactions can work with a locally defined
      Hibernate <tt class="interfacename">SessionFactory</tt> nicely, just
      like with a local JDBC <tt class="interfacename">DataSource</tt> - if
      accessing a single database, of course. Therefore you just have to fall
      back to Spring's JTA transaction strategy when actually facing
      distributed transaction requirements. Note that a JCA connector needs
      container-specific deployment steps, and obviously JCA support in the
      first place. This is far more hassle than deploying a simple web app
      with local resource definitions and Spring-driven transactions. And you
      often need the Enterprise Edition of your container, as e.g. WebLogic
      Express does not provide JCA. A Spring application with local resources
      and transactions spanning one single database will work in any J2EE web
      container (without JTA, JCA, or EJB) - like Tomcat, Resin, or even plain
      Jetty. Additionally, such a middle tier can be reused in desktop
      applications or test suites easily.</p><p>All things considered: if you do not use EJB, stick with local
      <tt class="interfacename">SessionFactory</tt> setup and Spring's
      <tt class="classname">HibernateTransactionManager</tt> or
      <tt class="classname">JtaTransactionManager</tt>. You will get all of the
      benefits including proper transactional JVM-level caching and
      distributed transactions, without any container deployment hassle. JNDI
      registration of a Hibernate
      <tt class="interfacename">SessionFactory</tt> via the JCA connector
      really only adds value when used in conjunction with EJBs.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-invalid-jdbc-access-error"></a>12.2.10.&nbsp;Spurious application server warnings when using Hibernate</h3></div></div><div></div></div><p>In some JTA environments with very strict XADataSource
      implementations -- currently only some WebLogic and WebSphere versions
      -- when using Hibernate configured without any awareness of the JTA
      <tt class="interfacename">PlatformTransactionManager</tt> object for
      that environment, it is possible for spurious warning or exceptions to
      show up in the application server log. These warnings or exceptions will
      say something to the effect that the connection being accessed is no
      longer valid, or JDBC access is no longer valid, possibly because the
      transaction is no longer active. As an example, here is an actual
      exception from WebLogic:</p><pre class="programlisting">java.sql.SQLException: The transaction is no longer active - status: 'Committed'.
   No further JDBC access is allowed within this transaction.</pre><p>This warning is easy to resolve by simply making Hibernate aware
      of the JTA <tt class="interfacename">PlatformTransactionManager</tt>
      instance, to which it will also synchronize (along with Spring). This
      may be done in two ways:</p><div class="itemizedlist"><ul type="disc"><li><p>If in your application context you are already directly
          obtaining the JTA
          <tt class="interfacename">PlatformTransactionManager</tt> object
          (presumably from JNDI via <tt class="literal">JndiObjectFactoryBean</tt>)
          and feeding it for example to Spring's
          <tt class="classname">JtaTransactionManager</tt>, then the easiest way
          is to simply specify a reference to this as the value of
          <tt class="classname">LocalSessionFactoryBean</tt>'s
          <span class="emphasis"><em>jtaTransactionManager</em></span> property. Spring will
          then make the object available to Hibernate.</p></li><li><p>More likely you do not already have the JTA
          <tt class="interfacename">PlatformTransactionManager</tt> instance
          (since Spring's <tt class="classname">JtaTransactionManager</tt> can
          find it itself) so you need to instead configure Hibernate to also
          look it up directly. This is done by configuring an AppServer
          specific <tt class="literal">TransactionManagerLookup</tt> class in the
          Hibernate configuration, as described in the Hibernate
          manual.</p></li></ul></div><p>It is not necessary to read any more for proper usage, but the
      full sequence of events with and without Hibernate being aware of the
      JTA <tt class="interfacename">PlatformTransactionManager</tt> will now
      be described.</p><p>When Hibernate is not configured with any awareness of the JTA
      <tt class="interfacename">PlatformTransactionManager</tt>, the sequence
      of events when a JTA transaction commits is as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>JTA transaction commits</p></li><li><p>Spring's <tt class="classname">JtaTransactionManager</tt> is
          synchronized to the JTA transaction, so it is called back via an
          <span class="emphasis"><em>afterCompletion</em></span> callback by the JTA transaction
          manager.</p></li><li><p>Among other activities, this can trigger a callback by Spring
          to Hibernate, via Hibernate's
          <tt class="literal">afterTransactionCompletion</tt> callback (used to
          clear the Hibernate cache), followed by an explicit
          <tt class="literal">close()</tt> call on the Hibernate Session, which
          results in Hibernate trying to <tt class="literal">close()</tt> the JDBC
          Connection.</p></li><li><p>In some environments, this
          <tt class="literal">Connection.close()</tt> call then triggers the warning
          or error, as the application server no longer considers the
          Connection usable at all, since the transaction has already been
          committed.</p></li></ul></div><p>When Hibernate is configured with awareness of the JTA
      <tt class="interfacename">PlatformTransactionManager</tt>, the sequence
      of events when a JTA transaction commits is instead as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>JTA transaction is ready to commit</p></li><li><p>Spring's <tt class="classname">JtaTransactionManager</tt> is
          synchronized to the JTA transaction, so it is called back via a
          <span class="emphasis"><em>beforeCompletion</em></span> callback by the JTA
          transaction manager.</p></li><li><p>Spring is aware that Hibernate itself is synchronized to the
          JTA Transaction, and behaves differently than in the previous
          scenario. Assuming the Hibernate
          <tt class="interfacename">Session</tt> needs to be closed at all,
          Spring will close it now.</p></li><li><p>JTA Transaction commits</p></li><li><p>Hibernate is synchronized to the JTA transaction, so it is
          called back via an <span class="emphasis"><em>afterCompletion</em></span> callback by
          the JTA transaction manager, and can properly clear its
          cache.</p></li></ul></div><p></p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-jdo"></a>12.3.&nbsp;JDO</h2></div></div><div></div></div><p>Spring supports the standard JDO 1.0/2.0 API as data access
    strategy, following the same style as the Hibernate support. The
    corresponding integration classes reside in the
    <tt class="literal">org.springframework.orm.jdo</tt> package.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15188"></a>12.3.1.&nbsp;PersistenceManagerFactory setup</h3></div></div><div></div></div><p>Spring provides a
      <tt class="classname">LocalPersistenceManagerFactoryBean</tt> class that
      allows for defining a local JDO
      <tt class="interfacename">PersistenceManagerFactory</tt> within a Spring
      application context:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myPmf" class="org.springframework.orm.jdo.LocalPersistenceManagerFactoryBean"&gt;
    &lt;property name="configLocation" value="classpath:kodo.properties"/&gt;
  &lt;/bean&gt;
    
  ...
&lt;/beans&gt;</pre><p>Alternatively, a
      <tt class="interfacename">PersistenceManagerFactory</tt> can also be set
      up through direct instantiation of a
      <tt class="interfacename">PersistenceManagerFactory</tt> implementation
      class. A JDO <tt class="interfacename">PersistenceManagerFactory</tt>
      implementation class is supposed to follow the JavaBeans pattern, just
      like a JDBC <tt class="interfacename">DataSource</tt> implementation
      class, which is a natural fit for a Spring bean definition. This setup
      style usually supports a Spring-defined JDBC
      <tt class="interfacename">DataSource</tt>, passed into the
      "connectionFactory" property. For example, for the open source JDO
      implementation JPOX (<a href="http://www.jpox.org/" target="_top">http://www.jpox.org</a>):</p><pre class="programlisting">&lt;beans&gt;

 &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
   &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
   &lt;property name="url" value="${jdbc.url}"/&gt;
   &lt;property name="username" value="${jdbc.username}"/&gt;
   &lt;property name="password" value="${jdbc.password}"/&gt;
 &lt;/bean&gt;

 &lt;bean id="myPmf" class="org.jpox.PersistenceManagerFactoryImpl" destroy-method="close"&gt;
   &lt;property name="connectionFactory" ref="dataSource"/&gt;
   &lt;property name="nontransactionalRead" value="true"/&gt;
 &lt;/bean&gt;
   
 ...
&lt;/beans&gt;</pre><p>A JDO <tt class="interfacename">PersistenceManagerFactory</tt> can
      also be set up in the JNDI environment of a J2EE application server,
      usually through the JCA connector provided by the particular JDO
      implementation. Spring's standard
      <tt class="literal">JndiObjectFactoryBean</tt> can be used to retrieve and
      expose such a <tt class="interfacename">PersistenceManagerFactory</tt>.
      However, outside an EJB context, there is often no compelling benefit in
      holding the <tt class="interfacename">PersistenceManagerFactory</tt> in
      JNDI: only choose such setup for a good reason. See "container resources
      versus local resources" in the Hibernate section for a discussion; the
      arguments there apply to JDO as well.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15236"></a>12.3.2.&nbsp;<tt class="classname">JdoTemplate</tt> and
      <tt class="classname">JdoDaoSupport</tt></h3></div></div><div></div></div><p>Each JDO-based DAO will then receive the
      <tt class="interfacename">PersistenceManagerFactory</tt> through
      dependency injection, i.e. through a bean property setter or through a
      constructor argument. Such a DAO could be coded against plain JDO API,
      working with the given
      <tt class="interfacename">PersistenceManagerFactory</tt>, but will
      usually rather be used with Spring's
      <tt class="classname">JdoTemplate</tt>:</p><pre class="programlisting">&lt;beans&gt;
  ...
  
  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;
  
&lt;/beans&gt;</pre><pre class="programlisting">public class ProductDaoImpl implements ProductDao {
  
    private PersistenceManagerFactory persistenceManagerFactory;

    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        this.persistenceManagerFactory = pmf;
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        JdoTemplate jdoTemplate = new JdoTemplate(this.persistenceManagerFactory);
        return (Collection) jdoTemplate.execute(new JdoCallback() {
            public Object doInJdo(PersistenceManager pm) throws JDOException {
                Query query = pm.newQuery(Product.class, "category = pCategory");
                query.declareParameters("String pCategory"); 
                List result = query.execute(category);
                // do some further stuff with the result list
                return result;
            }
        });
    }
}</pre><p>A callback implementation can effectively be used for any JDO data
      access. <tt class="classname">JdoTemplate</tt> will ensure that
      <tt class="classname">PersistenceManager</tt>s are properly opened and
      closed, and automatically participate in transactions. The template
      instances are thread-safe and reusable, they can thus be kept as
      instance variables of the surrounding class. For simple single-step
      actions such as a single <tt class="literal">find</tt>,
      <tt class="literal">load</tt>, <tt class="literal">makePersistent</tt>, or
      <tt class="literal">delete</tt> call, <tt class="classname">JdoTemplate</tt>
      offers alternative convenience methods that can replace such one line
      callback implementations. Furthermore, Spring provides a convenient
      <tt class="classname">JdoDaoSupport</tt> base class that provides a
      <tt class="literal">setPersistenceManagerFactory(..)</tt> method for receiving
      a <tt class="classname">PersistenceManagerFactory</tt>, and
      <tt class="literal">getPersistenceManagerFactory()</tt> and
      <tt class="literal">getJdoTemplate()</tt> for use by subclasses. In
      combination, this allows for very simple DAO implementations for typical
      requirements:</p><pre class="programlisting">public class ProductDaoImpl extends JdoDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) throws DataAccessException {
        return getJdoTemplate().find(
            Product.class, "category = pCategory", "String category", new Object[] {category});
    }
}</pre><p>As alternative to working with Spring's
      <tt class="classname">JdoTemplate</tt>, you can also code Spring-based DAOs
      at the JDO API level, explicitly opening and closing a
      <tt class="interfacename">PersistenceManager</tt>. As elaborated in the
      corresponding Hibernate section, the main advantage of this approach is
      that your data access code is able to throw checked exceptions.
      <tt class="classname">JdoDaoSupport</tt> offers a variety of support methods
      for this scenario, for fetching and releasing a transactional
      <tt class="interfacename">PersistenceManager</tt> as well as for
      converting exceptions.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15312"></a>12.3.3.&nbsp;Implementing DAOs based on plain JDO API</h3></div></div><div></div></div><p>DAOs can also be written against plain JDO API, without any Spring
      dependencies, directly using an injected
      <tt class="interfacename">PersistenceManagerFactory</tt>. A
      corresponding DAO implementation looks like as follows:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private PersistenceManagerFactory persistenceManagerFactory;

    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        this.persistenceManagerFactory = pmf;
    }

    public Collection loadProductsByCategory(String category) {
        PersistenceManager pm = this.persistenceManagerFactory.getPersistenceManager();
        try {
            Query query = pm.newQuery(Product.class, "category = pCategory");
            query.declareParameters("String pCategory"); 
            return query.execute(category);
        }
        finally {
          pm.close();
        }
    }
}</pre><p>As the above DAO still follows the Dependency Injection pattern,
      it still fits nicely into a Spring application context, just like it
      would if coded against Spring's
      <tt class="classname">JdoTemplate</tt>:</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The main issue with such DAOs is that they always get a new
      <tt class="interfacename">PersistenceManager</tt> from the factory. To
      still access a Spring-managed transactional
      <tt class="interfacename">PersistenceManager</tt>, consider defining a
      <tt class="classname">TransactionAwarePersistenceManagerFactoryProxy</tt>
      (as included in Spring) in front of your target
      <tt class="interfacename">PersistenceManagerFactory</tt>, passing the
      proxy into your DAOs.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myPmfProxy"
      class="org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy"&gt;
    &lt;property name="targetPersistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmfProxy"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</pre><p>Your data access code will then receive a transactional
      <tt class="interfacename">PersistenceManager</tt> (if any) from the
      <tt class="literal">PersistenceManagerFactory.getPersistenceManager()</tt>
      method that it calls. The latter method call goes through the proxy,
      which will first check for a current transactional
      <tt class="interfacename">PersistenceManager</tt> before getting a new
      one from the factory. <tt class="literal">close()</tt> calls on the
      <tt class="interfacename">PersistenceManager</tt> will be ignored in
      case of a transaction
      <tt class="interfacename">PersistenceManager</tt>.</p><p>If your data access code will always run within an active
      transaction (or at least within active transaction synchronization), it
      is safe to omit the <tt class="literal">PersistenceManager.close()</tt> call
      and thus the entire <tt class="literal">finally</tt> block, which you might
      prefer to keep your DAO implementations concise:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private PersistenceManagerFactory persistenceManagerFactory;

    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        this.persistenceManagerFactory = pmf;
    }

    public Collection loadProductsByCategory(String category) {
        PersistenceManager pm = this.persistenceManagerFactory.getPersistenceManager();
        Query query = pm.newQuery(Product.class, "category = pCategory");
        query.declareParameters("String pCategory"); 
        return query.execute(category);
    }
}</pre><p>With such DAOs that rely on active transactions, it is recommended
      to enforce active transactions through turning
      <tt class="classname">TransactionAwarePersistenceManagerFactoryProxy</tt>'s
      "allowCreate" flag off:</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myPmfProxy"
      class="org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy"&gt;
    &lt;property name="targetPersistenceManagerFactory" ref="myPmf"/&gt;
    &lt;property name="allowCreate" value="false"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmfProxy"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</pre><p>The main advantage of this DAO style is that it depends on JDO API
      only; no import of any Spring class is required. This is of course
      appealing from a non-invasiveness perspective, and might feel more
      natural to JDO developers.</p><p>However, the DAO throws plain <tt class="literal">JDOException</tt>
      (which is unchecked, so does not have to be declared or caught), which
      means that callers can only treat exceptions as generally fatal - unless
      they want to depend on JDO's own exception structure. Catching specific
      causes such as an optimistic locking failure is not possible without
      tying the caller to the implementation strategy. This tradeoff might be
      acceptable to applications that are strongly JDO-based and/or do not
      need any special exception treatment.</p><p>In summary: DAOs can be implemented based on plain JDO API, while
      still being able to participate in Spring-managed transactions. This
      might in particular appeal to people already familiar with JDO, feeling
      more natural to them. However, such DAOs will throw plain
      <tt class="classname">JDOException</tt>; conversion to Spring's
      <tt class="classname">DataAccessException</tt> would have to happen
      explicitly (if desired).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15397"></a>12.3.4.&nbsp;Transaction management</h3></div></div><div></div></div><p>To execute service operations within transactions, you can use
      Spring's common declarative transaction facilities. For example:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans
        xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:aop="http://www.springframework.org/schema/aop"
        xmlns:tx="http://www.springframework.org/schema/tx"
        xsi:schemaLocation="
   http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd
   http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd"&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.jdo.JdoTransactionManager"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

  &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="increasePrice*" propagation="REQUIRED"/&gt;
      &lt;tx:method name="someOtherBusinessMethod" propagation="REQUIRES_NEW"/&gt;
      &lt;tx:method name="*" propagation="SUPPORTS" read-only="true"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

  &lt;aop:config&gt;
    &lt;aop:pointcut id="productServiceMethods" expression="execution(* product.ProductService.*(..))"/&gt;
    &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="productServiceMethods"/&gt;
  &lt;/aop:config&gt;

&lt;/beans&gt;</pre><p>Note that JDO requires an active transaction when modifying a
      persistent object. There is no concept like a non-transactional flush in
      JDO, in contrast to Hibernate. For this reason, the chosen JDO
      implementation needs to be set up for a specific environment: in
      particular, it needs to be explicitly set up for JTA synchronization, to
      detect an active JTA transaction itself. This is not necessary for local
      transactions as performed by Spring's
      <tt class="classname">JdoTransactionManager</tt>, but it is necessary for
      participating in JTA transactions (whether driven by Spring's
      <tt class="classname">JtaTransactionManager</tt> or by EJB CMT / plain
      JTA).</p><p><tt class="classname">JdoTransactionManager</tt> is capable of
      exposing a JDO transaction to JDBC access code that accesses the same
      JDBC <tt class="interfacename">DataSource</tt>, provided that the
      registered <tt class="classname">JdoDialect</tt> supports retrieval of the
      underlying JDBC <tt class="interfacename">Connection</tt>. This is by
      default the case for JDBC-based JDO 2.0 implementations; for JDO 1.0
      implementations, a custom <tt class="classname">JdoDialect</tt> needs to be
      used. See next section for details on the
      <tt class="classname">JdoDialect</tt> mechanism.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15431"></a>12.3.5.&nbsp;JdoDialect</h3></div></div><div></div></div><p>As an advanced feature, both <tt class="classname">JdoTemplate</tt>
      and <tt class="classname">JdoTransactionManager</tt> support a custom
      <tt class="classname">JdoDialect</tt>, to be passed into the "jdoDialect"
      bean property. In such a scenario, the DAOs won't receive a
      <tt class="interfacename">PersistenceManagerFactory</tt> reference but
      rather a full <tt class="classname">JdoTemplate</tt> instance instead (for
      example, passed into <tt class="classname">JdoDaoSupport</tt>'s
      "jdoTemplate" property). A <tt class="classname">JdoDialect</tt>
      implementation can enable some advanced features supported by Spring,
      usually in a vendor-specific manner:</p><div class="itemizedlist"><ul type="disc"><li><p>applying specific transaction semantics (such as custom
          isolation level or transaction timeout)</p></li><li><p>retrieving the transactional JDBC
          <tt class="interfacename">Connection</tt> (for exposure to
          JDBC-based DAOs)</p></li><li><p>applying query timeouts (automatically calculated from
          Spring-managed transaction timeout)</p></li><li><p>eagerly flushing a
          <tt class="interfacename">PersistenceManager</tt> (to make
          transactional changes visible to JDBC-based data access code)</p></li><li><p>advanced translation of <tt class="literal">JDOExceptions</tt> to
          Spring <tt class="literal">DataAccessExceptions</tt></p></li></ul></div><p>This is particularly valuable for JDO 1.0 implementations, where
      none of those features are covered by the standard API. On JDO 2.0, most
      of those features are supported in a standard manner: Hence, Spring's
      <tt class="literal">DefaultJdoDialect</tt> uses the corresponding JDO 2.0 API
      methods by default (as of Spring 1.2). For special transaction semantics
      and for advanced translation of exception, it is still valuable to
      derive vendor-specific <tt class="classname">JdoDialect</tt>
      subclasses.</p><p>See the <tt class="classname">JdoDialect</tt> Javadoc for more details
      on its operations and how they are used within Spring's JDO
      support.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-toplink"></a>12.4.&nbsp;Oracle TopLink</h2></div></div><div></div></div><p>Since Spring 1.2, Spring supports Oracle TopLink (<a href="http://www.oracle.com/technology/products/ias/toplink" target="_top">http://www.oracle.com/technology/products/ias/toplink</a>) as
    data access strategy, following the same style as the Hibernate support.
    Both TopLink 9.0.4 (the production version as of Spring 1.2) and 10.1.3
    (still in beta as of Spring 1.2) are supported. The corresponding
    integration classes reside in the
    <tt class="literal">org.springframework.orm.toplink</tt> package.</p><p>Spring's TopLink support has been co-developed with the Oracle
    TopLink team. Many thanks to the TopLink team, in particular to Jim Clark
    who helped to clarify details in all areas!</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15509"></a>12.4.1.&nbsp;<tt class="interfacename">SessionFactory</tt> abstraction</h3></div></div><div></div></div><p>TopLink itself does not ship with a SessionFactory abstraction.
      Instead, multi-threaded access is based on the concept of a central
      <tt class="literal">ServerSession</tt>, which in turn is able to spawn
      <tt class="literal">ClientSession</tt> instances for single-threaded usage.
      For flexible setup options, Spring defines a
      <tt class="interfacename">SessionFactory</tt> abstraction for TopLink,
      enabling to switch between different
      <tt class="interfacename">Session</tt> creation strategies.</p><p>As a one-stop shop, Spring provides a
      <tt class="classname">LocalSessionFactoryBean</tt> class that allows for
      defining a TopLink <tt class="interfacename">SessionFactory</tt> with
      bean-style configuration. It needs to be configured with the location of
      the TopLink session configuration file, and usually also receives a
      Spring-managed JDBC <tt class="interfacename">DataSource</tt> to
      use.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory" class="org.springframework.orm.toplink.LocalSessionFactoryBean"&gt;
    &lt;property name="configLocation" value="toplink-sessions.xml"/&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;
    
  ...
&lt;/beans&gt;</pre><pre class="programlisting">&lt;toplink-configuration&gt;

  &lt;session&gt;
    &lt;name&gt;Session&lt;/name&gt;
    &lt;project-xml&gt;toplink-mappings.xml&lt;/project-xml&gt;
    &lt;session-type&gt;
      &lt;server-session/&gt;
    &lt;/session-type&gt;
    &lt;enable-logging&gt;true&lt;/enable-logging&gt;
    &lt;logging-options/&gt;
  &lt;/session&gt;

&lt;/toplink-configuration&gt;</pre><p>Usually, <tt class="classname">LocalSessionFactoryBean</tt> will hold
      a multi-threaded TopLink <tt class="literal">ServerSession</tt> underneath and
      create appropriate client <tt class="interfacename">Session</tt>s for
      it: either a plain <tt class="interfacename">Session</tt> (typical), a
      managed <tt class="literal">ClientSession</tt>, or a transaction-aware
      <tt class="interfacename">Session</tt> (the latter are mainly used
      internally by Spring's TopLink support). It might also hold a
      single-threaded TopLink <tt class="literal">DatabaseSession</tt>; this is
      rather unusual, though.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15566"></a>12.4.2.&nbsp;<tt class="classname">TopLinkTemplate</tt> and
      <tt class="classname">TopLinkDaoSupport</tt></h3></div></div><div></div></div><p>Each TopLink-based DAO will then receive the
      <tt class="interfacename">SessionFactory</tt> through dependency
      injection, i.e. through a bean property setter or through a constructor
      argument. Such a DAO could be coded against plain TopLink API, fetching
      a <tt class="interfacename">Session</tt> from the given
      <tt class="interfacename">SessionFactory</tt>, but will usually rather
      be used with Spring's <tt class="literal">TopLinkTemplate</tt>:</p><pre class="programlisting">&lt;beans&gt;
  ...
  
  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;
  
&lt;/beans&gt;</pre><pre class="programlisting">public class ProductDaoImpl implements ProductDao {
  
    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        TopLinkTemplate tlTemplate = new TopLinkTemplate(this.sessionFactory);
        return (Collection) tlTemplate.execute(new TopLinkCallback() {
            public Object doInTopLink(Session session) throws TopLinkException {
                ReadAllQuery findOwnersQuery = new ReadAllQuery(Product.class);
                findOwnersQuery.addArgument("Category");
                ExpressionBuilder builder = this.findOwnersQuery.getExpressionBuilder();
                findOwnersQuery.setSelectionCriteria(
                    builder.get("category").like(builder.getParameter("Category")));

                Vector args = new Vector();
                args.add(category);
                List result = session.executeQuery(findOwnersQuery, args);
                // do some further stuff with the result list
                return result;
            }
        });
    }
}</pre><p>A callback implementation can effectively be used for any TopLink
      data access. <tt class="classname">TopLinkTemplate</tt> will ensure that
      <tt class="interfacename">Session</tt>s are properly opened and closed,
      and automatically participate in transactions. The template instances
      are thread-safe and reusable, they can thus be kept as instance
      variables of the surrounding class. For simple single-step actions such
      as a single <tt class="literal">executeQuery</tt>, <tt class="literal">readAll</tt>,
      <tt class="literal">readById</tt>, or <tt class="literal">merge</tt> call,
      <tt class="classname">JdoTemplate</tt> offers alternative convenience
      methods that can replace such one line callback implementations.
      Furthermore, Spring provides a convenient
      <tt class="classname">TopLinkDaoSupport</tt> base class that provides a
      <tt class="literal">setSessionFactory(..)</tt> method for receiving a
      <tt class="interfacename">SessionFactory</tt>, and
      <tt class="literal">getSessionFactory()</tt> and
      <tt class="literal">getTopLinkTemplate()</tt> for use by subclasses. In
      combination, this allows for simple DAO implementations for typical
      requirements:</p><pre class="programlisting">public class ProductDaoImpl extends TopLinkDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) throws DataAccessException {
        ReadAllQuery findOwnersQuery = new ReadAllQuery(Product.class);
        findOwnersQuery.addArgument("Category");
        ExpressionBuilder builder = this.findOwnersQuery.getExpressionBuilder();
        findOwnersQuery.setSelectionCriteria(
            builder.get("category").like(builder.getParameter("Category")));

        return getTopLinkTemplate().executeQuery(findOwnersQuery, new Object[] {category});
    }
}&lt;/programlisting&gt;</pre><p>Side note: TopLink query objects are thread-safe and can be cached
      within the DAO, i.e. created on startup and kept in instance
      variables.</p><p>As alternative to working with Spring's
      <tt class="literal">TopLinkTemplate</tt>, you can also code your TopLink data
      access based on the raw TopLink API, explicitly opening and closing a
      <tt class="interfacename">Session</tt>. As elaborated in the
      corresponding Hibernate section, the main advantage of this approach is
      that your data access code is able to throw checked exceptions.
      <tt class="literal">TopLinkDaoSupport</tt> offers a variety of support methods
      for this scenario, for fetching and releasing a transactional
      <tt class="interfacename">Session</tt> as well as for converting
      exceptions.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15647"></a>12.4.3.&nbsp;Implementing DAOs based on plain TopLink API</h3></div></div><div></div></div><p>DAOs can also be written against plain TopLink API, without any
      Spring dependencies, directly using an injected TopLink
      <tt class="interfacename">Session</tt>. The latter will usually be based
      on a <tt class="interfacename">SessionFactory</tt> defined by a
      <tt class="classname">LocalSessionFactoryBean</tt>, exposed for bean
      references of type <tt class="interfacename">Session</tt> through
      Spring's <tt class="literal">TransactionAwareSessionAdapter</tt>.</p><p>The <tt class="literal">getActiveSession()</tt> method defined on
      TopLink's <tt class="interfacename">Session</tt> interface will return
      the current transactional <tt class="interfacename">Session</tt> in such
      a scenario. If there is no active transaction, it will return the shared
      TopLink <tt class="literal">ServerSession</tt> as-is, which is only supposed
      to be used directly for read-only access. There is also an analogous
      <tt class="literal">getActiveUnitOfWork()</tt> method, returning the TopLink
      <tt class="literal">UnitOfWork</tt> associated with the current transaction,
      if any (returning null else).</p><p>A corresponding DAO implementation looks like as follows:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private Session session;

    public void setSession(Session session) {
        this.session = session;
    }

    public Collection loadProductsByCategory(String category) {
        ReadAllQuery findOwnersQuery = new ReadAllQuery(Product.class);
        findOwnersQuery.addArgument("Category");
        ExpressionBuilder builder = this.findOwnersQuery.getExpressionBuilder();
        findOwnersQuery.setSelectionCriteria(
            builder.get("category").like(builder.getParameter("Category")));

        Vector args = new Vector();
        args.add(category);
        return session.getActiveSession().executeQuery(findOwnersQuery, args);
    }
}</pre><p>As the above DAO still follows the Dependency Injection pattern,
      it still fits nicely into a Spring application context, analogous to
      like it would if coded against Spring's
      <tt class="literal">TopLinkTemplate</tt>. Spring's
      <tt class="literal">TransactionAwareSessionAdapter</tt> is used to expose a
      bean reference of type <tt class="interfacename">Session</tt>, to be
      passed into the DAO:</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="mySessionAdapter"
      class="org.springframework.orm.toplink.support.TransactionAwareSessionAdapter"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="session" ref="mySessionAdapter"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</pre><p>The main advantage of this DAO style is that it depends on TopLink
      API only; no import of any Spring class is required. This is of course
      appealing from a non-invasiveness perspective, and might feel more
      natural to TopLink developers.</p><p>However, the DAO throws plain <tt class="literal">TopLinkException</tt>
      (which is unchecked, so does not have to be declared or caught), which
      means that callers can only treat exceptions as generally fatal - unless
      they want to depend on TopLink's own exception structure. Catching
      specific causes such as an optimistic locking failure is not possible
      without tying the caller to the implementation strategy. This tradeoff
      might be acceptable to applications that are strongly TopLink-based
      and/or do not need any special exception treatment.</p><p>A further disadvantage of that DAO style is that TopLink's
      standard <tt class="literal">getActiveSession()</tt> feature just works within
      JTA transactions. It does not work with any other transaction strategy
      out-of-the-box, in particular not with local TopLink
      transactions.</p><p>Fortunately, Spring's
      <tt class="literal">TransactionAwareSessionAdapter</tt> exposes a
      corresponding proxy for the TopLink <tt class="literal">ServerSession</tt>
      which supports TopLink's <tt class="literal">Session.getActiveSession()</tt>
      and <tt class="literal">Session.getActiveUnitOfWork()</tt> methods for any
      Spring transaction strategy, returning the current Spring-managed
      transactional <tt class="interfacename">Session</tt> even with
      <tt class="literal">TopLinkTransactionManager</tt>. Of course, the standard
      behavior of that method remains: returning the current
      <tt class="interfacename">Session</tt> associated with the ongoing JTA
      transaction, if any (no matter whether driven by Spring's
      <tt class="classname">JtaTransactionManager</tt>, by EJB CMT, or by plain
      JTA).</p><p>In summary: DAOs can be implemented based on plain TopLink API,
      while still being able to participate in Spring-managed transactions.
      This might in particular appeal to people already familiar with TopLink,
      feeling more natural to them. However, such DAOs will throw plain
      <tt class="literal">TopLinkException</tt>; conversion to Spring's
      <tt class="classname">DataAccessException</tt> would have to happen
      explicitly (if desired).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15750"></a>12.4.4.&nbsp;Transaction management</h3></div></div><div></div></div><p>To execute service operations within transactions, you can use
      Spring's common declarative transaction facilities. For example:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans
        xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:aop="http://www.springframework.org/schema/aop"
        xmlns:tx="http://www.springframework.org/schema/tx"
        xsi:schemaLocation="
   http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd
   http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd"&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.toplink.TopLinkTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;
  
  &lt;aop:config&gt;
    &lt;aop:pointcut id="productServiceMethods" expression="execution(* product.ProductService.*(..))"/&gt;
    &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="productServiceMethods"/&gt;
  &lt;/aop:config&gt;

  &lt;tx:advice id="txAdvice" transaction-manager="myTxManager"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="increasePrice*" propagation="REQUIRED"/&gt;
      &lt;tx:method name="someOtherBusinessMethod" propagation="REQUIRES_NEW"/&gt;
      &lt;tx:method name="*" propagation="SUPPORTS" read-only="true"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

&lt;/beans&gt;</pre><p>Note that TopLink requires an active <tt class="literal">UnitOfWork</tt>
      for modifying a persistent object. (You should never modify objects
      returned by a plain TopLink <tt class="interfacename">Session</tt> -
      those are usually read-only objects, directly taken from the
      second-level cache!) There is no concept like a non-transactional flush
      in TopLink, in contrast to Hibernate. For this reason, TopLink needs to
      be set up for a specific environment: in particular, it needs to be
      explicitly set up for JTA synchronization, to detect an active JTA
      transaction itself and expose a corresponding active
      <tt class="interfacename">Session</tt> and
      <tt class="literal">UnitOfWork</tt>. This is not necessary for local
      transactions as performed by Spring's
      <tt class="literal">TopLinkTransactionManager</tt>, but it is necessary for
      participating in JTA transactions (whether driven by Spring's
      <tt class="classname">JtaTransactionManager</tt> or by EJB CMT / plain
      JTA).</p><p>Within your TopLink-based DAO code, use the
      <tt class="literal">Session.getActiveUnitOfWork()</tt> method to access the
      current <tt class="literal">UnitOfWork</tt> and perform write operations
      through it. This will only work within an active transaction (both
      within Spring-managed transactions and plain JTA transactions). For
      special needs, you can also acquire separate
      <tt class="literal">UnitOfWork</tt> instances that won't participate in the
      current transaction; this is hardly needed, though.</p><p><tt class="literal">TopLinkTransactionManager</tt> is capable of
      exposing a TopLink transaction to JDBC access code that accesses the
      same JDBC <tt class="interfacename">DataSource</tt>, provided that
      TopLink works with JDBC in the backend and is thus able to expose the
      underlying JDBC <tt class="interfacename">Connection</tt>. The
      <tt class="interfacename">DataSource</tt> to expose the transactions for
      needs to be specified explicitly; it won't be autodetected.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-ibatis"></a>12.5.&nbsp;iBATIS SQL Maps</h2></div></div><div></div></div><p>Through the <tt class="literal">org.springframework.orm.ibatis</tt>
    package, Spring supports iBATIS SQL Maps 1.x and 2.x (<a href="http://www.ibatis.com/" target="_top">http://www.ibatis.com</a>). The iBATIS support much resembles
    the JDBC / Hibernate support in that it supports the same template style
    programming and just as with JDBC or Hibernate, the iBATIS support works
    with Spring's exception hierarchy and let's you enjoy the all IoC features
    Spring has.</p><p>Transaction management can be handled through Spring's standard
    facilities. There are no special transaction strategies for iBATIS, as
    there is no special transactional resource involved other than a JDBC
    <tt class="interfacename">Connection</tt>. Hence, Spring's standard JDBC
    <tt class="classname">DataSourceTransactionManager</tt> or
    <tt class="classname">JtaTransactionManager</tt> are perfectly
    sufficient.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15822"></a>12.5.1.&nbsp;Overview and differences between iBATIS 1.x and 2.x</h3></div></div><div></div></div><p>Spring supports both iBATIS SQL Maps 1.x and 2.x. First let's have
      a look at the differences between the two.</p><p>The XML config files have changed a bit, node and attribute names.
      Also the Spring classes you need to extend are different, as are some
      method names.</p><div class="table"><a name="d0e15829"></a><p class="title"><b>Table&nbsp;12.1.&nbsp;iBATIS SQL Maps supporting classes for 1.x and 2.x</b></p><table summary="iBATIS SQL Maps supporting classes for 1.x and 2.x" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Feature</th><th>1.x</th><th>2.x</th></tr></thead><tbody><tr><td>Creation of SqlMap(Client)</td><td><tt class="classname">SqlMapFactoryBean</tt></td><td><tt class="literal">SqlMapClientFactoryBean</tt></td></tr><tr><td>Template-style helper class</td><td><tt class="classname">SqlMapTemplate</tt></td><td><tt class="classname">SqlMapClientTemplate</tt></td></tr><tr><td>Callback to use MappedStatement</td><td><tt class="interfacename">SqlMapCallback</tt></td><td><tt class="literal">SqlMapClientCallback</tt></td></tr><tr><td>Super class for DAOs</td><td><tt class="classname">SqlMapDaoSupport</tt></td><td><tt class="literal">SqlMapClientDaoSupport</tt></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15881"></a>12.5.2.&nbsp;iBATIS SQL Maps 1.x</h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e15884"></a>12.5.2.1.&nbsp;Setting up the SqlMap</h4></div></div><div></div></div><p>Using iBATIS SQL Maps involves creating SqlMap configuration
        files containing statements and result maps. Spring takes care of
        loading those using the
        <tt class="classname">SqlMapFactoryBean</tt>.</p><pre class="programlisting">public class Account {

    private String name;
    private String email;
    
    public String getName() {
        return this.name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getEmail() {
        return this.email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
}</pre><p>Suppose we would want to map this class. We'd have to create the
        following <tt class="literal">SqlMap</tt>. Using the query, we can later on
        retrieve users through their email addresses.
        <tt class="literal">Account.xml</tt>:</p><pre class="programlisting">&lt;sql-map name="Account"&gt;

  &lt;result-map name="result" class="examples.Account"&gt;
    &lt;property name="name" column="NAME" columnIndex="1"/&gt;
    &lt;property name="email" column="EMAIL" columnIndex="2"/&gt;
  &lt;/result-map&gt;
    
  &lt;mapped-statement name="getAccountByEmail" result-map="result"&gt;
    select ACCOUNT.NAME, ACCOUNT.EMAIL
    from ACCOUNT
    where ACCOUNT.EMAIL = #value#
  &lt;/mapped-statement&gt;
    
  &lt;mapped-statement name="insertAccount"&gt;
    insert into ACCOUNT (NAME, EMAIL) values (#name#, #email#)
  &lt;/mapped-statement&gt;

&lt;/sql-map&gt;</pre><p>After having defined the Sql Map, we have to create a
        configuration file for iBATIS
        (<tt class="literal">sqlmap-config.xml</tt>):</p><pre class="programlisting">&lt;sql-map-config&gt;

  &lt;sql-map resource="example/Account.xml"/&gt;

&lt;/sql-map-config&gt;</pre><p>iBATIS loads resources from the class path, so be sure to add
        the <tt class="literal">Account.xml</tt> file to the class path.</p><p>Using Spring, we can now very easily set up the
        <tt class="literal">SqlMap</tt>, using the
        <tt class="classname">SqlMapFactoryBean</tt>:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="sqlMap" class="org.springframework.orm.ibatis.SqlMapFactoryBean"&gt;
    &lt;property name="configLocation" value="WEB-INF/sqlmap-config.xml"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e15926"></a>12.5.2.2.&nbsp;Using <tt class="classname">SqlMapTemplate</tt> and
        <tt class="classname">SqlMapDaoSupport</tt></h4></div></div><div></div></div><p>The <tt class="classname">SqlMapDaoSupport</tt> class offers a
        supporting class similar to the
        <tt class="classname">HibernateDaoSupport</tt> and the
        <tt class="classname">JdoDaoSupport</tt> classes. Let's implement a
        DAO:</p><pre class="programlisting">public class SqlMapAccountDao extends SqlMapDaoSupport implements AccountDao {

    public Account getAccount(String email) throws DataAccessException {
        return (Account) getSqlMapTemplate().executeQueryForObject("getAccountByEmail", email);
    }

    public void insertAccount(Account account) throws DataAccessException {
        getSqlMapTemplate().executeUpdate("insertAccount", account);
    }
}</pre><p>As you can see, we're using the pre-configured
        <tt class="classname">SqlMapTemplate</tt> to execute the query. Spring has
        initialized the <tt class="literal">SqlMap</tt> for us using the
        <tt class="classname">SqlMapFactoryBean</tt>, and when setting up the
        <tt class="literal">SqlMapAccountDao</tt> as follows, you're all set to go.
        Note that with iBATIS SQL Maps 1.x, the JDBC
        <tt class="interfacename">DataSource</tt> is usually specified on the
        DAO.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="accountDao" class="example.SqlMapAccountDao"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;property name="sqlMap" ref="sqlMap"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Note that a <tt class="classname">SqlMapTemplate</tt> instance could
        also be created manually, passing in the
        <tt class="interfacename">DataSource</tt> and the
        <tt class="literal">SqlMap</tt> as constructor arguments. The
        <tt class="classname">SqlMapDaoSupport</tt> base class simply
        pre-initializes a <tt class="classname">SqlMapTemplate</tt> instance for
        us.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15983"></a>12.5.3.&nbsp;iBATIS SQL Maps 2.x</h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e15986"></a>12.5.3.1.&nbsp;Setting up the SqlMapClient</h4></div></div><div></div></div><p>If we want to map the previous Account class with iBATIS 2.x we
        need to create the following SQL map
        <tt class="literal">Account.xml</tt>:</p><pre class="programlisting">&lt;sqlMap namespace="Account"&gt;

  &lt;resultMap id="result" class="examples.Account"&gt;
    &lt;result property="name" column="NAME" columnIndex="1"/&gt;
    &lt;result property="email" column="EMAIL" columnIndex="2"/&gt;
  &lt;/resultMap&gt;

  &lt;select id="getAccountByEmail" resultMap="result"&gt;
    select ACCOUNT.NAME, ACCOUNT.EMAIL
    from ACCOUNT
    where ACCOUNT.EMAIL = #value#
  &lt;/select&gt;

  &lt;insert id="insertAccount"&gt;
    insert into ACCOUNT (NAME, EMAIL) values (#name#, #email#)
  &lt;/insert&gt;

&lt;/sqlMap&gt;</pre><p>The configuration file for iBATIS 2 changes a bit
        (<tt class="literal">sqlmap-config.xml</tt>):</p><pre class="programlisting">&lt;sqlMapConfig&gt;

  &lt;sqlMap resource="example/Account.xml"/&gt;

&lt;/sqlMapConfig&gt;</pre><p>Remember that iBATIS loads resources from the class path, so be
        sure to add the <tt class="literal">Account.xml</tt> file to the class
        path.</p><p>We can use the <tt class="literal">SqlMapClientFactoryBean</tt> in the
        Spring application context. Note that with iBATIS SQL Maps 2.x, the
        JDBC <tt class="interfacename">DataSource</tt> is usually specified on
        the <tt class="literal">SqlMapClientFactoryBean</tt>, which enables lazy
        loading.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="sqlMapClient" class="org.springframework.orm.ibatis.SqlMapClientFactoryBean"&gt;
    &lt;property name="configLocation" value="WEB-INF/sqlmap-config.xml"/&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e16021"></a>12.5.3.2.&nbsp;Using <tt class="classname">SqlMapClientTemplate</tt> and
        <tt class="literal">SqlMapClientDaoSupport</tt></h4></div></div><div></div></div><p>The <tt class="literal">SqlMapClientDaoSupport</tt> class offers a
        supporting class similar to the
        <tt class="classname">SqlMapDaoSupport</tt>. We extend it to implement our
        DAO:</p><pre class="programlisting">public class SqlMapAccountDao extends SqlMapClientDaoSupport implements AccountDao {

    public Account getAccount(String email) throws DataAccessException {
        return (Account) getSqlMapClientTemplate().queryForObject("getAccountByEmail", email);
    }

    public void insertAccount(Account account) throws DataAccessException {
        getSqlMapClientTemplate().update("insertAccount", account);
    }
}</pre><p>In the DAO, we use the pre-configured
        <tt class="classname">SqlMapClientTemplate</tt> to execute the queries,
        after setting up the <tt class="literal">SqlMapAccountDao</tt> in the
        application context and wiring it with our
        <tt class="literal">SqlMapClient</tt> instance:</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="accountDao" class="example.SqlMapAccountDao"&gt;
    &lt;property name="sqlMapClient" ref="sqlMapClient"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Note that a <tt class="classname">SqlMapTemplate</tt> instance could
        also be created manually, passing in the
        <tt class="literal">SqlMapClient</tt> as constructor argument. The
        <tt class="literal">SqlMapClientDaoSupport</tt> base class simply
        pre-initializes a <tt class="classname">SqlMapClientTemplate</tt> instance
        for us.</p><p>The <tt class="classname">SqlMapClientTemplate</tt> also offers a
        generic <tt class="literal">execute</tt> method, taking a custom
        <tt class="literal">SqlMapClientCallback</tt> implementation as argument.
        This can, for example, be used for batching:</p><pre class="programlisting">public class SqlMapAccountDao extends SqlMapClientDaoSupport implements AccountDao {
    ...

    public void insertAccount(Account account) throws DataAccessException {
        getSqlMapClientTemplate().execute(new SqlMapClientCallback() {
            public Object doInSqlMapClient(SqlMapExecutor executor) throws SQLException {
                executor.startBatch();
                executor.update("insertAccount", account);
                executor.update("insertAddress", account.getAddress());
                executor.executeBatch();
            }
        });
    }
}</pre><p>In general, any combination of operations offered by the native
        <tt class="literal">SqlMapExecutor</tt> API can be used in such a callback.
        Any <tt class="literal">SQLException</tt> thrown will automatically get
        converted to Spring's generic
        <tt class="classname">DataAccessException</tt> hierarchy.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e16090"></a>12.5.3.3.&nbsp;Implementing DAOs based on plain iBATIS API</h4></div></div><div></div></div><p>DAOs can also be written against plain iBATIS API, without any
        Spring dependencies, directly using an injected
        <tt class="literal">SqlMapClient</tt>. A corresponding DAO implementation
        looks like as follows:</p><pre class="programlisting">public class SqlMapAccountDao implements AccountDao {
        
    private SqlMapClient sqlMapClient;
    
    public void setSqlMapClient(SqlMapClient sqlMapClient) {
        this.sqlMapClient = sqlMapClient;
    }

    public Account getAccount(String email) {
        try {
            return (Account) this.sqlMapClient.queryForObject("getAccountByEmail", email);
        }
        catch (SQLException ex) {
            throw new MyDaoException(ex);
        }
    }

    public void insertAccount(Account account) throws DataAccessException {
        try {
            this.sqlMapClient.update("insertAccount", account);
        }
        catch (SQLException ex) {
            throw new MyDaoException(ex);
        }
    }
}</pre><p>In such a scenario, the <tt class="literal">SQLException</tt> thrown
        by the iBATIS API needs to be handled in a custom fashion: usually,
        wrapping it in your own application-specific DAO exception. Wiring in
        the application context would still look like before, due to the fact
        that the plain iBATIS-based DAO still follows the Dependency Injection
        pattern:</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="accountDao" class="example.SqlMapAccountDao"&gt;
    &lt;property name="sqlMapClient" ref="sqlMapClient"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-jpa"></a>12.6.&nbsp;JPA</h2></div></div><div></div></div><p>Spring JPA (available under the
    <tt class="literal">org.springframework.orm.jpa</tt> package) offers
    comprehensive support for the <a href="http://java.sun.com/developer/technicalArticles/J2EE/jpa/index.html" target="_top">Java
    Persistence API</a> in a similar manner to the integration with
    Hibernate or JDO, while being aware of the underlying implementation in
    order to provide additional features.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e16118"></a>12.6.1.&nbsp;JPA setup in a Spring environment</h3></div></div><div></div></div><p>Spring JPA offers two ways of setting up JPA
      <tt class="interfacename">EntityManagerFactory</tt>:</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e16126"></a>12.6.1.1.&nbsp;<tt class="classname">LocalEntityManagerFactoryBean</tt></h4></div></div><div></div></div><p>The <tt class="classname">LocalEntityManagerFactoryBean</tt> creates
        an <tt class="interfacename">EntityManager</tt> suitable for
        environments which solely use JPA for data access. The factory bean
        will use the JPA <tt class="interfacename">PersistenceProvider</tt>
        autodetection mechanism and in most cases, requires only the
        persistence unit name:</p><pre class="programlisting">&lt;beans&gt;
...
&lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean"&gt;
 &lt;property name="persistenceUnitName" value="myPersistenceUnit"/&gt;
&lt;/bean&gt;
...
&lt;/beans&gt;</pre><p>Switching to a JNDI
        <tt class="interfacename">EntityManagerFactory</tt> (for example in
        JTA environments), is just a matter of changing the XML
        configuration:</p><pre class="programlisting">&lt;beans&gt;
...
&lt;jndi:lookup id="entityManagerFactory" jndi-name="jpa/myPersistenceUnit"/&gt;
...
&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e16150"></a>12.6.1.2.&nbsp;<tt class="classname">LocalContainerEntityManagerFactoryBean</tt></h4></div></div><div></div></div><p>The
        <tt class="classname">LocalContainerEntityManagerFactoryBean</tt> gives
        full control over the JPA
        <tt class="interfacename">EntityManagerFactory</tt> and is appropriate
        for environments where fine customizations are required. The
        <tt class="classname">LocalContainerEntityManagerFactoryBean</tt> will
        create a <tt class="interfacename">PersistenceUnitInfo</tt> based on
        the <tt class="literal">'persistence.xml'</tt> file, the supplied
        <tt class="literal">dataSourceLookup</tt> strategy and the
        <tt class="literal">loadTimeWeaver</tt>. It is thus possible to work with
        custom datasources outside of JNDI and control the weaving
        process.</p><pre class="programlisting">&lt;beans&gt;
 ...
 &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="dataSource" ref="someDataSource"/&gt;
  &lt;property name="loadTimeWeaver"&gt;
    &lt;bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"/&gt;
  &lt;/property&gt;
 &lt;/bean&gt;
&lt;/beans&gt;</pre><div class="sidebar"><p class="title"><b>When is load time weaving required?</b></p><p>Not all JPA providers impose the need of a JDK agent
          (Hibernate being an example). If your provider does not require an
          agent or you have other alternatives (for example applying
          enhancements at build time through a custom compiler or an ant task)
          the load time weaver <span class="bold"><b>should not</b></span> be
          used.</p></div><p>The <tt class="interfacename">LoadTimeWeaver</tt> interface is a
        Spring-provided class that allows JPA
        <tt class="interfacename">ClassTransformer</tt> instances to be
        plugged in a specific manner depending on the environment (web
        container/application server). Hooking
        <tt class="literal">ClassTransformers</tt> through a JDK 5.0 <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/instrument/package-summary.html" target="_top">agent</a>
        is typically not efficient - the agents work against the
        <span class="emphasis"><em>entire virtual machine</em></span> and inspect
        <span class="emphasis"><em>every</em></span> class that is loaded - something that is
        typically undesirable in a production server enviroment.</p><p>Spring provides a number of
        <tt class="interfacename">LoadTimeWeaver</tt> implementations for
        various environments, allowing
        <tt class="interfacename">ClassTransformer</tt> instances to be
        applied only <span class="emphasis"><em>per classloader</em></span> and not per
        VM.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e16218"></a>12.6.1.2.1.&nbsp;Tomcat setup</h5></div></div><div></div></div><p><a href="http://tomcat.apache.org/" target="_top">Jakarta
          Tomcat's</a> default classloader does not support class
          transformation but allows custom classloaders to be used. Spring
          offers the <tt class="classname">TomcatInstrumentableClassLoader</tt>
          (inside the
          <tt class="literal">org.springframework.instrument.classloading.tomcat</tt>
          package) which extends the Tomcat classloader
          (<tt class="classname">WebappClassLoader</tt>) and allows JPA
          <tt class="classname">ClassTransformer</tt> instances to 'enhance' all
          classes loaded by it. In short, JPA transformers will be applied
          only inside a specific web application (which uses the
          <tt class="classname">TomcatInstrumentableClassLoader</tt>).</p><p>In order to use the custom classloader:</p><div class="orderedlist"><ol type="1"><li><p>Copy <tt class="literal">spring-tomcat-weaver.jar</tt> into
              <span class="emphasis"><em>$CATALINA_HOME</em></span>/server/lib (where
              <span class="emphasis"><em>$CATALINA_HOME</em></span> represents the root of the
              Tomcat installation).</p></li><li><p>Instruct Tomcat to use the custom classloader (instead of
              the default one) by editing the web application context
              file:</p><pre class="programlisting">&lt;Context path="/myWebApp" docBase="/my/webApp/location" ...&gt;
   &lt;Loader loaderClass="org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"/&gt;
...
&lt;/Context&gt;</pre><p>Tomcat 5.0.x and 5.5.x series support several context
              locations: server configuration file
              (<span class="emphasis"><em>$CATALINA_HOME/conf/server.xml</em></span>), the
              default context configuration
              (<span class="emphasis"><em>$CATALINA_HOME/conf/context.xml</em></span>) that
              affects all deployed web applications and per-webapp
              configurations, deployed on the server
              <span class="emphasis"><em>($CATALINA_HOME/conf/[enginename]/[hostname]/my-webapp-context.xml</em></span>)
              side or along with the webapp
              (<span class="emphasis"><em>your-webapp.war/META-INF/context.xml</em></span>). For
              efficiency, inside the web-app configuration style is
              recommended since only applications which use JPA will use the
              custom classloader. See the Tomcat 5.x <a href="http://tomcat.apache.org/tomcat-5.5-doc/config/context.html" target="_top">documentation</a>
              for more details about available context locations.</p><p>Note that at the moment (Tomcat 5.5.17), a bug in the XML
              configuration parsing prevents usage of <tt class="literal">Loader
              </tt>tag inside<span class="emphasis"><em> server.xml </em></span>(no matter
              if a classloader is specified or not (be it the official or a
              custom one).</p><p>In Tomcat 4.x, one can use the same contex.xml and place
              it under <span class="emphasis"><em>$CATALINA_HOME</em></span>/webapps or modify
              <span class="emphasis"><em>$CATALINA_HOME/</em></span>conf/server.xml to use the
              custom classloader by default. See the Tomcat 4.x <a href="http://tomcat.apache.org/tomcat-4.1-doc/config/context.html" target="_top">documentation</a>
              for more information.</p></li><li><p>Use the appropriate <tt class="literal">LoadTimeWeaver</tt> when
              configuring
              <tt class="literal">LocalContainerEntityManagerFactoryBean</tt>:</p><pre class="programlisting">&lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  ...
  &lt;property name="loadTimeWeaver"&gt;
    &lt;bean class="org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"/&gt;
  &lt;/property&gt;
  ...
&lt;/bean&gt;</pre></li></ol></div><p>Using this technique, JPA applications relying on
          instrumentation, can run in Tomcat without the need of an agent.
          This is important especially when hosting applications which rely on
          different JPA implementations since the JPA transformers are applied
          only at classloader level and thus, are isolated from each
          other.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e16309"></a>12.6.1.2.2.&nbsp;OC4J setup (10.1.3.1+)</h5></div></div><div></div></div><p>As Oracle's <a href="http://www.oracle.com/technology/tech/java/oc4j/index.html" target="_top">OC4J</a>
          classloader has native bytecode transformation support, switching
          from an JDK agent to a <tt class="literal">LoadTimeWeaver</tt> can be done
          just through the application Spring configuration:</p><pre class="programlisting">&lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  ...
  &lt;property name="loadTimeWeaver"&gt;
    &lt;bean class="org.springframework.instrument.classloading.oc4j.OC4JLoadTimeWeaver"/&gt;
  &lt;/property&gt;
  ...
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e16322"></a>12.6.1.2.3.&nbsp;General LoadTimeWeaver</h5></div></div><div></div></div><p>For environments where class instrumentation is required but
          are not supported by the existing LoadTimeWeaver implementations, a
          JDK agent can be the only solution. For such cases, Spring provides
          <tt class="literal">InstrumentationLoadTimeWeaver</tt> which requires a
          Spring-specific (but very general) VM agent
          (<tt class="literal">spring-agent.jar</tt>):</p><pre class="programlisting">&lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="loadTimeWeaver"&gt;
    &lt;bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that the virtual machine has to be started with the
          Spring agent, by supplying the following JVM options:</p><pre class="programlisting">-javaagent:/path/to/spring-agent.jar</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e16340"></a>12.6.1.3.&nbsp;Dealing with multiple persistence units</h4></div></div><div></div></div><p>For applications that rely on multiple persistence units
        locations (stored in various jars in the classpath for example),
        Spring offers the <tt class="literal">PersistenceUnitManager</tt> to act as
        a central repository and avoid the (potentially expensive) persistence
        units discovery process. The default implementation allows multiple
        locations to be specified (by default, the classpath is searched for
        META-INF/persistence.xml files) which are parsed and later on
        retrieved through the persistence unit name:</p><pre class="programlisting">&lt;bean id="persistenceUnitManager" class="org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager"&gt;
  &lt;property name="persistenceXmlLocation"&gt;
    &lt;list&gt;
     &lt;value&gt;org/springframework/orm/jpa/domain/persistence-multi.xml&lt;/value&gt;
     &lt;value&gt;classpath:/my/package/**/custom-persistence.xml&lt;/value&gt;
     &lt;value&gt;classpath*:META-INF/persistence.xml&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property&gt;
   &lt;map&gt;
    &lt;entry key="localDataSource" value-ref="local-db"/&gt;
    &lt;entry key="remoteDataSource" value-ref="remote-db"/&gt;
   &lt;/map&gt;
  &lt;/property&gt;
  &lt;!-- if no datasource is specified, use this one --&gt;
  &lt;property name="defaultDataSource" ref="remoteDataSource"/&gt;
  
&lt;/bean&gt;

&lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
 &lt;property name="persistenceUnitManager" ref="persistenceUnitManager"/&gt;
 ...
&lt;/bean&gt;</pre><p>Note that the default implementation allows customization of the
        persistence unit infos before feeding them to the JPA provider
        declaratively through its properties (which affect *all* housed units)
        or programatically, through the
        <tt class="literal">PersistenceUnitPostProcessor</tt> (which allow
        persistence unit selection). If no persistenceUnitManager is
        specified, one will be created and used internally by
        <tt class="literal">LocalContainerEntityManagerFactoryBean</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e16358"></a>12.6.2.&nbsp;<tt class="classname">JpaTemplate</tt> and
      <tt class="classname">JpaDaoSupport</tt></h3></div></div><div></div></div><p>Each JPA-based DAO will then receive a
      <tt class="interfacename">EntityManagerFactory</tt> via dependency
      injection. Such a DAO can be coded against plain JPA and work with the
      given <tt class="interfacename">EntityManagerFactory</tt> or through
      Spring's <tt class="classname">JpaTemplate</tt>:</p><pre class="programlisting">&lt;beans&gt;
...
  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory"/&gt;
  &lt;/bean&gt;
...
&lt;/beans&gt;</pre><pre class="programlisting">public class JpaProductDao implements ProductDao {
  
    private EntityManagerFactory entityManagerFactory;

    public void setEntityManagerFactory(EntityManagerFactory emf) {
        this.entityManagerFactoryeManagerFactory = emf;
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        JpaTemplate jpaTemplate = new JpaTemplate(this.entityManagerFactory);
        
        return (Collection) jpaTemplate.execute(new JpaCallback() {
        
            public Object doInJpa(EntityManager em) throws PersistenceException {
                
                Query query = em.createQuery("from Product as p where p.category = :category");
                query.setParameter("category", category);
                List result = query.getResultList(); 
                // do some further processing with the result list
                return result;
            }
        });
    }
}</pre><p>The <tt class="interfacename">JpaCallback</tt> implementation
      allows any type of JPA data access. The
      <tt class="classname">JpaTemplate</tt> will ensure that
      <tt class="interfacename">EntityManager</tt>s are properly opened and
      closed and automatically participate in transactions. Moreover, the
      <tt class="classname">JpaTemplate</tt> properly handles exceptions, making
      sure resources are cleaned up and the appropriate transactions rolled
      back. The template instances are thread-safe and reusable and they can
      be kept as instance variable of the enclosing class. Note that
      <tt class="classname">JpaTemplate</tt> offers single-step actions such as
      find, load, merge, etc along with alternative convenience methods that
      can replace one line callback implementations.</p><p>Furthermore, Spring provides a convenient
      <tt class="classname">JpaDaoSupport</tt> base class that provides the
      <tt class="literal">get/setEntityManagerFactory</tt> and
      <tt class="literal">getJpaTemplate()</tt> to be used by subclases:</p><pre class="programlisting">public class ProductDaoImpl extends JpaDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) throws DataAccessException {
        Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
        params.put("category", category);
        return getJpaTemplate().findByNamedParams("from Product as p where p.category = :category", params);
    }
}</pre><p>Besides working with Spring's <tt class="classname">JpaTemplate</tt>,
      one can also code Spring-based DAOs against the JPA, doing one's own
      explicit <tt class="literal">EntityManager</tt> handling. As elaborated in the
      corresponding Hibernate section, the main advantage of this approach is
      that your data access code is able to throw checked exceptions.
      <tt class="classname">JpaDaoSupport</tt> offers a variety of support methods
      for this scenario, for retrieving and releasing a transaction
      <tt class="interfacename">EntityManager</tt>, as well as for converting
      exceptions.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e16424"></a>12.6.3.&nbsp;Implementing DAOs based on plain JPA</h3></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://static.springframework.org/spring/docs/2.0.x/images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>While <tt class="interfacename">EntityManagerFactory</tt>
        instances are thread safe,
        <tt class="interfacename">EntityManager</tt> instances are not. The
        injected JPA <tt class="interfacename">EntityManager</tt> behave just
        like an <tt class="interfacename">EntityManager</tt> fetched from an
        application server's JNDI environment, as defined by the JPA
        specification. It will delegate all calls to the current transactional
        <tt class="interfacename">EntityManager</tt>, if any; else, it will
        fall back to a newly created
        <tt class="interfacename">EntityManager</tt> per operation, making it
        thread safe.</p></td></tr></table></div><p>It is possible to write code against the plain JPA without using
      any Spring dependencies, using an injected
      <tt class="interfacename">EntityManagerFactory</tt> or
      <tt class="interfacename">EntityManager</tt>. Note that Spring can
      understand <tt class="interfacename">@PersistenceUnit</tt> and
      <tt class="interfacename">@PersistenceContext</tt> annotations both at
      field and method level if a
      <tt class="classname">PersistenceAnnotationBeanPostProcessor</tt> is
      enabled. A corresponding DAO implementation might look like this:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    @PersistenceUnit
    private EntityManagerFactory entityManagerFactory;

    public Collection loadProductsByCategory(String category) {
        EntityManager em = this.entityManagerFactory.getEntityManager();
        try {
             Query query = em.createQuery("from Product as p where p.category = ?1");
             query.setParameter(1, category);
             return query.getResultList();

        }
        finally {
            if (em != null) {
                em.close();
            }
        }
    }
}</pre><p>The DAO above has no dependency on Spring and still fits nicely
      into a Spring application context, just like it would if coded against
      Spring's <tt class="classname">JpaTemplate</tt>. Moreover, the DAO takes
      advantage of annotations to require the injection of the default
      <tt class="interfacename">EntityManagerFactory</tt>:</p><pre class="programlisting">&lt;beans&gt;
  ...
  <i class="lineannotation"><span class="lineannotation">&lt;!-- JPA annotations bean post processor --&gt;</span></i>
  &lt;bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"/&gt;

&lt;/beans&gt;</pre><p>The main issue with such DAOs is that it always gets a new
      <tt class="interfacename">EntityManager</tt> from the factory. This can
      be easily overcome by requesting an
      <tt class="interfacename">EntityManager</tt> to be injected instead of
      the factory:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private EntityManager em;

    @PersistenceContext
    public void setEntityManager(EntityManager em) {
        this.em = em;
    }

    public Collection loadProductsByCategory(String category) {
       Query query = em.createQuery("from Product as p where p.category = :category");
       query.setParameter("category", category);
       return query.getResultList(); 
    }
}</pre><div class="sidebar"><p class="title"><b>Method and Field level Injection</b></p><p>Annotations that indicate dependency injections (such as
        @PersistenceUnit and @PersistenceContext) can be applied on field or
        methods inside a class, therefore the expression "method/field level
        injection". Field-level annotations concise and easier to use while
        method-level allow for processing the injected dependency. In both
        cases the member visibility (public, protected, private) does not
        matter.</p><p>What about class level annotations?</p><p>On JEE 5 platform, they are used for dependency declaration and
        not for resource injection.</p></div><p>The injected <tt class="interfacename">EntityManager</tt> is
      Spring-managed (aware of the ongoing transaction). It is important to
      note that even though the new implementation prefers method level
      injection (of an <tt class="interfacename">EntityManager</tt> instead of
      an <tt class="interfacename">EntityManagerFactory)</tt>, no change is
      required in the application context XML due to annotation usage.</p><p>The main advantage of this DAO style is that it depends on Java
      Persistence API; no import of any Spring class is required. Moreover, as
      the JPA annotations are understood, the injections are applied
      automatically by the Spring container. This is of course appealing from
      a non-invasiveness perspective, and might feel more natural to JPA
      developers.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e16512"></a>12.6.4.&nbsp;Exception Translation</h3></div></div><div></div></div><p>However, the DAO throws the plain
      <tt class="classname">PersistenceException</tt> exception class (which is
      unchecked, and so does not have to be declared or caught) but also
      <tt class="classname">IllegalArgumentException</tt> and
      <tt class="classname">IllegalStateException</tt>, which means that callers
      can only treat exceptions as generally fatal - unless they want to
      depend on JPA's own exception structure. Catching specific causes such
      as an optimistic locking failure is not possible without tying the
      caller to the implementation strategy. This tradeoff might be acceptable
      to applications that are strongly JPA-based and/or do not need any
      special exception treatment. However, Spring offers a solution allowing
      exception translation to be applied transparently through the
      <tt class="interfacename">@Repository</tt> annotation:</p><pre class="programlisting">@Repository
public class ProductDaoImpl implements ProductDao {
 ...
}</pre><pre class="programlisting">&lt;beans&gt;
  ...
  <i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="classname">Exception</tt> translation bean post processor --&gt;</span></i>
  &lt;bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"/&gt;

&lt;/beans&gt;</pre><p>The postprocessor will automatically look for all exception
      translators (implementations of the
      <tt class="interfacename">PersistenceExceptionTranslator</tt> interface)
      and advice all beans maked with the
      <tt class="interfacename">@Repository</tt> annotation so that the
      discovered translators can intercept and apply the appropriate
      translation on the thrown exceptions.</p><p>In summary: DAOs can be implemented based on the plain Java
      Persistence API and annotations, while still being able to benefit from
      Spring-managed transactions, dependency injection, and transparent
      exception conversion (if desired) to Spring's custom exception
      hierarchies.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e16549"></a>12.7.&nbsp;Transaction Management</h2></div></div><div></div></div><p>To execute service operations within transactions, you can use
    Spring's common declarative transaction facilities. For example:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd"&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="myEmf"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;
  
  &lt;aop:config&gt;
    &lt;aop:pointcut id="productServiceMethods" expression="execution(* product.ProductService.*(..))"/&gt;
    &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="productServiceMethods"/&gt;
  &lt;/aop:config&gt;

  &lt;tx:advice id="txAdvice" transaction-manager="myTxManager"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="increasePrice*" propagation="REQUIRED"/&gt;
      &lt;tx:method name="someOtherBusinessMethod" propagation="REQUIRES_NEW"/&gt;
      &lt;tx:method name="*" propagation="SUPPORTS" read-only="true"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

&lt;/beans&gt;</pre><p>Spring JPA allows a configured
    <tt class="classname">JpaTransactionManager</tt> to expose a JPA transaction
    to JDBC access code that accesses the same JDBC
    <tt class="interfacename">DataSource</tt>, provided that the registered
    <tt class="interfacename">JpaDialect</tt> supports retrieval of the
    underlying JDBC <tt class="interfacename">Connection</tt>. Out of the box,
    Spring provides dialects for the Toplink and Hibernate JPA
    implementations. See the next section for details on the
    <tt class="interfacename">JpaDialect</tt> mechanism.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e16573"></a>12.8.&nbsp;JpaDialect</h2></div></div><div></div></div><p>As an advanced feature <tt class="classname">JpaTemplate</tt>,
    <tt class="classname">JpaTransactionManager</tt> and subclasses of
    <tt class="classname">AbstractEntityManagerFactoryBean</tt> support a custom
    <tt class="interfacename">JpaDialect</tt>, to be passed into the
    "jpaDialect" bean property. In such a scenario, the DAOs won't receive an
    <tt class="interfacename">EntityManagerFactory</tt> reference but rather a
    full <tt class="classname">JpaTemplate</tt> instance instead (for example,
    passed into <tt class="classname">JpaDaoSupport</tt>'s "jpaTemplate"
    property). A <tt class="interfacename">JpaDialect</tt> implementation can
    enable some advanced features supported by Spring, usually in a
    vendor-specific manner:</p><div class="itemizedlist"><ul type="disc"><li><p>applying specific transaction semantics (such as custom
        isolation level or transaction timeout)</p></li><li><p>retrieving the transactional JDBC
        <tt class="interfacename">Connection</tt> (for exposure to JDBC-based
        DAOs)</p></li><li><p>advanced translation of <tt class="literal">PersistenceExceptions</tt>
        to Spring <tt class="literal">DataAccessExceptions</tt></p></li></ul></div><p>This is particularly valuable for special transaction semantics and
    for advanced translation of exception. Note that the default
    implementation used (<tt class="classname">DefaultJpaDialect</tt>) doesn't
    provide any special capabilities and if the above features are required,
    the appropriate dialect has to be specified.</p><p>See the <tt class="interfacename">JpaDialect</tt> Javadoc for more
    details of its operations and how they are used within Spring's JPA
    support.</p></div></div><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="jdbc.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="pt03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;11.&nbsp;Data access using JDBC&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.interface21.com/" title="Interface21 - Spring from the Source">Sponsored by Interface21</a></span></td><td width="40%" align="right" valign="top">&nbsp;Part&nbsp;III.&nbsp;The Web</td></tr></table></div></body>
<!-- Mirrored from static.springframework.org/spring/docs/2.0.x/reference/orm.html by HTTrack Website Copier/3.x [XR&CO'2005], Tue, 17 Oct 2006 17:46:00 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
