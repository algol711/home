<html>
<!-- Mirrored from static.springframework.org/spring/docs/2.0.x/reference/validation.html by HTTrack Website Copier/3.x [XR&CO'2005], Tue, 17 Oct 2006 17:45:45 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;5.&nbsp;Validation, Data-binding, the BeanWrapper, and PropertyEditors</title><link rel="stylesheet" href="http://static.springframework.org/spring/docs/2.0.x/styles/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><link rel="home" href="index.html" title="The Spring Framework - Reference Documentation"><link rel="up" href="pt01.html" title="Part&nbsp;I.&nbsp;Core Technologies"><link rel="previous" href="resources.html" title="Chapter&nbsp;4.&nbsp;Resources"><link rel="next" href="aop.html" title="Chapter&nbsp;6.&nbsp;Aspect Oriented Programming with Spring"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns="http://www.w3.org/TR/xhtml1/transitional" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://www.springframework.org/" title="The Spring Framework"><img style="border:none;" src="images/xdev-spring_logo.jpg"></a><a style="border:none;" href="http://www.interface21.com/" title="Interface21 - Spring from the Source"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/i21-banner-rhs.jpg"></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="validation"></a>Chapter&nbsp;5.&nbsp;Validation, Data-binding, the <tt class="interfacename">BeanWrapper</tt>, and <tt class="literal">PropertyEditors</tt></h2></div></div>
   <table align="center">
<tr>
<td>
<script type="text/javascript"><!--
google_ad_client = "pub-2627642070897863";
google_ad_width = 336;
google_ad_height = 280;
google_ad_format = "336x280_as";
google_ad_type = "text_image";
//2006-10-13: com_336x280
google_ad_channel = "7652836435";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
<td>
<script type="text/javascript"><!--
google_ad_client = "pub-2627642070897863";
google_ad_width = 336;
google_ad_height = 280;
google_ad_format = "336x280_as";
google_ad_type = "text_image";
//2006-10-13: com_336x280
google_ad_channel = "7652836435";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</tr>
</table>
   <div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validation-introduction"></a>5.1.&nbsp;Introduction</h2></div></div><div></div></div><p>There are pros and cons for considering validation as business logic,
    and Spring offers a design for validation (and data binding) that
    does not exclude either one of them. Specifically validation should not be
    tied to the web tier, should be easy to localize and it should be
    possible to plug in any validator available. Considering the above, Spring
    has come up with a <tt class="interfacename">Validator</tt> interface that
    is both basic and eminently usable in every layer of an application.</p><p>Data binding is useful for allowing user input to be dynamically
    bound to the domain model of an application (or whatever objects you use
    to process user input). Spring provides the so-called
    <tt class="interfacename">DataBinder</tt> to do exactly that. The
    <tt class="interfacename">Validator</tt> and the
    <tt class="interfacename">DataBinder</tt> make up the <tt class="literal">validation</tt> package,
    which is primarily used in but not limited to the MVC framework.</p><p>The <tt class="interfacename">BeanWrapper</tt> is a fundamental concept in the
    Spring Framework and is used in a lot of places. However, you probably
    will not ever have the need to use the <tt class="interfacename">BeanWrapper</tt> directly. Because this
    is reference documentation however, we felt that some explanation might be
    right. We're explaining the <tt class="interfacename">BeanWrapper</tt> in this chapter since if you were
    going to use it at all, you would probably do that when trying to bind
    data to objects, which is strongly related to the <tt class="interfacename">BeanWrapper</tt>.</p><p>Spring uses PropertyEditors all over the place. The concept of a
    <tt class="interfacename">PropertyEditor</tt> is part of the JavaBeans specification. Just as the
    <tt class="interfacename">BeanWrapper</tt>, it's best to explain the use of PropertyEditors in this
    chapter as well, since it's closely related to the <tt class="interfacename">BeanWrapper</tt> and the
    <tt class="interfacename">DataBinder</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validator"></a>5.2.&nbsp;Validation using Spring's <tt class="interfacename">Validator</tt> interface</h2></div></div><div></div></div><p>Spring's features a <tt class="interfacename">Validator</tt> interface that you can
        use to validate objects. The <tt class="interfacename">Validator</tt> interface works using
        an <tt class="interfacename">Errors</tt> object so that while validating, validators can report
        validation failures to the <tt class="interfacename">Errors</tt> object.</p><p>Let's consider a small data object:</p><pre class="programlisting">
public class Person {

  private String name;
  private int age;

  <i class="lineannotation"><span class="lineannotation">// the usual getters and setters...</span></i>
}</pre><p>We're going to provide validation behavior for the <tt class="classname">Person</tt>
			class by implementing the following two methods of the
			<tt class="interfacename">org.springframework.validation.Validator</tt> interface:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="methodname">supports(Class)</tt> - Can this
					<tt class="interfacename">Validator</tt> validate instances of the supplied
					<tt class="classname">Class</tt>?</p></li><li><p><tt class="methodname">validate(Object, org.springframework.validation.Errors)</tt> - 
					validates the given object and in case of validation errors, registers
					those with the given <tt class="interfacename">Errors</tt> object</p></li></ul></div><p>
		</p><p>
		Implementing a <tt class="interfacename">Validator</tt> is fairly straightforward,
		especially when you know of the <tt class="classname">ValidationUtils</tt> helper class
		that the Spring Framework also provides.</p><pre class="programlisting">public class PersonValidator implements Validator {
    
    <i class="lineannotation"><span class="lineannotation">/**
    * This <tt class="interfacename">Validator</tt> validates <span class="bold"><b>just</b></span> <tt class="classname">Person</tt> instances
    */</span></i>
    public boolean supports(Class clazz) {
        return Person.class.equals(clazz);
    }
    
    public void validate(Object obj, Errors e) {
        ValidationUtils.rejectIfEmpty(e, "name", "name.empty");
        Person p = (Person) obj;
        if (p.getAge() &lt; 0) {
            e.rejectValue("age", "negativevalue");
        } else if (p.getAge() &gt; 110) {
            e.rejectValue("age", "too.darn.old");
        }
    }
}</pre><p>As you can see, the <tt class="literal">static</tt> <tt class="methodname">rejectIfEmpty(..)</tt>
		method on the <tt class="classname">ValidationUtils</tt> class is used to reject the
		<tt class="literal">'name'</tt> property if it is <tt class="literal">null</tt> or the empty string.
		Have a look at the Javadoc for the <tt class="classname">ValidationUtils</tt> class to see
		what functionality it provides besides the example shown previously.</p><p>While it is certainly possible to implement a single
		<tt class="interfacename">Validator</tt> class to validate each of the nested objects
		in a rich object, it may be better to encapsulate the validation logic for each nested
		class of object in its own <tt class="interfacename">Validator</tt> implementation. A
		simple example of a <span class="emphasis"><em>'rich'</em></span> object would be a
		<tt class="classname">Customer</tt> that is composed of two <tt class="classname">String</tt>
		properties (a first and second name) and a complex <tt class="classname">Address</tt> object.
        <tt class="classname">Address</tt> objects may be used independant of
        <tt class="classname">Customer</tt> objects, and so a distinct
        <tt class="classname">AddressValidator</tt> has been implemented. If you want your
        <tt class="classname">CustomerValidator</tt> to reuse the logic contained within the
        <tt class="classname">AddressValidator</tt> class without recourse to copy-n-paste you can
        dependency-inject or instantiate an <tt class="classname">AddressValidator</tt> within your
        <tt class="classname">CustomerValidator</tt>, and use it like so:</p><pre class="programlisting">public class CustomerValidator implements Validator {

   private final Validator addressValidator;

   public UserValidator(Validator addressValidator) {
      if (addressValidator == null) {
          throw new IllegalArgumentException("The supplied [Validator] is required and must not be null.");
      }
      if (!addressValidator.supports(Address.class)) {
          throw new IllegalArgumentException(
            "The supplied [Validator] must support the validation of [Address] instances.");
      }
      this.addressValidator = addressValidator;
   }

    <i class="lineannotation"><span class="lineannotation">/**
    * This <tt class="interfacename">Validator</tt> validates <tt class="classname">Customer</tt> instances, and any subclasses of <tt class="classname">Customer</tt> too
    */</span></i>
   public boolean supports(Class clazz) {
      return Customer.class.isAssignableFrom(clazz);
   }

   public void validate(Object target, Errors errors) {
      ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required");
      ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required");
      Customer customer = (Customer) target;
      try {
          errors.pushNestedPath("address");
          ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);
      } finally {
          errors.popNestedPath();
      }
   }
}</pre><p>Validation errors are reported to the <tt class="interfacename">Errors</tt>
		object passed to the validator. In case of Spring Web MVC you can use
		<tt class="literal">&lt;spring:bind/&gt;</tt> tag to inspect the error messages, but
		of course you can also inspect the errors object yourself. More information about
		the methods it offers can be found from the Javadoc.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validation-conversion"></a>5.3.&nbsp;Resolving codes to error messages</h2></div></div><div></div></div><p>We've talked about databinding and validation. Outputting messages corresponding to 
		validation errors is the last thing we need to discuss. In the example we've shown
		above, we rejected the <tt class="literal">name</tt> and the <tt class="literal">age</tt> field.
		If we're going to output the error messages by using a <tt class="interfacename">MessageSource</tt>,
		we will do so using the error code we've given when rejecting the field ('name' and 'age'
		in this case). When you call (either directly, or indirectly, using for example the 
		<tt class="classname">ValidationUtils</tt> class) <tt class="literal">rejectValue</tt> or one of
		the other <tt class="literal">reject</tt> methods from the <tt class="interfacename">Errors</tt>
		interface, the underlying implementation will not only register the code you've
		passed in, but also a number of additional error codes. What error codes it registers
		is determined by the <tt class="interfacename">MessageCodesResolver</tt> that is used.
		By default, the <tt class="classname">DefaultMessageCodesResolver</tt> is used, which for example
		not only registers a message with the code you gave, but also messages that include the 
		field name you passed to the reject method. So in case you reject a field using
		<tt class="literal">rejectValue("age", "too.darn.old")</tt>, apart from the
		<tt class="literal">too.darn.old</tt> code, Spring will also register
		<tt class="literal">too.darn.old.age</tt> and <tt class="literal">too.darn.old.age.int</tt>
		(so the first will include the field name and the second will include the type of the
		field); this is done as a convenience to aid developers in targeting error
		messages and suchlike.</p><p>More information on the <tt class="interfacename">MessageCodesResolver</tt> and the default
		strategy can be found online with the Javadocs for
		<a href="http://www.springframework.org/docs/api/org/springframework/validation/MessageCodesResolver.html" target="_top">MessageCodesResolver</a>
		and
		<a href="http://www.springframework.org/docs/api/org/springframework/validation/DefaultMessageCodesResolver.html" target="_top">DefaultMessageCodesResolver</a>
		respectively.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-beans"></a>5.4.&nbsp;Bean manipulation and the <tt class="interfacename">BeanWrapper</tt></h2></div></div><div></div></div><p>The <tt class="literal">org.springframework.beans</tt> package adheres to
    the JavaBeans standard provided by Sun. A JavaBean is simply a class with
    a default no-argument constructor, which follows a naming conventions
    where a property named <tt class="literal">bingoMadness</tt> has a setter
    <tt class="methodname">setBingoMadness(..)</tt> and a getter <tt class="methodname">getBingoMadness()</tt>.
    For more information about JavaBeans and the specification, please refer
    to Sun's website
    (<a href="http://java.sun.com/products/javabeans/" target="_top">java.sun.com/products/javabeans</a>).</p><p>One quite important concept of the beans package is the
    <tt class="interfacename">BeanWrapper</tt> interface and its corresponding
    implementation (<tt class="classname">BeanWrapperImpl</tt>). As quoted from the
    Javadoc, the <tt class="interfacename">BeanWrapper</tt> offers functionality to set and get property
    values (individually or in bulk), get property descriptors, and to query
    properties to determine if they are readable or writable. Also, the
    <tt class="interfacename">BeanWrapper</tt> offers support for nested properties, enabling the setting of
    properties on sub-properties to an unlimited depth. Then, the <tt class="interfacename">BeanWrapper</tt>
    supports the ability to add standard JavaBeans
    <tt class="interfacename">PropertyChangeListeners</tt> and
    <tt class="interfacename">VetoableChangeListeners</tt>, without the need for
    supporting code in the target class. Last but not least, the <tt class="interfacename">BeanWrapper</tt>
    provides support for the setting of indexed properties. The <tt class="interfacename">BeanWrapper</tt>
    usually isn't used by application code directly, but by the
    <tt class="interfacename">DataBinder</tt> and the
    <tt class="interfacename">BeanFactory</tt>.</p><p>The way the <tt class="interfacename">BeanWrapper</tt> works is partly indicated by its name:
    <span class="emphasis"><em>it wraps a bean</em></span> to perform actions on that bean, like
    setting and retrieving properties.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-beans-conventions"></a>5.4.1.&nbsp;Setting and getting basic and nested properties</h3></div></div><div></div></div><p>Setting and getting properties is done using the
      <tt class="literal">setPropertyValue(s)</tt> and
      <tt class="literal">getPropertyValue(s)</tt> methods that both come with a
      couple of overloaded variants. They're all described in more detail in
      the Javadoc Spring comes with. What's important to know is that there
      are a couple of conventions for indicating properties of an object. A
      couple of examples:</p><div class="table"><a name="d0e6891"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;Examples of properties</b></p><table summary="Examples of properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Expression</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="literal">name</tt></td><td>Indicates the property <tt class="literal">name</tt>
                corresponding to the methods <tt class="literal">getName()</tt> or
                <tt class="literal">isName()</tt> and
                <tt class="literal">setName()</tt></td></tr><tr><td><tt class="literal">account.name</tt></td><td>Indicates the nested property <tt class="literal">name</tt>
                of the property <tt class="literal">account</tt> corresponding e.g.
                to the methods <tt class="literal">getAccount().setName()</tt> or
                <tt class="literal">getAccount().getName()</tt></td></tr><tr><td><tt class="literal">account[2]</tt></td><td>Indicates the <span class="emphasis"><em>third</em></span> element of the
                indexed property <tt class="literal">account</tt>. Indexed
                properties can be of type <tt class="literal">array</tt>,
                <tt class="literal">list</tt> or other <span class="emphasis"><em>naturally
                ordered</em></span> collection</td></tr><tr><td><tt class="literal">account[COMPANYNAME]</tt></td><td>Indicates the value of the map entry indexed by the key
                <span class="emphasis"><em>COMPANYNAME</em></span> of the Map property
                <tt class="literal">account</tt></td></tr></tbody></table></div><p>Below you'll find some examples of working with the <tt class="interfacename">BeanWrapper</tt> to
      get and set properties.</p><p><span class="emphasis"><em>(This next section is not vitally important to you if you're not
      planning to work with the <tt class="interfacename">BeanWrapper</tt> directly. If you're
      just using the <tt class="interfacename">DataBinder</tt> and the
      <tt class="interfacename">BeanFactory</tt> and their out-of-the-box implementation, you
      should skip ahead to the section about
      <tt class="interfacename">PropertyEditors</tt>.)</em></span></p><p>Consider the following two classes:</p><pre class="programlisting">public class Company {
    private String name;
    private Employee managingDirector;

    public String getName()	{ 
        return this.name; 
    }
    public void setName(String name) { 
        this.name = name; 
    } 
    public Employee getManagingDirector() { 
        return this.managingDirector; 
    }
    public void setManagingDirector(Employee managingDirector) {
        this.managingDirector = managingDirector;
    }
}</pre><pre class="programlisting">public class Employee {
    private float salary;

    public float getSalary() {
        return salary;
    }
    public void setSalary(float salary) {
        this.salary = salary;
    }
}</pre><p>The following code snippets show some examples of how to retrieve
      and manipulate some of the properties of instantiated
      <tt class="literal">Companies</tt> and <tt class="literal">Employees</tt>:</p><pre class="programlisting">BeanWrapper company = BeanWrapperImpl(new Company());
<i class="lineannotation"><span class="lineannotation">// setting the company name..</span></i>
company.setPropertyValue("name", "Some Company Inc.");
<i class="lineannotation"><span class="lineannotation">// ... can also be done like this:</span></i>
PropertyValue value = new PropertyValue("name", "Some Company Inc.");
company.setPropertyValue(value);

<i class="lineannotation"><span class="lineannotation">// ok, let's create the director and tie it to the company:</span></i>
BeanWrapper jim = BeanWrapperImpl(new Employee());
jim.setPropertyValue("name", "Jim Stravinsky");
company.setPropertyValue("managingDirector", jim.getWrappedInstance());

<i class="lineannotation"><span class="lineannotation">// retrieving the salary of the managingDirector through the company</span></i>
Float salary = (Float) company.getPropertyValue("managingDirector.salary");</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-beans-conversion"></a>5.4.2.&nbsp;Built-in <span class="interface">PropertyEditor</span> implementations</h3></div></div><div></div></div><p>Spring heavily uses the concept of
      <tt class="literal">PropertyEditors</tt>. Sometimes it might be handy to be
      able to represent properties in a different way than the object itself.
      For example, a date can be represented in a human readable way, while
      we're still able to convert the human readable form back to the original
      date (or even better: convert any date entered in a human readable form,
      back to <tt class="classname">Date</tt> objects). This behavior can be achieved by
      <span class="emphasis"><em>registering custom editors</em></span>, of type
      <tt class="interfacename">java.beans.PropertyEditor</tt>. Registering custom editors
      on a <tt class="interfacename">BeanWrapper</tt> or alternately in a specific IoC container as
      mentioned in the previous chapter, gives it the knowledge of how to
      convert properties to the desired type. Read more about PropertyEditors
      in the Javadoc of the <tt class="literal">java.beans</tt> package provided by
      Sun.</p><p>A couple of examples where property editing is used in Spring
      </p><div class="itemizedlist"><ul type="disc" compact><li><p><span class="emphasis"><em>setting properties on beans</em></span> is done
            using <tt class="literal">PropertyEditors</tt>. When mentioning
            <tt class="literal">java.lang.String</tt> as the value of a property of
            some bean you're declaring in XML file, Spring will (if the setter
            of the corresponding property has a <tt class="classname">Class</tt>-parameter) use the
            <tt class="classname">ClassEditor</tt> to try to resolve the parameter to
            a <tt class="classname">Class</tt> object</p></li><li><p><span class="emphasis"><em>parsing HTTP request parameters</em></span> in
            Spring's MVC framework is done using all kinds of <tt class="literal">PropertyEditors</tt>
            that you can manually bind in all subclasses of the
            <tt class="classname">CommandController</tt></p></li></ul></div><p>Spring has a number of built-in <tt class="literal">PropertyEditors</tt> to make life easy.
      Each of those is listed below and they are all located in the
      <tt class="literal">org.springframework.beans.propertyeditors</tt> package.
      Most, but not all (as indicated below), are registered by default by
      <tt class="classname">BeanWrapperImpl</tt>. Where the property editor is configurable in some
      fashion, you can of course still register your own variant to override
      the default one:</p><div class="table"><a name="d0e7088"></a><p class="title"><b>Table&nbsp;5.2.&nbsp;Built-in <tt class="literal">PropertyEditors</tt></b></p><table summary="Built-in PropertyEditors" border="1"><colgroup><col><col></colgroup><thead><tr><th>Class</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="classname">ByteArrayPropertyEditor</tt></td><td>Editor for byte arrays. Strings will simply be
                converted to their corresponding byte representations.
                Registered by default by <tt class="classname">BeanWrapperImpl</tt>.</td></tr><tr><td><tt class="classname">ClassEditor</tt></td><td>Parses Strings representing classes to actual classes
                and the other way around. When a class is not found, an
                <tt class="classname">IllegalArgumentException</tt> is thrown. Registered by default by
                <tt class="classname">BeanWrapperImpl</tt>.</td></tr><tr><td><tt class="classname">CustomBooleanEditor</tt></td><td>Customizable property editor for <tt class="classname">Boolean</tt> properties.
                Registered by default by <tt class="classname">BeanWrapperImpl</tt>, but, can be
                overridden by registering custom instance of it as custom
                editor.</td></tr><tr><td><tt class="classname">CustomCollectionEditor</tt></td><td>Property editor for Collections, converting any source
                <tt class="interfacename">Collection</tt> to a given target <tt class="interfacename">Collection</tt> type.</td></tr><tr><td><tt class="classname">CustomDateEditor</tt></td><td>Customizable property editor for java.util.Date,
                supporting a custom DateFormat. NOT registered by default. Must
                be user registered as needed with appropriate format.</td></tr><tr><td><tt class="classname">CustomNumberEditor</tt></td><td>Customizable property editor for any Number subclass
                like <tt class="classname">Integer</tt>, <tt class="classname">Long</tt>,
                <tt class="classname">Float</tt>, <tt class="classname">Double</tt>. Registered
                by default by <tt class="classname">BeanWrapperImpl</tt>, but can be
                overridden by registering custom instance of it as a custom editor.</td></tr><tr><td><tt class="classname">FileEditor</tt></td><td>Capable of resolving Strings to
                <tt class="classname">java.io.File</tt> objects. Registered by default by
                <tt class="classname">BeanWrapperImpl</tt>. </td></tr><tr><td><tt class="classname">InputStreamEditor</tt></td><td>One-way property editor, capable of taking a text
                string and producing (via an intermediate <tt class="classname">ResourceEditor</tt> and
                <tt class="interfacename">Resource</tt>) an
                <tt class="interfacename">InputStream</tt>, so <tt class="interfacename">InputStream</tt>
                properties may be directly set as Strings. Note that the default usage
                will not close the <tt class="interfacename">InputStream</tt> for
                you! Registered by default by <tt class="classname">BeanWrapperImpl</tt>.</td></tr><tr><td><tt class="classname">LocaleEditor</tt></td><td>Capable of resolving Strings to
                <tt class="classname">Locale</tt> objects and vice versa (the String
                format is [language]_[country]_[variant], which is the same
                thing the toString() method of Locale provides). Registered by
                default by <tt class="classname">BeanWrapperImpl</tt>.</td></tr><tr><td><tt class="classname">PropertiesEditor</tt></td><td>Capable of converting Strings (formatted using the
                format as defined in the Javadoc for the java.lang.Properties
                class) to <tt class="classname">Properties</tt> objects. Registered by
                default by <tt class="classname">BeanWrapperImpl</tt>.</td></tr><tr><td><tt class="classname">StringArrayPropertyEditor</tt></td><td>Capable of resolving a comma-delimited list of String
                to a String-array and vice versa.</td></tr><tr><td><tt class="classname">StringTrimmerEditor</tt></td><td>Property editor that trims Strings. Optionally allows
                transforming an empty string into a <tt class="literal">null</tt> value. NOT
                registered by default; must be user registered as needed.</td></tr><tr><td><tt class="classname">URLEditor</tt></td><td>Capable of resolving a String representation of a URL
                to an actual <tt class="classname">URL</tt> object. Registered by
                default by <tt class="classname">BeanWrapperImpl</tt>.</td></tr></tbody></table></div><p>
		Spring uses the <tt class="interfacename">java.beans.PropertyEditorManager</tt> to set
		the search path for property editors that might be needed. The search path also includes
		<tt class="literal">sun.bean.editors</tt>, which includes
		<tt class="interfacename">PropertyEditor</tt> implementations for types such as
		<tt class="classname">Font</tt>, <tt class="classname">Color</tt>, and most of the primitive types.
		Note also that the standard JavaBeans infrastructure will automatically discover
		<tt class="interfacename">PropertyEditor</tt> classes (without you having to register them
		explicitly) if they are in the same package as the class they handle, and have the same name
		as that class, with <tt class="literal">'Editor'</tt> appended; for example, one could have the
		following class and package structure, which would be sufficient for the
		<tt class="classname">FooEditor</tt> class to be recognized and used as the
		<tt class="interfacename">PropertyEditor</tt> for <tt class="classname">Foo</tt>-typed
		properties.
	  </p><pre class="programlisting">com
  chank
    pop
      Foo
      FooEditor   <i class="lineannotation"><span class="lineannotation">// the <tt class="interfacename">PropertyEditor</tt> for the <tt class="classname">Foo</tt> class</span></i></pre><p>Note that you can also use the standard <tt class="interfacename">BeanInfo</tt> JavaBeans
		mechanism here as well (described
		<a href="http://java.sun.com/docs/books/tutorial/javabeans/customization/index.html" target="_top">in not-amazing-detail here</a>).
		Find below an example of using the <tt class="interfacename">BeanInfo</tt> mechanism for
		explicitly registering one or more <tt class="interfacename">PropertyEditor</tt> instances
		with the properties of an associated class.</p><pre class="programlisting">com
  chank
    pop
      Foo
      FooBeanInfo   <i class="lineannotation"><span class="lineannotation">// the <tt class="interfacename">BeanInfo</tt> for the <tt class="classname">Foo</tt> class</span></i></pre><p>
		Here is the Java source code for the referenced <tt class="classname">FooBeanInfo</tt> class. This
		would associate a <tt class="classname">CustomNumberEditor</tt> with the <tt class="literal">age</tt>
		property of the <tt class="classname">Foo</tt> class.
	  </p><pre class="programlisting">public class FooBeanInfo extends SimpleBeanInfo {
      
    public PropertyDescriptor[] getPropertyDescriptors() {
        try {
            final PropertyEditor numberPE = new CustomNumberEditor(Integer.class, true);
            PropertyDescriptor ageDescriptor = new PropertyDescriptor("age", Foo.class) {
                public PropertyEditor createPropertyEditor(Object bean) {
                    return numberPE;
                };
            };
            return new PropertyDescriptor[] { ageDescriptor };
        }
        catch (IntrospectionException ex) {
            throw new Error(ex.toString());
        }
    }
}</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-beans-conversion-customeditor-registration"></a>5.4.2.1.&nbsp;Registering additional custom <tt class="literal">PropertyEditors</tt></h4></div></div><div></div></div><p>When setting bean properties as a string value, a Spring IoC container
            ultimately uses standard JavaBeans <tt class="literal">PropertyEditors</tt> to convert these
            Strings to the complex type of the property. Spring pre-registers a number
            of custom <tt class="literal">PropertyEditors</tt> (for example, to convert a classname expressed
            as a string into a real <tt class="classname">Class</tt> object). Additionally, Java's standard
            JavaBeans <tt class="interfacename">PropertyEditor</tt> lookup mechanism allows a
            <tt class="classname">PropertyEditor</tt> for a class simply to be named appropriately and
            placed in the same package as the class it provides support for, to be found automatically.</p><p>If there is a need to register other custom <tt class="literal">PropertyEditors</tt>, there
            are several mechanisms available. The most manual approach, which is not normally convenient or
            recommended, is to simply use the <tt class="methodname">registerCustomEditor()</tt> method of the
            <tt class="interfacename">ConfigurableBeanFactory</tt> interface, assuming you have a
            <tt class="interfacename">BeanFactory</tt> reference. The more convenient mechanism is to use
            a special bean factory post-processor called <tt class="classname">CustomEditorConfigurer</tt>.
            Although bean factory post-processors can be used semi-manually with
            <tt class="interfacename">BeanFactory</tt> implementations, this one has a nested property
            setup, so it is strongly recommended that it is used
            with the <tt class="interfacename">ApplicationContext</tt>, where it may be deployed in similar fashion
            to any other bean, and automatically detected and applied.</p><p>Note that all bean factories and application contexts automatically
            use a number of built-in property editors, through their use of something
            called a <tt class="interfacename">BeanWrapper</tt> to handle property conversions.
            The standard property editors that the <tt class="interfacename">BeanWrapper</tt> registers
            are listed in <a href="validation.html#beans-beans-conversion" title="5.4.2.&nbsp;Built-in PropertyEditor implementations">the previous section</a>. Additionally,
            <tt class="literal">ApplicationContexts</tt> also override or add an additional number of editors
            to handle resource lookups in a manner appropriate to the specific application context type.</p><p>
			Standard JavaBeans <tt class="interfacename">PropertyEditor</tt>
			instances are used to convert property values expressed as strings to
			the actual complex type of the property.
			<tt class="classname">CustomEditorConfigurer</tt>, a bean factory post-processor,
			may be used to conveniently add support for additional
			<tt class="interfacename">PropertyEditor</tt> instances to an
			<tt class="interfacename">ApplicationContext</tt>.
		</p><p>
			Consider a user class <tt class="classname">ExoticType</tt>, and another
			class <tt class="classname">DependsOnExoticType</tt> which needs
			<tt class="classname">ExoticType</tt> set as a property:
		</p><pre class="programlisting">package example;
		
public class ExoticType {

    private String name;

    public ExoticType(String name) {
        this.name = name;
    }
}

public class DependsOnExoticType { 
   
    private ExoticType type;

    public void setType(ExoticType type) {
        this.type = type;
    }
}</pre><p>When things are properly set up, we want to be able to assign the type property
		as a string, which a <tt class="interfacename">PropertyEditor</tt> will behind the scenes
		convert into a real <tt class="classname">ExoticType</tt> object:</p><pre class="programlisting">&lt;bean id="sample" class="example.DependsOnExoticType"&gt;
    &lt;property name="type" value="aNameForExoticType"/&gt;
&lt;/bean&gt;</pre><p>The <tt class="interfacename">PropertyEditor</tt> implementation could look similar to this:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// converts string representation to <tt class="classname">ExoticType</tt> object</span></i>
package example;

public class ExoticTypeEditor extends PropertyEditorSupport {

    private String format;

    public void setFormat(String format) {
        this.format = format;
    }
    
    public void setAsText(String text) {
        if (format != null &amp;&amp; format.equals("upperCase")) {
            text = text.toUpperCase();
        }
        ExoticType type = new ExoticType(text);
        setValue(type);
    }
}</pre><p>Finally, we use <tt class="classname">CustomEditorConfigurer</tt> to
		register the new <tt class="interfacename">PropertyEditor</tt>
		with the <tt class="interfacename">ApplicationContext</tt>, which will
		then be able to use it as needed:</p><pre class="programlisting">&lt;bean id="customEditorConfigurer" 
    class="org.springframework.beans.factory.config.CustomEditorConfigurer"&gt;
  &lt;property name="customEditors"&gt;
    &lt;map&gt;
      &lt;entry key="example.ExoticType"&gt;
        &lt;bean class="example.ExoticTypeEditor"&gt;
          &lt;property name="format" value="upperCase"/&gt;
        &lt;/bean&gt;
      &lt;/entry&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre></div></div></div></div><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="resources.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="aop.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;4.&nbsp;Resources&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.interface21.com/" title="Interface21 - Spring from the Source">Sponsored by Interface21</a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;6.&nbsp;Aspect Oriented Programming with Spring</td></tr></table></div></body>
<!-- Mirrored from static.springframework.org/spring/docs/2.0.x/reference/validation.html by HTTrack Website Copier/3.x [XR&CO'2005], Tue, 17 Oct 2006 17:45:45 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
