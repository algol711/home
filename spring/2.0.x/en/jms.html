<html>
<!-- Mirrored from static.springframework.org/spring/docs/2.0.x/reference/jms.html by HTTrack Website Copier/3.x [XR&CO'2005], Tue, 17 Oct 2006 17:46:12 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;19.&nbsp;JMS</title><link rel="stylesheet" href="http://static.springframework.org/spring/docs/2.0.x/styles/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><link rel="home" href="index.html" title="The Spring Framework - Reference Documentation"><link rel="up" href="pt04.html" title="Part&nbsp;IV.&nbsp;Integration"><link rel="previous" href="ejb.html" title="Chapter&nbsp;18.&nbsp;Enterprise Java Bean (EJB) integration"><link rel="next" href="jmx.html" title="Chapter&nbsp;20.&nbsp;JMX"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns="http://www.w3.org/TR/xhtml1/transitional" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://www.springframework.org/" title="The Spring Framework"><img style="border:none;" src="images/xdev-spring_logo.jpg"></a><a style="border:none;" href="http://www.interface21.com/" title="Interface21 - Spring from the Source"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/i21-banner-rhs.jpg"></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="jms"></a>Chapter&nbsp;19.&nbsp;JMS</h2></div></div><div></div></div>
   <table align="center">
<tr>
<td>
<script type="text/javascript"><!--
google_ad_client = "pub-2627642070897863";
google_ad_width = 336;
google_ad_height = 280;
google_ad_format = "336x280_as";
google_ad_type = "text_image";
//2006-10-13: com_336x280
google_ad_channel = "7652836435";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
<td>
<script type="text/javascript"><!--
google_ad_client = "pub-2627642070897863";
google_ad_width = 336;
google_ad_height = 280;
google_ad_format = "336x280_as";
google_ad_type = "text_image";
//2006-10-13: com_336x280
google_ad_channel = "7652836435";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</td>
</tr>
</table>
   <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e23932"></a>19.1.&nbsp;Introduction</h2></div></div><div></div></div><p>Spring provides a JMS abstraction framework that simplifies the use
    of the JMS API and shields the user from differences between the JMS 1.0.2
    and 1.1 APIs.</p><p>JMS can be roughly divided into two areas of functionality, namely the
    production and consumption of messages. The <tt class="classname">JmsTemplate</tt>
    class is used for message production and synchronous message reception. For
    asynchronous reception similar to Java EE's message-driven bean style, Spring
    provides a number of message listener containers that are used to create
    Message-Driven POJOs (MDPs).</p><div class="sidebar"><p class="title"><b>Domain Unification</b></p><p>There are two major releases of the JMS specification, 1.0.2 and
        1.1.</p><p>JMS 1.0.2 defined two types of messaging domains, point-to-point
        (Queues) and publish/subscribe (Topics). The 1.0.2 API reflected these two
        messaging domains by providing a parallel class hierarchy for each domain.
        As a result, a client application became domain specific in its use of
        the JMS API. JMS 1.1 introduced the concept of domain unification that
        minimized both the functional differences and client API differences
        between the two domains. As an example of a functional difference that was
        removed, if you use a JMS 1.1 provider you can transactionally consume a
        message from one domain and produce a message on the other using the same
        <tt class="literal">Session</tt>.</p><p>The JMS 1.1 specification was released in April 2002 and
        incorporated as part of Java EE 1.4 in November 2003. As a result, most
        application servers that are currently in use are only required to support
        JMS 1.0.2.</p></div><p>The package <tt class="literal">org.springframework.jms.core</tt> provides
    the core functionality for using JMS. It contains JMS template classes
    that simplifies the use of the JMS by handling the creation and release of
    resources, much like the <tt class="classname">JdbcTemplate</tt> does for
    JDBC. The design principal common to Spring template classes is to provide
    helper methods to perform common operations and for more sophisticated
    usage, delegate the essence of the processing task to user implemented
    callback interfaces. The JMS template follows the same design. The classes
    offer various convenience methods for the sending of messages, consuming a
    message synchronously, and exposing the JMS session and message producer
    to the user.</p><p>The package <tt class="literal">org.springframework.jms.support</tt>
    provides JMSException translation functionality. The translation converts
    the checked <tt class="classname">JMSException</tt> hierarchy to a mirrored
    hierarchy of unchecked exceptions. If there are any provider specific
    subclasses of the checked <tt class="classname">javax.jms.JMSException</tt>,
    this exception is wrapped in the unchecked
    <tt class="classname">UncategorizedJmsException</tt>.</p><p>The package <tt class="literal">org.springframework.jms.support.converter</tt> provides a
    <tt class="interfacename">MessageConverter</tt> abstraction to convert between Java objects
    and JMS messages.</p><p>The package <tt class="literal">org.springframework.jms.support.destination</tt> provides
    various strategies for managing JMS destinations, such as providing a
    service locator for destinations stored in JNDI.</p><p>Finally, the package
    <tt class="literal">org.springframework.jms.connection</tt> provides an
    implementation of the <tt class="classname">ConnectionFactory</tt> suitable
    for use in standalone applications. It also contains an implementation of
    Spring's <tt class="interfacename">PlatformTransactionManager</tt> for
    JMS (the cunningly named <tt class="classname">JmsTransactionManager</tt>).
    This allows for seamless integration of JMS as a transactional resource into
    Spring's transaction management mechanisms.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e24003"></a>19.2.&nbsp;Using Spring JMS</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e24006"></a>19.2.1.&nbsp;<tt class="classname">JmsTemplate</tt></h3></div></div><div></div></div><p>Two implementations of the <tt class="classname">JmsTemplate</tt> class are
  		provided. The class <tt class="classname">JmsTemplate</tt> uses the JMS 1.1 API
  		and the subclass <tt class="classname">JmsTemplate102</tt> uses the JMS 1.0.2 API.</p><p>Code that uses the <tt class="classname">JmsTemplate</tt> only needs to
    	implement callback interfaces giving them a clearly defined contract. The
    	<tt class="classname">MessageCreator</tt> callback interface creates a message
    	given a Session provided by the calling code in JmsTemplate. In order to
    	allow for more complex usage of the JMS API, the callback
    	<tt class="classname">SessionCallback</tt> provides the user with the JMS
    	session and the callback <tt class="classname">ProducerCallback</tt> exposes a
    	Session and MessageProducer pair.</p><p>The JMS API exposes two types of send methods, one that takes
    	delivery mode, priority, and time-to-live as quality of service (QOS)
    	parameters and one that takes no QOS parameters which uses default values.
    	Since there are many send methods in <tt class="classname">JmsTemplate</tt>,
    	the setting of the QOS parameters have been exposed as bean properties to
    	avoid duplication in the number of send methods. Similarly, the timeout
    	value for synchronous receive calls is set using the property
    	<tt class="classname">setReceiveTimeout</tt>.</p><p>Some JMS providers allow the setting of default QOS values
    	administratively through the configuration of the ConnectionFactory. This
    	has the effect that a call to <tt class="classname">MessageProducer</tt>'s
    	send method <tt class="methodname">send(Destination destination, Message
    	message)</tt> will use different QOS default values than those
    	specified in the JMS specification. In order to provide consistent 
    	management of QOS values, the <tt class="classname">JmsTemplate</tt> must 
    	therefore be specifically enabled to use its own QOS values by setting 
    	the boolean property <span class="property">isExplicitQosEnabled</span>
    	to <tt class="literal">true</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e24060"></a>19.2.2.&nbsp;Connection Factory</h3></div></div><div></div></div><p>The <tt class="classname">JmsTemplate</tt> requires a reference to a
      	<tt class="classname">ConnectionFactory</tt>. The
      	<tt class="classname">ConnectionFactory</tt> is part of the JMS
      	specification and serves as the entry point for working with JMS. It is
      	used by the client application as a factory to create connections with
      	the JMS provider and encapsulates various configuration parameters, many
      	of which are vendor specific such as SSL configuration options.</p><p>When using JMS inside an EJB, the vendor provides implementations
      	of the JMS interfaces so that they can participate in declarative
      	transaction management and perform pooling of connections and session.
      	In order to use this implementation, Java EE containers typically require
      	that you declare a JMS connection factory as a
      	<span class="property">resource-ref</span> inside the EJB or servlet deployment
      	descriptors. To ensure the use of these features with the
     	<tt class="classname">JmsTemplate</tt> inside an EJB, the client application
      	should ensure that it references the managed implementation of the
      	<tt class="classname">ConnectionFactory</tt>.</p><p>Spring provides an implementation of the
      	<tt class="classname">ConnectionFactory</tt> interface,
      	<tt class="classname">SingleConnectionFactory</tt>, that will return the
      	same <tt class="classname">Connection</tt> on all
      	<tt class="methodname">createConnection</tt> calls and ignore calls to
      	<tt class="methodname">close.</tt> This is useful for testing and
      	standalone environments so that the same connection can be used for
      	multiple <tt class="classname">JmsTemplate</tt> calls that may span any
      	number of transactions. <tt class="classname">SingleConnectionFactory</tt>
      	takes a reference to a standard <tt class="classname">ConnectionFactory</tt>
      	that would typically come from JNDI.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e24111"></a>19.2.3.&nbsp;Destination Management</h3></div></div><div></div></div><p>Destinations, like ConnectionFactories, are JMS administered
      	objects that can be stored and retrieved in JNDI. When configuring a
      	Spring application context you can use the JNDI factory class
      	<tt class="classname">JndiObjectFactoryBean</tt> to perform dependency
      	injection on your object's references to JMS destinations. However,
      	often this strategy is cumbersome if there are a large number of
      	destinations in the application or if there are advanced destination
      	management features unique to the JMS provider. Examples of such
      	advanced destination management would be the creation of dynamic
      	destinations or support for a hierarchical namespace of destinations.
      	The <tt class="classname">JmsTemplate</tt> delegates the resolution of a
      	destination name to a JMS destination object to an implementation of the
      	interface <tt class="classname">DestinationResolver</tt>.
      	<tt class="classname">DynamicDestinationResolver</tt> is the default
      	implementation used by <tt class="classname">JmsTemplate</tt> and
      	accommodates resolving dynamic destinations. A
      	<tt class="classname">JndiDestinationResolver</tt> is also provided that
      	acts as a service locator for destinations contained in JNDI and
      	optionally falls back to the behavior contained in
      	<tt class="classname">DynamicDestinationResolver</tt>.</p><p>Quite often the destinations used in a JMS application are only
      	known at runtime and therefore cannot be administratively created when
      	the application is deployed. This is often because there is shared
      	application logic between interacting system components that create
     	destinations at runtime according to a well-known naming convention.
     	Even though the creation of dynamic destinations are not part of the JMS
      	specification, most vendors have provided this functionality. Dynamic
      	destinations are created with a name defined by the user which
      	differentiates them from temporary destinations and are often not
      	registered in JNDI. The API used to create dynamic destinations varies
      	from provider to provider since the properties associated with the
      	destination are vendor specific. However, a simple implementation choice
      	that is sometimes made by vendors is to disregard the warnings in the
      	JMS specification and to use the <tt class="classname">TopicSession</tt>
      	method <tt class="methodname">createTopic(String topicName)</tt> or the
      	<tt class="classname">QueueSession</tt> method
      	<tt class="methodname">createQueue(String queueName)</tt> to create a new
      	destination with default destination properties. Depending on the vendor
      	implementation, <tt class="classname">DynamicDestinationResolver</tt> may
      	then also create a physical destination instead of only resolving
      	one.</p><p>The boolean property <span class="property">pubSubDomain</span> is used to
      	configure the <tt class="classname">JmsTemplate</tt> with knowledge of what
      	JMS domain is being used. By default the value of this property is
      	false, indicating that the point-to-point domain, Queues, will be used.
      	In the 1.0.2 implementation the value of this property determines if the
      	<tt class="classname">JmsTemplate</tt>'s send operations will send a message
      	to a <tt class="interfacename">Queue</tt> or to a <tt class="interfacename">Topic</tt>.
      	This flag has no effect on send operations for
      	the 1.1 implementation. However, in both implementations, this property
      	determines the behavior of dynamic destination resolution via
      	implementations of the <tt class="interfacename">DestinationResolver</tt> interface.</p><p>You can also configure the <tt class="classname">JmsTemplate</tt> with
      	a default destination via the property
      	<span class="property">defaultDestination</span>. The default destination will be
      	used with send and receive operations that do not refer to a specific
      	destination.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e24182"></a>19.2.4.&nbsp;Message Listener Containers</h3></div></div><div></div></div><p>One of the most common uses of JMS messages in the EJB world is to
		drive message-driven beans (MDBs). Spring offers a solution to create
		message-driven POJOs (MDPs) in a way that does not tie a user to an EJB
		container. (See the section entitled <a href="jms.html#jms-asynchronousMessageReception" title="19.4.2.&nbsp;Asynchronous Reception - Message-Driven POJOs">Section&nbsp;19.4.2, &#8220;Asynchronous Reception - Message-Driven POJOs&#8221;</a>
		for detailed coverage of Spring's MDP support.)</p><p>A subclass of <tt class="classname">AbstractMessageListenerContainer</tt>
        is used to receive messages from a JMS message queue and drive
        the MDPs that are injected into it. The
        <tt class="classname">AbstractMessageListenerContainer</tt> is responsible
        for all threading of message reception and dispatch into the MDPs
        for processing. A message listener container is the intermediary between an
        MDP and a messaging provider, and takes care of registering to receive messages,
        participating in transactions, resource acquisition and release, exception
        conversion and suchlike. This allows you as an application developer to write
        the (posssibly complex) business logic associated with receiving a message
        (and possibly responding to it), and delegates boilerplate JMS
        infrastructure concerns to the framework.</p><p>There are three subclasses of
		<tt class="classname">AbstractMessageListenerContainer</tt> packaged
		with Spring, each with its specialised feature set.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e24202"></a>19.2.4.1.&nbsp;<tt class="classname">SimpleMessageListenerContainer</tt></h4></div></div><div></div></div><p>This message listener container is the simplest of the
			three subclasses.  It simply creates a fixed number of JMS
			sessions at startup and uses them throughout the lifespan of
			the container.  This subclass doesn't allow for dynamic adaption to
			runtime demands or participate in transactional reception of
			messages.  However, it does have the fewest requirements on 
			the JMS provider.  This subclass only requires simple JMS API
			behaviors.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e24208"></a>19.2.4.2.&nbsp;<tt class="classname">DefaultMessageListenerContainer</tt></h4></div></div><div></div></div><p>This message listener container is the one used in most
			cases. As with the <tt class="classname">SimpleMessageListenerContainer</tt>
			this subclass does not allow for dynamic adaption to runtime
			demands. However, this flavor does participate in transactions.
			Each received message is registered with an XA transaction
			(when configured) and can take advantage of XA transation
			semantics. This subclass strikes a good balance between low
			requirements on the JMS provider and good functionality including
			transaction participation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e24217"></a>19.2.4.3.&nbsp;<tt class="classname">ServerSessionMessageListenerContainer</tt></h4></div></div><div></div></div><p>This subclass is the most powerful of the three.  It
			leverages the JMS ServerSessionPool SPI to allow for dynamic
			management of JMS sessions.  This implementation also participates
			in transactions.  The use of this variety of message listener
			container enables powerful runtime tuning but places a larger
			set of requirements (ServerSessionPool SPI) on the JMS
			provider being used.  If there is no need for runtime performance
			tuning, look to the <tt class="classname">DefaultMessageListenerContainer</tt>
			or the <tt class="classname">SimpleMessageListenerContainer</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e24229"></a>19.2.5.&nbsp;Transaction management</h3></div></div><div></div></div><p>Spring provides a <tt class="classname">JmsTransactionManager</tt>
        that manages transactions for a single JMS
        <tt class="classname">ConnectionFactory</tt>. This allows JMS applications
        to leverage the managed transaction features of Spring as described in
        <a href="transaction.html" title="Chapter&nbsp;9.&nbsp;Transaction management">Chapter&nbsp;9, <i>Transaction management</i></a>. The
        <tt class="classname">JmsTransactionManager</tt> binds a Connection/Session
        pair from the specified <tt class="classname">ConnectionFactory</tt> to the
        thread. However, in a Java EE environment the
        <tt class="classname">ConnectionFactory</tt> will pool connections and
        sessions, so the instances that are bound to the thread depend on the
        pooling behavior. In a standalone environment, using Spring's
        <tt class="classname">SingleConnectionFactory</tt> will result in a using a
        single JMS <tt class="classname">Connection</tt> with each transaction having
        its own <tt class="classname">Session</tt>. The
        <tt class="classname">JmsTemplate</tt> can also be used with the
        <tt class="classname">JtaTransactionManager</tt> and an XA-capable JMS
        <tt class="classname">ConnectionFactory</tt> for performing distributed
        transactions.</p><p>Reusing code across a managed and unmanaged transactional
        environment can be confusing when using the JMS API to create a
        <tt class="classname">Session</tt> from a <tt class="classname">Connection</tt>.
        This is because the JMS API only has only one factory method to create a
        <tt class="classname">Session</tt> and it requires values for the
        transaction and acknowledgement modes. In a managed environment, setting
        these values is the responsibility of the environment's transactional
        infrastructure, so these values are ignored by the vendor's wrapper to
        the JMS Connection. When using the <tt class="classname">JmsTemplate</tt> in
        an unmanaged environment you can specify these values through the use of
        the properties <tt class="classname">SessionTransacted</tt> and
        <tt class="classname">SessionAcknowledgeMode</tt>. When using a
        <tt class="classname">PlatformTransactionManager</tt> with
        <tt class="classname">JmsTemplate</tt>, the template will always be given a
        transactional JMS <tt class="classname">Session</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e24298"></a>19.3.&nbsp;Sending a Message</h2></div></div><div></div></div><p>The <tt class="classname">JmsTemplate</tt> contains many convenience
    methods to send a message. There are send methods that specify the
    destination using a <tt class="classname">javax.jms.Destination</tt> object
    and those that specify the destination using a string for use in a JNDI
    lookup. The send method that takes no destination argument uses the
    default destination. Here is an example that sends a message to a queue
    using the 1.0.2 implementation.</p><pre class="programlisting">import javax.jms.ConnectionFactory;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Queue;
import javax.jms.Session;

import org.springframework.jms.core.MessageCreator;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.JmsTemplate102;

public class JmsQueueSender {

  private JmsTemplate jmsTemplate;
  private Queue queue;

  public void setConnectionFactory(ConnectionFactory cf) {
    this.jmsTemplate = new JmsTemplate102(cf, false);
  }

  public void setQueue(Queue queue) {
    this.queue = queue;
  }

  public void simpleSend() {
    this.jmsTemplate.send(this.queue, new MessageCreator() {
      public Message createMessage(Session session) throws JMSException {
        return session.createTextMessage("hello queue world");
      }
    });
  }
}</pre><p>This example uses the <tt class="classname">MessageCreator</tt>
    callback to create a text message from the supplied
    <tt class="classname">Session</tt> object and the
    <tt class="classname">JmsTemplate</tt> is constructed by passing a reference
    to a <tt class="classname">ConnectionFactory</tt> and a boolean specifying
    the messaging domain. A zero argument constructor and
    <span class="property">connectionFactory</span> / <span class="property">queue</span> bean
    properties are provided and can be used for constructing the instance
    (using a BeanFactory or plain Java code). Alternatively, consider
    deriving from Spring's <tt class="classname">JmsGatewaySupport</tt>
    convenience base class, which provides pre-built bean properties for JMS
    configuration.</p><p>When configuring the JMS 1.0.2 support in an application context,
    it is important to remember setting the value of the boolean property
    <span class="property">pubSubDomain</span> property in order to indicate if you
    want to send to Queues or Topics.</p><p>The method <tt class="methodname">send(String destinationName, MessageCreator
    creator)</tt> lets you send to a message using the string name
    of the destination. If these names are registered in JNDI, you should
    set the <span class="property">destinationResolver</span> property of the
    template to an instance of
    <tt class="classname">JndiDestinationResolver</tt>.</p><p>If you created the <tt class="classname">JmsTemplate</tt> and
    specified a default destination, the <tt class="methodname">send(MessageCreator c)</tt>
    sends a message to that destination.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e24358"></a>19.3.1.&nbsp;Using Message Converters</h3></div></div><div></div></div><p>In order to facilitate the sending of domain model objects, the
        <tt class="classname">JmsTemplate</tt> has various send methods that take a
        Java object as an argument for a message's data content. The overloaded
        methods <tt class="methodname">convertAndSend</tt> and
        <tt class="methodname">receiveAndConvert</tt> in
        <tt class="classname">JmsTemplate</tt> delegate the conversion process to an
        instance of the <tt class="literal">MessageConverter</tt> interface. This
        interface defines a simple contract to convert between Java objects and
        JMS messages. The default implementation
        <tt class="classname">SimpleMessageConverter</tt> supports conversion
        between <tt class="classname">String</tt> and
        <tt class="classname">TextMessage</tt>, <tt class="classname">byte[]</tt> and
        <tt class="classname">BytesMesssage</tt>, and
        <tt class="classname">java.util.Map</tt> and
        <tt class="classname">MapMessage</tt>. By using the converter, you and your
        application code can focus on the business object that is being sent or
        received via JMS and not be concerned with the details of how it is
        represented as a JMS message.</p><p>The sandbox currently includes a
        <tt class="classname">MapMessageConverter</tt> which uses reflection to
        convert between a JavaBean and a <tt class="classname">MapMessage</tt>.
        Other popular implementations choices you might implement yourself are
        Converters that use an existing XML marshalling package, such as JAXB,
        Castor, XMLBeans, or XStream, to create a
        <tt class="interfacename">TextMessage</tt> representing the object.</p><p>To accommodate the setting of a message's properties, headers, and
        body that can not be generically encapsulated inside a converter class,
        the <tt class="interfacename">MessagePostProcessor</tt> interface gives you access
        to the message after it has been converted, but before it is sent. The
        example below demonstrates how to modify a message header and a property after
        a <tt class="interfacename">java.util.Map</tt> is converted to a message.</p><pre class="programlisting">public void sendWithConversion() {
  Map m = new HashMap();
  m.put("Name", "Mark");
  m.put("Age", new Integer(47));
  jmsTemplate.convertAndSend("testQueue", m, new MessagePostProcessor() {
    public Message postProcessMessage(Message message) throws JMSException {
      message.setIntProperty("AccountID", 1234);
      message.setJMSCorrelationID("123-00001");
      return message;
    }
  });
}</pre><p>This results in a message of the form:</p><pre class="programlisting">MapMessage={ 
  Header={ 
    ... standard headers ...
    CorrelationID={123-00001} 
  } 
  Properties={ 
    AccountID={Integer:1234}
  } 
  Fields={ 
    Name={String:Mark} 
    Age={Integer:47} 
  } 
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e24424"></a>19.3.2.&nbsp;<tt class="interfacename">SessionCallback</tt> and <tt class="interfacename">ProducerCallback</tt></h3></div></div><div></div></div><p>While the send operations cover many common usage scenarios, there
        are cases when you want to perform multiple operations on a JMS
        <tt class="interfacename">Session</tt> or
        <tt class="interfacename">MessageProducer</tt>. The
        <tt class="interfacename">SessionCallback</tt> and
        <tt class="interfacename">ProducerCallback</tt> expose the JMS
        <tt class="interfacename">Session</tt> and
        <tt class="interfacename">Session</tt> / <tt class="interfacename">MessageProducer</tt>
        pair respectfully. The <tt class="methodname">execute()</tt> methods on
        <tt class="classname">JmsTemplate</tt> execute these callback
        methods.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e24460"></a>19.4.&nbsp;Receiving a message</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e24463"></a>19.4.1.&nbsp;Synchronous Reception</h3></div></div><div></div></div><p>While JMS is typically associated with asynchronous processing, it
        is possible to consume messages synchronously. The overloaded
        <tt class="methodname">receive(..)</tt> methods provide this functionality.
        During a synchronous receive, the calling thread blocks until a message
        becomes available. This can be a dangerous operation since the calling
        thread can potentially be blocked indefinitely. The property
        <span class="property">receiveTimeout</span> specifies how long the receiver
        should wait before giving up waiting for a message.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jms-asynchronousMessageReception"></a>19.4.2.&nbsp;Asynchronous Reception - Message-Driven POJOs</h3></div></div><div></div></div><p>In a fashion similar to a Message-Driven Bean (MDB) in the EJB world,
  		the Message-Driven POJO (MDP) acts as a receiver for JMS messages. The one
  		restriction (but see also below for the discussion of the
  		<tt class="classname">MessageListenerAdapter</tt> class) on an MDP is that it
  		must implement the <tt class="interfacename">javax.jms.MessageListener</tt>
  		interface. Please also be aware that in the case where your POJO will be
  		receiving messages on multiple threads, it is important to ensure that your
  		implementation is thread-safe.</p><p>Below is a simple implementation of an MDP:</p><pre class="programlisting">import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;

public class ExampleListener implements MessageListener {

  public void onMessage(Message message) {
    if (message instanceof TextMessage) {
      try {
        System.out.println(((TextMessage) message).getText());
      } catch (JMSException ex) {
        throw new RuntimeException(ex);
      }
    } else {
      throw new IllegalArgumentException("Message must be of type TextMessage");
    }
  }
}</pre><p>Once you've implemented your <tt class="interfacename">MessageListener</tt>, 
		it's time to create a message listener container.</p><p>Find below an example of how to define and configure one of the message listener
		containers that ships with Spring (in this case the 
		<tt class="classname">DefaultMessageListenerContainer</tt>).</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- this is the Message Driven POJO (MDP) --&gt;</span></i>
&lt;bean id="messageListener" class="jmsexample.ExampleListener" /&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- and this is the attendant message listener container --&gt;</span></i>
&lt;bean id="listenerContainer"
  class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
  &lt;property name="concurrentConsumers" value="5"/&gt;
  &lt;property name="connectionFactory" ref="connectionFactory" /&gt;
  &lt;property name="destination" ref="destination" /&gt;
  <span class="bold"><b>&lt;property name="messageListener" ref="messageListener" /&gt;</b></span>
&lt;/bean&gt;</pre><p>Please refer to the Spring Javadoc of the various message
        listener containers for a full description of the features supported by each implementation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e24511"></a>19.4.3.&nbsp;The <tt class="interfacename">SessionAwareMessageListener</tt> interface</h3></div></div><div></div></div><p>The <tt class="interfacename">SessionAwareMessageListener</tt> interface
  	    is a Spring-specific interface that provides a similar contract the JMS
  	    <tt class="interfacename">MessageListener</tt> interface, but also provides
  	    the message handling method with access to the JMS <tt class="interfacename">Session</tt>
  	    from which the <tt class="interfacename">Message</tt> was received.</p><pre class="programlisting">package org.springframework.jms.listener;

public interface SessionAwareMessageListener {

    void onMessage(Message message, Session session) <span class="bold"><b>throws JMSException</b></span>;
}</pre><p>You can choose to have your MDPs implement this interface (in preference to the
        standard JMS <tt class="interfacename">MessageListener</tt> interface) if you
        want your MDPs to be able to respond to any received messages (using the
        <tt class="interfacename">Session</tt> supplied in the
        <tt class="literal">onMessage(Message, Session)</tt> method). All of the message listener
        container implementations that ship wth Spring have support for MDPs that implement either
        the <tt class="interfacename">MessageListener</tt> or
        <tt class="interfacename">SessionAwareMessageListener</tt> interface. Classes
        that implement the <tt class="interfacename">SessionAwareMessageListener</tt> come
        with the caveat that they are then tied to Spring through the interface. The choice of whether
        or not to use it is left entirely up to you as an application developer or architect.</p><p>Please note that the <tt class="literal">'onMessage(..)'</tt> method of the
        <tt class="interfacename">SessionAwareMessageListener</tt> interface throws
        <tt class="classname">JMSException</tt>. In contrast to the standard JMS
        <tt class="interfacename">MessageListener</tt> interface, when using the
        <tt class="interfacename">SessionAwareMessageListener</tt> interface, it is the responsibility
        of the client code to handle any exceptions thrown.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e24573"></a>19.4.4.&nbsp;The <tt class="classname">MessageListenerAdapter</tt></h3></div></div><div></div></div><p>The <tt class="classname">MessageListenerAdapter</tt> class is the final component in
  	    Spring's asynchronous messaging support: in a nutshell, it allows you to 
  	    expose almost <span class="emphasis"><em>any</em></span> class as a MDP (there are of course some constraints).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://static.springframework.org/spring/docs/2.0.x/images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you are using the JMS 1.0.2 API, you will want to use the
  	        <tt class="classname">MessageListenerAdapter102</tt> class which provides the exact
  	        same functionality and value add as the <tt class="classname">MessageListenerAdapter</tt>
  	        class, but for the JMS 1.0.2 API.</p></td></tr></table></div><p>Consider the following interface definition. Notice that although the interface extends
  	    neither the <tt class="interfacename">MessageListener</tt> nor
        <tt class="interfacename">SessionAwareMessageListener</tt> interfaces, it can still
        be used as a MDP via the use of the <tt class="classname">MessageListenerAdapter</tt> class.
        Notice also how the various message handling methods are strongly typed according to
        the <span class="emphasis"><em>contents</em></span> of the various <tt class="interfacename">Message</tt>
        types that they can receive and handle.</p><pre class="programlisting">public interface MessageDelegate {

    void handleMessage(String message);

    void handleMessage(Map message);

    void handleMessage(byte[] message);

    void handleMessage(Serializable message);
}</pre><pre class="programlisting">public class DefaultMessageDelegate implements MessageDelegate {
    <i class="lineannotation"><span class="lineannotation">// implementation elided for clarity...</span></i>
}</pre><p>In particular, note how the above implementation of the <tt class="interfacename">MessageDelegate</tt>
        interface (the above <tt class="classname">DefaultMessageDelegate</tt> class) has
        <span class="emphasis"><em>no</em></span> JMS dependencies at all. It truly is a POJO that we will
        make into an MDP via the following configuration.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- this is the Message Driven POJO (MDP) --&gt;</span></i>
<span class="bold"><b>&lt;bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="jmsexample.DefaultMessageDelegate"/&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</b></span>

<i class="lineannotation"><span class="lineannotation">&lt;!-- and this is the attendant message listener container... --&gt;</span></i>
&lt;bean id="listenerContainer"
  class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
  &lt;property name="concurrentConsumers" value="5"/&gt;
  &lt;property name="connectionFactory" ref="connectionFactory" /&gt;
  &lt;property name="destination" ref="destination" /&gt;
  <span class="bold"><b>&lt;property name="messageListener" ref="messageListener" /&gt;</b></span>
&lt;/bean&gt;</pre><p>Below is an example of another MDP that can only handle the receiving of
        JMS <tt class="interfacename">TextMessage</tt> messages. Notice how the message handling
        method is actually called <tt class="literal">'receive'</tt> (the name of the message handling
        method in a <tt class="classname">MessageListenerAdapter</tt> defaults to
        <tt class="literal">'handleMessage'</tt>), but it is configurable (as you will see below).
        Notice also how the <tt class="literal">'receive(..)'</tt> method is strongly typed to
        receive and respond only to JMS <tt class="interfacename">TextMessage</tt> messages.</p><pre class="programlisting">public interface TextMessageDelegate {

    void receive(TextMessage message);
}</pre><pre class="programlisting">public class DefaultTextMessageDelegate implements TextMessageDelegate {
    <i class="lineannotation"><span class="lineannotation">// implementation elided for clarity...</span></i>
}</pre><p>The configuration of the attendant <tt class="classname">MessageListenerAdapter</tt> would
        look like this:</p><pre class="programlisting">&lt;bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="jmsexample.DefaultTextMessageDelegate"/&gt;
    &lt;/constructor-arg&gt;
    &lt;property name="defaultListenerMethod" value="receive"/&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- we <span class="bold"><b>don't</b></span> want automatic message context extraction --&gt;</span></i>
    &lt;property name="messageConverter"&gt;
        &lt;null/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Please note that if the above <tt class="literal">'messageListener'</tt> receives a
        JMS <tt class="interfacename">Message</tt> of a type other than
        <tt class="interfacename">TextMessage</tt>, an <tt class="classname">IllegalStateException</tt>
        will be thrown (and subsequently swallowed).</p><p>Another of the capabilities of the <tt class="classname">MessageListenerAdapter</tt>
        class is the ability to automatically send back a response <tt class="interfacename">Message</tt>
        if a handler method returns a non-void value.</p><p>Consider the following interface and its attendant implementation:</p><pre class="programlisting">public interface ResponsiveTextMessageDelegate {

    <i class="lineannotation"><span class="lineannotation"><span class="bold"><b>// notice the return type...</b></span></span></i>
    String receive(TextMessage message);
}</pre><pre class="programlisting">public class DefaultResponsiveTextMessageDelegate implements ResponsiveTextMessageDelegate {
    <i class="lineannotation"><span class="lineannotation">// implementation elided for clarity...</span></i>
}</pre><p>If the above <tt class="classname">DefaultResponsiveTextMessageDelegate</tt> is used in
        conjunction with a <tt class="classname">MessageListenerAdapter</tt> then any non-null
        value that is returned from the execution of the <tt class="literal">'receive(..)'</tt>
        method will (in the default configuration) be converted into a
        <tt class="interfacename">TextMessage</tt>. The resulting <tt class="interfacename">TextMessage</tt>
        will then be sent to the <tt class="interfacename">Destination</tt> (if one exists) 
        defined in the JMS Reply-To property of the original <tt class="interfacename">Message</tt>, or the
        default <tt class="interfacename">Destination</tt> set on the
        <tt class="classname">MessageListenerAdapter</tt> (if one has been configured); if no
        <tt class="interfacename">Destination</tt> is found then an
        <tt class="classname">InvalidDestinationException</tt> will be thrown (and please note
        that this exception <span class="emphasis"><em>will not</em></span> be swallowed and
        <span class="emphasis"><em>will</em></span> propagate up the call stack).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e24759"></a>19.4.5.&nbsp;Participating in transactions</h3></div></div><div></div></div><p>Participation in transactions requires only a couple of minor
  		changes. You will need to create a transaction manager
  		and register that transaction manager with one of the subclasses
  		that can participate in transactions (<tt class="classname">DefaultMessageListenerContainer</tt>
  		or <tt class="classname">ServerSessionMessageListenerContainer</tt>).</p><p>To create the transaction manager, you'll want to create an
  		instance of <tt class="classname">JmsTransactionManager</tt> and give
  		it an XA transaction-capable connection factory.</p><pre class="programlisting">&lt;bean id="transactionManager" class="org.springframework.jms.connection.JmsTransactionManager"&gt;
  &lt;property name="connectionFactory" ref="connectionFactory" /&gt;
&lt;/bean&gt;</pre><p>Then you just need to add it to our earlier container configuration. The
		container will take care of the rest.</p><pre class="programlisting">&lt;bean id="listenerContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
  &lt;property name="concurrentConsumers" value="5" /&gt;
  &lt;property name="connectionFactory" ref="connectionFactory" /&gt;
  &lt;property name="destination" ref="destination" /&gt;
  &lt;property name="messageListener" ref="messageListener" /&gt;
  <span class="bold"><b>&lt;property name="transactionManager" ref="transactionManager" /&gt;</b></span>
&lt;/bean&gt;</pre></div></div></div><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ejb.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="jmx.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;18.&nbsp;Enterprise Java Bean (EJB) integration&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.interface21.com/" title="Interface21 - Spring from the Source">Sponsored by Interface21</a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;20.&nbsp;JMX</td></tr></table></div></body>
<!-- Mirrored from static.springframework.org/spring/docs/2.0.x/reference/jms.html by HTTrack Website Copier/3.x [XR&CO'2005], Tue, 17 Oct 2006 17:46:12 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
