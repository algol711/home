<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>5.5. 探索 UserDict: 一个封装类</title>
<link rel="stylesheet" href="../diveintopython.css" type="text/css">
<link rev="made" href="mailto:f8dy@diveintopython.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.52.2">
<meta name="keywords" content="Python, Dive Into Python, tutorial, object-oriented, programming, documentation, book, free">
<meta name="description" content="Python from novice to pro">
<link rel="home" href="../toc/index.html" title="Dive Into Python">
<link rel="up" href="index.html" title="第 5 章 对象和面向对象">
<link rel="previous" href="instantiating_classes.html" title="5.4. 类的实例化">
<link rel="next" href="special_class_methods.html" title="5.6. 专用类方法">
</head>
<body>
<table id="Header" width="100%" border="0" cellpadding="0" cellspacing="0" summary="">
<tr>
<td id="breadcrumb" colspan="5" align="left" valign="top">导航: <a href="../index.html">起始页</a> &gt; <a href="../toc/index.html">Dive Into Python</a> &gt; <a href="index.html">对象和面向对象</a> &gt; <span class="thispage">探索 UserDict: 一个封装类</span>
</td>
<td id="navigation" align="right" valign="top">   <a href="instantiating_classes.html" title="上一页: “类的实例化”">&lt;&lt;</a>   <a href="special_class_methods.html" title="下一页: “专用类方法”">&gt;&gt;</a>
</td>
</tr>
<tr>
<td colspan="3" id="logocontainer">
<h1 id="logo"><a href="../index.html" accesskey="1">Python 研究(Dive Into Python)</a></h1>
<p id="tagline">Python 从新手到高手 [DIP_5_4_CPUG_RELEASE]</p>
</td>
<td colspan="3" align="right"><form id="search" method="GET" action="http://www.google.com/custom"><p><label for="q" accesskey="4">Find: </label><input type="text" id="q" name="q" size="20" maxlength="255" value=" "> <input type="submit" value="搜索"><input type="hidden" name="cof" value="LW:752;L:http://diveintopython.org/images/diveintopython.png;LH:42;AH:left;GL:0;AWFID:3ced2bb1f7f1b212;"><input type="hidden" name="domains" value="diveintopython.org"><input type="hidden" name="sitesearch" value="diveintopython.org"></p></form></td>
</tr>
</table>
<!--#include virtual="/inc/ads" --><div class="section" lang="zh_cn">
<div class="titlepage">
<div><div><h2 class="title">
<a name="fileinfo.userdict"></a>5.5. 探索 <tt class="classname">UserDict</tt>: 一个封装类</h2></div></div>
<div></div>
</div>
<div class="abstract"><p>如你所见， <tt class="classname">FileInfo</tt> 是一个象字典一样动作的类。为了进一步揭示这一点，让我们看一看在 <tt class="filename">UserDict</tt> 模块中的 <tt class="classname">UserDict</tt> 类，它是我们的 <tt class="classname">FileInfo</tt> 类的父类。它没有什么特别的，也是用 <span class="application">Python</span> 写的，并且保存在一个 <tt class="literal">.py</tt> 文件里，就象我们其他的代码。特别之处在于，它保存在你的 <span class="application">Python</span> 安装目录的  <tt class="filename">lib</tt>  目录下。</p></div>
<a name="tip.locate"></a><table class="tip" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/tip.png" alt="提示" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 Windows 下的 <span class="application">ActivePython</span> <span class="acronym">IDE</span> 中，你可以快速打开在你的库路径中的任何模块，使用
<span class="guimenu">File</span>-&gt;<span class="guimenuitem"><span class="accel">L</span>ocate...</span> (<span><b class="shortcut"><span><b class="keycap">Ctrl</b></span>-<span class="keysym">L</span></b></span>)。</td></tr>
</table>
<div class="example">
<a name="fileinfo.userdict.init.example"></a><h3 class="title">例 5.9. 定义 <tt class="classname">UserDict</tt> 类</h3>
<pre class="programlisting"><span class='pykeyword'>
class</span> UserDict:                                <a name="fileinfo.userdict.1.1"></a><img src="../images/callouts/1.png" alt="1" border="0" width="12" height="12">
    <span class='pykeyword'>def</span><span class='pyclass'> __init__</span>(self, dict=None):             <a name="fileinfo.userdict.1.2"></a><img src="../images/callouts/2.png" alt="2" border="0" width="12" height="12">
        self.data = {}                         <a name="fileinfo.userdict.1.3"></a><img src="../images/callouts/3.png" alt="3" border="0" width="12" height="12">
        <span class='pykeyword'>if</span> dict <span class='pykeyword'>is</span> <span class='pykeyword'>not</span> None: self.update(dict) <a name="fileinfo.userdict.1.4"></a><img src="../images/callouts/4.png" alt="4" border="0" width="12" height="12"> <a name="fileinfo.userdict.1.5"></a><img src="../images/callouts/5.png" alt="5" border="0" width="12" height="12">
</pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="12" valign="top" align="left">
<a href="#fileinfo.userdict.1.1"><img src="../images/callouts/1.png" alt="1" border="0" width="12" height="12"></a> </td>
<td valign="top" align="left">注意 <tt class="classname">UserDict</tt> 是一个基类，不是从任何其他类继承而来。</td>
</tr>
<tr>
<td width="12" valign="top" align="left">
<a href="#fileinfo.userdict.1.2"><img src="../images/callouts/2.png" alt="2" border="0" width="12" height="12"></a> </td>
<td valign="top" align="left">这就是我们 <a href="defining_classes.html#fileinfo.class.example" title="例 5.4. 定义 FileInfo 类">在 <tt class="classname">FileInfo</tt>  类中进行了覆盖</a> 的 <tt class="function">__init__</tt>  方法。注意这个父类的参数列表与子类不同。很好，每个子类可以拥有自已的参数集，只要使用正确的参数调用父类就可以了。这里父类有一个定义初始值的方法（通过在 <tt class="varname">dict</tt> 参数中传入一个字典），这一方法我们的 <tt class="classname">FileInfo</tt> 没有用上。</td>
</tr>
<tr>
<td width="12" valign="top" align="left">
<a href="#fileinfo.userdict.1.3"><img src="../images/callouts/3.png" alt="3" border="0" width="12" height="12"></a> </td>
<td valign="top" align="left">
<span class="application">Python</span> 支持数据属性（在 <span class="application">Java</span> 和 <span class="application">Powerbuilder</span> 中叫做 “<span class="quote">实例变量</span>”，在 <span class="application"><span class="acronym">C++</span></span> 中叫 “<span class="quote">数据成员</span>”），它是由某个特定的类实例所拥有的数据。在本例中，每个 <tt class="classname">UserDict</tt> 实例将拥有一个 <tt class="varname">data</tt> 数据属性。要从类外的代码引用这个属性，需要用实例的名字限定它，<tt class="literal"><i class="replaceable">instance</i>.data</tt>，限定的方法与你用模块的名字来限定函数一样。要在类的内部引用一个数据属性，我们使用 <tt class="literal">self</tt> 作为限定符。习惯上，所有的数据属性都在 <tt class="function">__init__</tt>  方法中初始化为有意义的值。然而，这并不是必须的，因为数据属性，象局部变量一样，当你首次赋给它值的时候<a href="../native_data_types/declaring_variables.html" title="3.4. 变量声明">突然产生</a>。</td>
</tr>
<tr>
<td width="12" valign="top" align="left">
<a href="#fileinfo.userdict.1.4"><img src="../images/callouts/4.png" alt="4" border="0" width="12" height="12"></a> </td>
<td valign="top" align="left">
<tt class="function">update</tt> 方法是一个字典复制器：它把一个字典中的键和值全部拷贝到另一个字典。 这个操作 <span class="emphasis"><em>并不</em></span> 事先清空目标字典，如果一些键在目标字典中已经存在，则它们将被覆盖，那些键名在目标字典中不存在的则不改变。应该把 <tt class="function">update</tt> 看作是合并函数，而不是复制函数。</td>
</tr>
<tr>
<td width="12" valign="top" align="left">
<a href="#fileinfo.userdict.1.5"><img src="../images/callouts/5.png" alt="5" border="0" width="12" height="12"></a> </td>
<td valign="top" align="left">这个语法你可能以前没看过（我还没有在这本书中的例子中用过它）。这是一条 <tt class="literal">if</tt> 语句，但是没有在下一行有一个缩近块，而只是在冒号后面，在同一行上有单条语句。这完全是合法的，它只是当你在一个块中仅有一条语句时的一个简写。（它就象在 <span class="application"><span class="acronym">C++</span></span> 中没有用大括号包括的单行语句。） 你可以用这种语法，或者可以在后面的行拥有缩近代码，但是不能对同一个块同时用两种方式。</td>
</tr>
</table></div>
</div>
<a name="compare.overloading"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<span class="application">Java</span>  和 <span class="application">Powerbuilder</span> 支持通过参数列表的重载，<span class="foreignphrase"><i class="foreignphrase"><span class="acronym">也就是</span></i></span> 一个类可以有同名的多个方法，但这些方法或者是参数个数不同，或参数的类型不同。其它语言（最明显如 <span class="acronym">PL/SQL</span>）甚至支持通过参数名的重载，<span class="foreignphrase"><i class="foreignphrase"><span class="acronym">也就是</span></i></span> 一个类可以有同名的多个方法，这些方法有相同类型，相同个数的参数，但参数名不同。<span class="application">Python</span> 两种都不支持，总之是没有任何形式的函数重载。一个 <tt class="function">__init__</tt> 方法就是一个 <tt class="function">__init__</tt> 方法，不管它有什么样的参数。每个类只能有一个 <tt class="function">__init__</tt> 方法，并且如果一个子类拥有一个 <tt class="function">__init__</tt> 方法，它 <span class="emphasis"><em>总是</em></span> 覆盖父类的 <tt class="function">__init__</tt> 方法，甚至子类可以用不同的参数列表来定义它。</td></tr>
</table>
<a name="fileinfo.derivedclasses"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<span class="application">Python</span> 的原作者 Guido 是这样解释方法覆盖的 “子类可以覆盖父类中的方法。因为方法没有特殊的优先级设置，在调用同一对象的另外方法时，父类中一个方法对另一个同类中的方法的调用，可能其实调用到的却是一个子类中覆盖父类同名方法的方法。（对于 <span class="application"><span class="acronym">C++</span></span> 程序员，所有的 <span class="application">Python</span> 方法都非常有效）”  如果你不明白（它另我颇感困惑），不必在意。我想我要跳过它。</td></tr>
</table>
<a name="note.dataattributes"></a><table class="caution" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/caution.png" alt="小心" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">应该总是在 <tt class="function">__init__</tt> 方法中给一个实例的所有数据属性赋予一个初始值。这样做将会节省你在后面调试的时间，不必为捕捉因使用未初始化（也就是不存在）的属性而导致的 <tt class="classname">AttributeError</tt> 异常费时费力。</td></tr>
</table>
<div class="example">
<a name="fileinfo.userdict.normalmethods"></a><h3 class="title">例 5.10. <tt class="classname">UserDict</tt> 常规方法</h3>
<pre class="programlisting">
    <span class='pykeyword'>def</span><span class='pyclass'> clear</span>(self): self.data.clear()          <a name="fileinfo.userdict.2.1"></a><img src="../images/callouts/1.png" alt="1" border="0" width="12" height="12">
    <span class='pykeyword'>def</span><span class='pyclass'> copy</span>(self):                             <a name="fileinfo.userdict.2.2"></a><img src="../images/callouts/2.png" alt="2" border="0" width="12" height="12">
        <span class='pykeyword'>if</span> self.__class__ <span class='pykeyword'>is</span> UserDict:          <a name="fileinfo.userdict.2.3"></a><img src="../images/callouts/3.png" alt="3" border="0" width="12" height="12">
            <span class='pykeyword'>return</span> UserDict(self.data)         
        <span class='pykeyword'>import</span> copy                             <a name="fileinfo.userdict.2.4"></a><img src="../images/callouts/4.png" alt="4" border="0" width="12" height="12">
        <span class='pykeyword'>return</span> copy.copy(self)                 
    <span class='pykeyword'>def</span><span class='pyclass'> keys</span>(self): <span class='pykeyword'>return</span> self.data.keys()     <a name="fileinfo.userdict.2.5"></a><img src="../images/callouts/5.png" alt="5" border="0" width="12" height="12">
    <span class='pykeyword'>def</span><span class='pyclass'> items</span>(self): <span class='pykeyword'>return</span> self.data.items()  
    <span class='pykeyword'>def</span><span class='pyclass'> values</span>(self): <span class='pykeyword'>return</span> self.data.values()
</pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="12" valign="top" align="left">
<a href="#fileinfo.userdict.2.1"><img src="../images/callouts/1.png" alt="1" border="0" width="12" height="12"></a> </td>
<td valign="top" align="left">
<tt class="function">clear</tt> 是一个普通的类方法，可以在任何时候被任何人公开调用。注意，<tt class="function">clear</tt> 象所有的类方法一样（常规的或专用的），使用  <tt class="literal">self</tt>  作为它的第一个参数。（记住，当你调用方法时，不用包括 <tt class="literal">self</tt>；这件事是 <span class="application">Python</span> 替你做的。） 还应注意这个封装类的基本技术：将一个真正的字典 (<tt class="varname">data</tt>)  作为数据属性保存起来，定义所有真正字典所拥有的方法，并且将每个类方法重定向到真正字典上的相应方法。（在你忘记的情况下，字典的 <tt class="function">clear</tt> 方法 <a href="../native_data_types/index.html#odbchelper.dict.del" title="例 3.5. 从 dictionary 中删除元素">删除它的所有关键字</a> 和关键字相应的值。）</td>
</tr>
<tr>
<td width="12" valign="top" align="left">
<a href="#fileinfo.userdict.2.2"><img src="../images/callouts/2.png" alt="2" border="0" width="12" height="12"></a> </td>
<td valign="top" align="left">真正字典的 <tt class="filename">copy</tt>  方法会返回一个新的字典，它是原始字典的原样的复制（所有的键-值对都相同）。但是 <tt class="classname">UserDict</tt> 不能简单地重定向到 <tt class="function">self.data.copy</tt>，因为那个方法返回一个真正的字典，而我们想要的是返回同一个类的一个新的实例，就象是 <tt class="literal">self</tt>。</td>
</tr>
<tr>
<td width="12" valign="top" align="left">
<a href="#fileinfo.userdict.2.3"><img src="../images/callouts/3.png" alt="3" border="0" width="12" height="12"></a> </td>
<td valign="top" align="left">我们使用 <tt class="literal">__class__</tt> 属性来查看是否 <tt class="literal">self</tt> 是一个 <tt class="classname">UserDict</tt>，如果是，太好了，因为我们知道如何拷贝一个 <tt class="classname">UserDict</tt>：只要创建一个新的 <tt class="classname">UserDict</tt> ，并传给它真正的字典，这个字典已经存放在 <tt class="varname">self.data</tt> 中了。 然后你立即返回这个新的 <tt class="classname">UserDict</tt>，你甚至于不需要再下面一行中使用 <tt class="literal">import copy</tt>。</td>
</tr>
<tr>
<td width="12" valign="top" align="left">
<a href="#fileinfo.userdict.2.4"><img src="../images/callouts/4.png" alt="4" border="0" width="12" height="12"></a> </td>
<td valign="top" align="left">如果 <tt class="literal"><span class="literal">self</span>.<span class="literal">__class__</span></tt> 不是 <tt class="classname">UserDict</tt>，那么 <tt class="literal">self</tt> 一定是 <tt class="classname">UserDict</tt> 的某个子类（如可能为 <tt class="classname">FileInfo</tt>），生活总是存在意外。 <tt class="classname">UserDict</tt>  不知道如何生成它的子类的一个原样的拷贝，例如，有可能在子类中定义了其它的数据属性，所以我们只能完全复制它们，确定拷贝了它们的全部内容。幸运的是，<span class="application">Python</span> 带了一个模块可以正确地完成这件事，它叫做 <tt class="filename">copy</tt>。在这里我不想深入细节（然而它是一个绝对酷的模块，是否你想到要自已研究它了呢？）。说 <tt class="filename">copy</tt> 能够拷贝任何 <span class="application">Python</span> 对象就够了，这就是为什么我们在这里用它的原因。</td>
</tr>
<tr>
<td width="12" valign="top" align="left">
<a href="#fileinfo.userdict.2.5"><img src="../images/callouts/5.png" alt="5" border="0" width="12" height="12"></a> </td>
<td valign="top" align="left">其余的方法是直截了当的重定向到 <tt class="varname">self.data</tt> 的内置函数上。</td>
</tr>
</table></div>
</div>
<a name="id2631006"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 <span class="application">Python</span> 2.2 之前的版本中，你不可以直接子类化字符串、列表以及字典之类的内建数据类型。 作为补偿， <span class="application">Python</span> 提供封装类来模拟内建数据类型的行为，比如：<tt class="classname">UserString</tt>， <tt class="classname">UserList</tt> 和 <tt class="classname">UserDict</tt>。 通过混合使用普通和特殊方法， <tt class="classname">UserDict</tt> 类出色于模仿字典。 在 <span class="application">Python</span> 2.2 和其后的版本中，你可以直接从 <tt class="classname">dict</tt> 内建数据类型继承。本书 <tt class="filename">fileinfo_fromdict.py</tt> 中有这方面的一个例子。</td></tr>
</table>
<p>如例子中所示，在 <span class="application">Python</span> 中，你可以直接继承自内建数据类型 <tt class="classname">dict</tt>，这样做有三点与 <tt class="filename">UserDict</tt> 不同。</p>
<div class="example">
<a name="fileinfo.userdict.fromdict"></a><h3 class="title">例 5.11. 直接继承自内建数据类型 <tt class="classname">dict</tt></h3>
<pre class="programlisting"><span class='pykeyword'>
class</span> FileInfo(dict):                  <a name="fileinfo.userdict.3.1"></a><img src="../images/callouts/1.png" alt="1" border="0" width="12" height="12">
    <span class='pystring'>"store file metadata"</span>
    <span class='pykeyword'>def</span><span class='pyclass'> __init__</span>(self, filename=None): <a name="fileinfo.userdict.3.2"></a><img src="../images/callouts/2.png" alt="2" border="0" width="12" height="12">
        self[<span class='pystring'>"name"</span>] = filename
</pre>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="12" valign="top" align="left">
<a href="#fileinfo.userdict.3.1"><img src="../images/callouts/1.png" alt="1" border="0" width="12" height="12"></a> </td>
<td valign="top" align="left">第一个区别是你不需要导入 <tt class="filename">UserDict</tt> 模块，因为 <tt class="classname">dict</tt> 是已经可以使用的内建数据类型。第二个区别是你不是继承自 <tt class="function">UserDict.UserDict</tt> ，而是直接继承自 <tt class="classname">dict</tt>。</td>
</tr>
<tr>
<td width="12" valign="top" align="left">
<a href="#fileinfo.userdict.3.2"><img src="../images/callouts/2.png" alt="2" border="0" width="12" height="12"></a> </td>
<td valign="top" align="left">第三个区别有些晦涩，但却很重要。  <tt class="filename">UserDict</tt> 内部的工作方式要求你手工地调用它的 <tt class="function">__init__</tt> 方法去正确初始化它的内部数据结构。 <tt class="classname">dict</tt> 并不这样工作，它不是一个封装所以不需要明确的初始化。</td>
</tr>
</table></div>
</div>
<div class="furtherreading">
<h3>进一步阅读</h3>
<ul><li>
<a href="http://www.python.org/doc/current/lib/"><i class="citetitle"><span class="application">Python</span> Library Reference</i></a> 提供了 <a href="http://www.python.org/doc/current/lib/module-UserDict.html"><tt class="filename">UserDict</tt> 模块</a> 和 <a href="http://www.python.org/doc/current/lib/module-copy.html"><tt class="filename">copy</tt> 模块</a> 的文档。</li></ul>
</div>
</div>
<table class="Footer" width="100%" border="0" cellpadding="0" cellspacing="0" summary="">
<tr>
<td width="35%" align="left">
<br><a class="NavigationArrow" href="instantiating_classes.html">&lt;&lt; 类的实例化</a>
</td>
<td width="30%" align="center">
<br> <span class="divider">|</span> <a href="index.html#fileinfo.divein" title="5.1. 概览">1</a> <span class="divider">|</span> <a href="importing_modules.html" title="5.2. 使用 from module import 导入模块">2</a> <span class="divider">|</span> <a href="defining_classes.html" title="5.3. 类的定义">3</a> <span class="divider">|</span> <a href="instantiating_classes.html" title="5.4. 类的实例化">4</a> <span class="divider">|</span> <span class="thispage">5</span> <span class="divider">|</span> <a href="special_class_methods.html" title="5.6. 专用类方法">6</a> <span class="divider">|</span> <a href="special_class_methods2.html" title="5.7. 高级专用类方法">7</a> <span class="divider">|</span> <a href="class_attributes.html" title="5.8. 类属性介绍">8</a> <span class="divider">|</span> <a href="private_functions.html" title="5.9. 私有函数">9</a> <span class="divider">|</span> <a href="summary.html" title="5.10. 小结">10</a> <span class="divider">|</span> </td>
<td width="35%" align="right">
<br><a class="NavigationArrow" href="special_class_methods.html">专用类方法 &gt;&gt;</a>
</td>
</tr>
<tr><td colspan="3"><br></td></tr>
</table>
<div class="Footer"><p class="copyright">版权 © 2000, 2001, 2002, 2003, 2004 <a href="mailto:mark@diveintopython.org">Mark Pilgrim</a></p></div>
</body>
</html>
