<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>附录 C. 技巧和窍门</title>
<link rel="stylesheet" href="../diveintopython.css" type="text/css">
<link rev="made" href="mailto:f8dy@diveintopython.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.52.2">
<meta name="keywords" content="Python, Dive Into Python, tutorial, object-oriented, programming, documentation, book, free">
<meta name="description" content="Python from novice to pro">
<link rel="home" href="../toc/index.html" title="Dive Into Python">
<link rel="up" href="../toc/index.html" title="Dive Into Python">
<link rel="previous" href="abstracts.html" title="附录 B. 五分钟回顾">
<link rel="next" href="examples.html" title="附录 D. 示例清单">
</head>
<body>
<table id="Header" width="100%" border="0" cellpadding="0" cellspacing="0" summary="">
<tr>
<td id="breadcrumb" colspan="5" align="left" valign="top">导航: <a href="../index.html">起始页</a> &gt; <a href="../toc/index.html">Dive Into Python</a> &gt; <span class="thispage">技巧和窍门</span>
</td>
<td id="navigation" align="right" valign="top">   <a href="abstracts.html" title="上一页: “五分钟回顾”">&lt;&lt;</a>   <a href="examples.html" title="下一页: “示例清单”">&gt;&gt;</a>
</td>
</tr>
<tr>
<td colspan="3" id="logocontainer">
<h1 id="logo"><a href="../index.html" accesskey="1">Python 研究(Dive Into Python)</a></h1>
<p id="tagline">Python 从新手到高手 [DIP_5_4_CPUG_RELEASE]</p>
</td>
<td colspan="3" align="right"><form id="search" method="GET" action="http://www.google.com/custom"><p><label for="q" accesskey="4">Find: </label><input type="text" id="q" name="q" size="20" maxlength="255" value=" "> <input type="submit" value="搜索"><input type="hidden" name="cof" value="LW:752;L:http://diveintopython.org/images/diveintopython.png;LH:42;AH:left;GL:0;AWFID:3ced2bb1f7f1b212;"><input type="hidden" name="domains" value="diveintopython.org"><input type="hidden" name="sitesearch" value="diveintopython.org"></p></form></td>
</tr>
</table>
<!--#include virtual="/inc/ads" --><div class="appendix" lang="zh_cn">
<div class="titlepage">
<div><div><h2 class="title">
<a name="tips"></a>附录 C. 技巧和窍门</h2></div></div>
<div></div>
</div>
<p><a href="../installing_python/index.html">第 1 章 安装 Python</a></p>
<ul></ul>
<p><a href="../getting_to_know_python/index.html">第 2 章 第一个 Python 程序</a></p>
<ul>
<li>
<a href="../getting_to_know_python/index.html#odbchelper.divein">2.1. 概览</a><a name="tip.run.windows"></a><table class="tip" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/tip.png" alt="提示" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 Windows 的 <span class="application">ActivePython</span> <span class="acronym">IDE</span> 中, 可以选择
<span class="guimenu">File</span>-&gt;<span class="guimenuitem"><span class="accel">R</span>un...</span> (<span><b class="shortcut"><span><b class="keycap">Ctrl</b></span>-<span class="keysym">R</span></b></span>) 来运行 <span class="application">Python</span> 程序。输出结果将显示在交互窗口中。</td></tr>
</table>
<a name="tip.run.mac"></a><table class="tip" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/tip.png" alt="提示" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 <span class="abbrev">Mac</span> <span class="acronym">OS</span> 的 <span class="application">Python</span> <span class="acronym">IDE</span> 中, 可以选择
<span class="guimenu">Python</span>-&gt;<span class="guimenuitem">Run window...</span> (<span><b class="shortcut"><span><b class="keycap">Cmd</b></span>-<span class="keysym">R</span></b></span>) 来运行 <span class="application">Python</span> 程序, 但首先要设置一个重要的选项。在 <span class="acronym">IDE</span> 中打开 <tt class="filename">.py</tt> 模块, 点击窗口右上角的黑色三角, 弹出这个模块的选项菜单, 然后将 <span class="guimenuitem">Run as __main__</span> 选中。  这个设置是同模块一同保存的, 所以对于每个模块您都需要这样做。 </td></tr>
</table>
<a name="tip.run.unix"></a><table class="tip" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/tip.png" alt="提示" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 <span class="acronym">UNIX</span> 兼容的操作系统中 (包括 <span class="abbrev">Mac</span> <span class="acronym">OS</span> X), 可以通过命令行： <b class="userinput"><tt>python <tt class="filename">odbchelper.py</tt></tt></b> 运行模块。
</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../getting_to_know_python/declaring_functions.html">2.2. 函数声明</a><a name="compare.funcdef.vb"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 <span class="application">Visual Basic</span> 中, 函数 (有返回值) 以 <tt class="literal">function</tt> 开始, 而子程序 (无返回值) 以 <tt class="literal">sub</tt> 开始。在 <span class="application">Python</span> 中没有子程序。只有函数, 所有的函数都有返回值 (尽管可能为 <tt class="literal">None</tt>) , 并且所有的函数都以 <tt class="literal">def</tt> 开始。
</td></tr>
</table>
<a name="compare.funcdef.java"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 <span class="application">Java</span>, <span class="application"><span class="acronym">C++</span></span> 和其他静态类型语言中, 必须要指定函数返回值和每个函数参数的数据类型。 在 <span class="application">Python</span> 中, 永远也不需要明确指定任何东西的数据类型。<span class="application">Python</span> 会根据赋给它的值在内部将其数据类型记录下来。 </td></tr>
</table>
<p></p>
</li>
<li>
<a href="../getting_to_know_python/documenting_functions.html">2.3. 文档化函数</a><a name="compare.quoting.perl"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">三重引号也是一种定义既包含单引号又包含双引号的字符串的简单方法, 就像 <span class="application">Perl</span> 中的 <tt class="literal">qq/.../</tt> 。</td></tr>
</table>
<a name="tip.docstring"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">许多 <span class="application">Python</span> <span class="acronym">IDE</span> 使用 <tt class="literal">doc string</tt> 来提供上下文敏感文档信息, 所以当键入一个函数名时, 它的 <tt class="literal">doc string</tt> 显示为一个工具提示。这一点可以说非常有用, 但是它的好坏取决于您书写的 <tt class="literal">doc string</tt> 的好坏。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../getting_to_know_python/everything_is_an_object.html">2.4. 万物皆对象</a><a name="compare.import.perl"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 <span class="application">Python</span> 中的 <tt class="literal">import</tt> 就像 <span class="application">Perl</span> 中的 <tt class="literal">require</tt>。一旦 <tt class="literal">import</tt> 一个 <span class="application">Python</span> 模块, 您可以使用 <tt class="literal"><i class="replaceable">module</i>.<i class="replaceable">function</i></tt> 来访问它的函数；一旦您 <tt class="literal">require</tt> 一个 <span class="application">Perl</span> 模块, 您可以使用 <tt class="literal"><i class="replaceable">module</i>::<i class="replaceable">function</i></tt> 来访问它的函数。 </td></tr>
</table>
<p></p>
</li>
<li>
<a href="../getting_to_know_python/indenting_code.html">2.5. 代码缩进</a><a name="compare.lineend.java"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<span class="application">Python</span> 使用硬回车来分割语句, 冒号和缩进来分割代码块。<span class="application"><span class="acronym">C++</span></span> 和 <span class="application">Java</span> 使用分号来分割语句, 花括号来分割代码块。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../getting_to_know_python/testing_modules.html">2.6. 测试模块</a><a name="compare.equals.c"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">与 <span class="application"><span class="acronym">C</span></span> 一样, <span class="application">Python</span> 使用 <tt class="literal">==</tt> 做比较, 使用 <tt class="literal">=</tt> 做赋值。  与 <span class="application"><span class="acronym">C</span></span> 不一样, <span class="application">Python</span> 不支持行内赋值, 所以不会出现想要进行比较却意外地出现赋值的情况。</td></tr>
</table>
<a name="tip.mac.runasmain"></a><table class="tip" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/tip.png" alt="提示" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 <span class="application">MacPython</span> 上, 需要一个额外的步聚来使得 <tt class="literal">if</tt> <tt class="literal">__name__</tt> 技巧有效。  点击窗口右上角的黑色三角, 弹出模块的属性菜单, 确认 <span class="guimenuitem">Run as __main__</span> 被选中。</td></tr>
</table>
<p></p>
</li>
</ul>
<p><a href="../native_data_types/index.html">第 3 章 内置数据类型</a></p>
<ul>
<li>
<a href="../native_data_types/index.html#odbchelper.dict">3.1. Dictionary 介绍</a><a name="compare.dict.perl"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<span class="application">Python</span>  中的 dictionary 就象 <span class="application">Perl</span> 中的 hash (哈希数组)。在 <span class="application">Perl</span> 中, 存储哈希值的变量总是以  <tt class="literal">%</tt>  字符开始；在 <span class="application">Python</span> 中, 变量可以任意取名, 并且 <span class="application">Python</span> 在内部会记录下其数据类型。</td></tr>
</table>
<a name="compare.dict.java"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<span class="application">Python</span> 中的 dictionary 象 <span class="application">Java</span> 中的 <tt class="classname">Hashtable</tt> 类的实例。 </td></tr>
</table>
<a name="compare.dict.vb"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<span class="application">Python</span> 中的 dictionary 象 <span class="application">Visual Basic</span> 中的 <tt class="classname">Scripting.Dictionary</tt> 对象的实例。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../native_data_types/index.html#id2592725">3.1.2. Dictionary 的修改</a><a name="tip.dictorder"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">Dictionary 没有元素顺序的概念。说元素 “<span class="quote">顺序乱了</span>” 是不正确的, 它们只是序偶的简单排列。这是一个重要的特性, 它会在您想要以一种特定的, 可重复的顺序 (象以 key 的字母表顺序) 存取 dictionary 元素的时候骚扰您。有一些实现这些要求的方法, 它们只是没有加到 dictionary 中去。 </td></tr>
</table>
<p></p>
</li>
<li>
<a href="../native_data_types/lists.html">3.2. List 介绍</a><a name="compare.list.perl"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<span class="application">Python</span> 的 list 如同 <span class="application">Perl</span> 中的数组。在 <span class="application">Perl</span> 中, 用来保存数组的变量总是以 <tt class="literal">@</tt> 字符开始；在 <span class="application">Python</span> 中, 变量可以任意取名, 并且 <span class="application">Python</span> 在内部会记录下其数据类型。</td></tr>
</table>
<a name="compare.list.java"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<span class="application">Python</span> 中的 list 更象 <span class="application">Java</span> 中的数组 (您可以简单的这样理解, 但 <span class="application">Python</span> 中的 list 远比 <span class="application">Java</span> 中的数组强大)。一个更好的类比是 <tt class="classname">ArrayList</tt> 类, 它可以保存任意对象, 并且可以在增加新元素时动态扩展。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../native_data_types/lists.html#id2595086">3.2.3. 在 list 中搜索</a><a name="tip.boolean"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 2.2.1 版本之前, <span class="application">Python</span> 没有单独的布尔数据类型。 为了弥补这一点, <span class="application">Python</span> 在布尔环境 (如 <tt class="literal">if</tt> 语句) 中几乎接受所有东西, 遵循下面的规则:<div class="itemizedlist"><ul>
<li>
<tt class="constant">0</tt> 为 false; 其它所有数值皆为 true。</li>
<li>空串 (<tt class="literal">""</tt>) 为 false; 其它所有字符串皆为 true。</li>
<li>空 list (<tt class="literal">[]</tt>) 为 false; 其它所有 list 皆为 true。</li>
<li>空 tuple (<tt class="literal">()</tt>) 为 false; 其它所有 tuple 皆为 true。</li>
<li>空 dictionary (<tt class="literal">{}</tt>) 为 false; 其它所有 dictionary 皆为 true。</li>
</ul></div>这些规则仍然适用于 <span class="application">Python</span> 2.2.1 及其后续版本, 但现在您也可以使用真正的布尔值, 它的值或者为 <tt class="literal">True</tt> 或者为 <tt class="literal">False</tt>。 请注意第一个字母是大写的；这些值如同在 <span class="application">Python</span> 中的其它东西一样都是大小写敏感的。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../native_data_types/tuples.html">3.3. Tuple 介绍</a><a name="tip.tuple"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">Tuple 可以转换成 list, 反之亦然。内置的 <tt class="function">tuple</tt>  函数接收一个 list, 并返回一个有着相同元素的 tuple。而 <tt class="function">list</tt> 函数接收一个 tuple 返回一个 list。从效果上看, <tt class="function">tuple</tt> 冻结一个 list, 而 <tt class="function">list</tt> 解冻一个 tuple。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../native_data_types/declaring_variables.html">3.4. 变量声明</a><a name="tip.multiline"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">当一条命令用续行符 (“<span class="quote"><tt class="literal">\</tt></span>”) 分割成多行时, 后续的行可以以任何方式缩近, 此时 <span class="application">Python</span> 通常的严格的缩近规则无需遵守。如果您的 <span class="application">Python</span> <span class="acronym">IDE</span> 自由对后续行进行了缩近, 您应该把它当成是缺省处理, 除非您有特别的原因不这么做。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../native_data_types/formatting_strings.html">3.5. 格式化字符串</a><a name="compare.stringformatting.c"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 <span class="application">Python</span> 中, 字符串格式化使用与 <span class="application"><span class="acronym">C</span></span> 中 <tt class="function">sprintf</tt> 函数一样的语法。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../native_data_types/joining_lists.html">3.7. 连接 list 与分割字符串</a><a name="tip.join"></a><table class="caution" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/caution.png" alt="小心" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<tt class="function">join</tt> 只能用于元素是字符串的 list; 它不进行任何的类型强制转换。连接一个存在一个或多个非字符串元素的 list
 将引发一个异常。</td></tr>
</table>
<a name="tip.split"></a><table class="tip" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/tip.png" alt="提示" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<tt class="literal"><i class="replaceable">anystring</i>.<tt class="function">split</tt>(<i class="replaceable">delimiter</i>, 1)</tt> 是一个有用的技术, 在您想要搜索一个子串, 然后处理字串前面的东西 (即 list 中第一个元素) 和其后的东西 (即 list 中第二个元素) 时, 使用这个技术。</td></tr>
</table>
<p></p>
</li>
</ul>
<p><a href="../power_of_introspection/index.html">第 4 章 自省的威力</a></p>
<ul>
<li>
<a href="../power_of_introspection/optional_arguments.html">4.2. 使用可选参数和命名参数</a><a name="tip.arguments"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">调用函数时唯一需要做的事情就是为每一个必备参数指定值（以某种方式）；以何种具体的方式和顺序都取决于你。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../power_of_introspection/built_in_functions.html#id2613473">4.3.3. 内置函数</a><a name="tip.manuals"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<span class="application">Python</span> 提供了很多出色的参考手册，你应该好好的精读一下所有 <span class="application">Python</span> 提供的必备模块。对于其它大部分语言，你会发现自己要常常回头参考手册或者 man 页来提醒自己如何使用这些模块，但是 <span class="application">Python</span> 不同于此，它很大程度上是自文档化的。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../power_of_introspection/lambda_functions.html">4.7. 使用 lambda 函数</a><a name="tip.lambda"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<tt class="literal">lambda</tt> 函数是一种风格问题。不一定非要使用它们；任何能够使用它们的地方，都可以定义一个单独的普通函数来进行替换。我将它们用在需要封装特殊的、非重用代码上，避免另我的代码充斥着大量单行函数。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../power_of_introspection/all_together.html">4.8. 全部放在一起</a><a name="compare.isnull.sql"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 <span class="acronym">SQL</span> 中，你必须使用 <tt class="literal">IS NULL</tt> 代替 <tt class="literal">= NULL</tt> 进行 null 值比较。在 <span class="application">Python</span>，你可以使用 <tt class="literal">== None</tt> 或者 <tt class="literal">is None</tt> 进行比较，但是 <tt class="literal">is None</tt> 更快。</td></tr>
</table>
<p></p>
</li>
</ul>
<p><a href="../object_oriented_framework/index.html">第 5 章 对象和面向对象</a></p>
<ul>
<li>
<a href="../object_oriented_framework/importing_modules.html">5.2. 使用 from module import 导入模块</a><a name="compare.fromimport.perl"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<span class="application">Python</span> 中的 <tt class="literal">from <i class="replaceable">module</i> import *</tt> 象 <span class="application">Perl</span> 中的 <tt class="literal">use <i class="replaceable">module</i></tt> ；<span class="application">Python</span> 中的 <tt class="literal">import <i class="replaceable">module</i></tt> 象 <span class="application">Perl</span> 中的 <tt class="literal">require <i class="replaceable">module</i></tt> 。</td></tr>
</table>
<a name="compare.fromimport.java"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<span class="application">Python</span> 中的 <tt class="literal">from <i class="replaceable">module</i> import *</tt> 象 <span class="application">Java</span> 中的 <tt class="literal">import <i class="replaceable">module</i>.*</tt> ；<span class="application">Python</span> 中的 <tt class="literal">import <i class="replaceable">module</i></tt> 象 <span class="application">Java</span> 中的 <tt class="literal">import <i class="replaceable">module</i></tt> 。</td></tr>
</table>
<a name="id2627811"></a><table class="caution" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/caution.png" alt="小心" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">尽量少用 <tt class="literal">from module import *</tt> ，因为判定一个特殊的函数或属性是从哪来的有些困难，并且会造成调试和重构都更困难。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../object_oriented_framework/defining_classes.html">5.3. 类的定义</a><a name="compare.pass.java"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 <span class="application">Python</span> 中的 <tt class="literal">pass</tt> 语句就象 <span class="application">Java</span> 或 <span class="application"><span class="acronym">C</span></span> 中的大括号空集 (<tt class="literal">{}</tt>)。</td></tr>
</table>
<a name="compare.extends.java"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 <span class="application">Python</span> 中，类的基类只是简单地列在类名后面的小括号里。不象在 <span class="application">Java</span> 中有一个特殊的象 <tt class="literal">extends</tt> 的关键字。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../object_oriented_framework/defining_classes.html#id2628522">5.3.1. 初始化并开始类编码</a><a name="compare.self.java"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">习惯上，任何 <span class="application">Python</span> 类方法的第一个参数（对当前实例的引用）都叫做 <tt class="literal">self</tt>。这个参数扮演着 <span class="application"><span class="acronym">C++</span></span> 或 <span class="application">Java</span> 中的保留字 <tt class="literal">this</tt> 的角色，但 <tt class="literal">self</tt> 在 <span class="application">Python</span> 中并不是一个保留字，它只是一个命名习惯。虽然如此，也请除了 <tt class="literal">self</tt> 之外不要使用其它的名字，这是一个非常坚固的习惯。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../object_oriented_framework/defining_classes.html#id2628881">5.3.2. 了解何时去使用 self 和 __init__</a><a name="tip.initoptional"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<tt class="function">__init__</tt> 方法是可选的，但是一旦你定义了，就必须记得显示调用父类的 <tt class="function">__init__</tt> 方法（如果它定义了的话）。这样更是正确的：无论何时子类想扩展父类的行为，后代方法必须在适当的时机，使用适当的参数，显式调用父类方法。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../object_oriented_framework/instantiating_classes.html">5.4. 类的实例化</a><a name="compare.new.java"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 <span class="application">Python</span> 中，创建类的实例只要调用一个类，仿佛它是一个函数就行了。不象 <span class="application"><span class="acronym">C++</span></span> 或 <span class="application">Java</span> 有一个明确的 <tt class="literal">new</tt> 操作符。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../object_oriented_framework/userdict.html">5.5. 探索 UserDict: 一个封装类</a><a name="tip.locate"></a><table class="tip" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/tip.png" alt="提示" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 Windows 下的 <span class="application">ActivePython</span> <span class="acronym">IDE</span> 中，你可以快速打开在你的库路径中的任何模块，使用
<span class="guimenu">File</span>-&gt;<span class="guimenuitem"><span class="accel">L</span>ocate...</span> (<span><b class="shortcut"><span><b class="keycap">Ctrl</b></span>-<span class="keysym">L</span></b></span>)。</td></tr>
</table>
<a name="compare.overloading"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<span class="application">Java</span>  和 <span class="application">Powerbuilder</span> 支持通过参数列表的重载，<span class="foreignphrase"><i class="foreignphrase"><span class="acronym">也就是</span></i></span> 一个类可以有同名的多个方法，但这些方法或者是参数个数不同，或参数的类型不同。其它语言（最明显如 <span class="acronym">PL/SQL</span>）甚至支持通过参数名的重载，<span class="foreignphrase"><i class="foreignphrase"><span class="acronym">也就是</span></i></span> 一个类可以有同名的多个方法，这些方法有相同类型，相同个数的参数，但参数名不同。<span class="application">Python</span> 两种都不支持，总之是没有任何形式的函数重载。一个 <tt class="function">__init__</tt> 方法就是一个 <tt class="function">__init__</tt> 方法，不管它有什么样的参数。每个类只能有一个 <tt class="function">__init__</tt> 方法，并且如果一个子类拥有一个 <tt class="function">__init__</tt> 方法，它 <span class="emphasis"><em>总是</em></span> 覆盖父类的 <tt class="function">__init__</tt> 方法，甚至子类可以用不同的参数列表来定义它。</td></tr>
</table>
<a name="fileinfo.derivedclasses"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<span class="application">Python</span> 的原作者 Guido 是这样解释方法覆盖的 “子类可以覆盖父类中的方法。因为方法没有特殊的优先级设置，在调用同一对象的另外方法时，父类中一个方法对另一个同类中的方法的调用，可能其实调用到的却是一个子类中覆盖父类同名方法的方法。（对于 <span class="application"><span class="acronym">C++</span></span> 程序员，所有的 <span class="application">Python</span> 方法都非常有效）”  如果你不明白（它另我颇感困惑），不必在意。我想我要跳过它。</td></tr>
</table>
<a name="note.dataattributes"></a><table class="caution" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/caution.png" alt="小心" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">应该总是在 <tt class="function">__init__</tt> 方法中给一个实例的所有数据属性赋予一个初始值。这样做将会节省你在后面调试的时间，不必为捕捉因使用未初始化（也就是不存在）的属性而导致的 <tt class="classname">AttributeError</tt> 异常费时费力。</td></tr>
</table>
<a name="id2631006"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 <span class="application">Python</span> 2.2 之前的版本中，你不可以直接子类化字符串、列表以及字典之类的内建数据类型。 作为补偿， <span class="application">Python</span> 提供封装类来模拟内建数据类型的行为，比如：<tt class="classname">UserString</tt>， <tt class="classname">UserList</tt> 和 <tt class="classname">UserDict</tt>。 通过混合使用普通和特殊方法， <tt class="classname">UserDict</tt> 类出色于模仿字典。 在 <span class="application">Python</span> 2.2 和其后的版本中，你可以直接从 <tt class="classname">dict</tt> 内建数据类型继承。本书 <tt class="filename">fileinfo_fromdict.py</tt> 中有这方面的一个例子。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../object_oriented_framework/special_class_methods.html#id2631329">5.6.1. 获得和设置数据项</a><a name="tip.self.call"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">当在一个类中存取数据属性时，你需要限定属性名：<tt class="literal">self.<i class="replaceable">attribute</i></tt>。当调用类中的其它方法时，你属要限定方法名：<tt class="literal">self.<i class="replaceable">method</i></tt>。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../object_oriented_framework/special_class_methods2.html">5.7. 高级专用类方法</a><a name="compare.strequals.java"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 <span class="application">Java</span> 中，通过使用 <tt class="literal">str1 == str2</tt> 可以决定两个字符串变量是否指向同一块物理内存位置。这就做 <span class="emphasis"><em>对象同一性</em></span>，在 <span class="application">Python</span> 中写为 <tt class="literal">str1 is str2</tt>。在 <span class="application">Java</span> 中为了比较两个字符串值，你要使用 <tt class="literal">str1.equals(str2)</tt>；在 <span class="application">Python</span> 中，你要使用 <tt class="literal">str1 == str2</tt>。 某些 <span class="application">Java</span> 程序员，他们已经被教授得认为，因为在 <span class="application">Java</span> 中 <tt class="literal">==</tt> 是通过一致性而不是值来进行比较的，所以 <span class="application">Java</span> 是更好的地方。这些人要转到 <span class="application">Python</span> 上来可能要花些时间。在 <span class="application">Java</span> 中，你通过 <tt class="literal">str1 == str2</tt> 来比较两个字符串是否指向同一物理内存位置。这被称作 <span class="emphasis"><em>对象确定（object identity）</em></span>， 在 <span class="application">Python</span> 中被写作 <tt class="literal">str1 is str2</tt>。 在 <span class="application">Java</span> 中比较字符串使用 <tt class="literal">str1.equals(str2)</tt> ，而在 <span class="application">Python</span> 中，你使用 <tt class="literal">str1 == str2</tt>。那些素来认为 <span class="application">Java</span> 中比较对象身份而不是值的 <tt class="literal">==</tt> 令世界变得更好的 <span class="application">Java</span> 程序员可能对 <span class="application">Python</span> 中的“<span class="quote">这个缺少</span>”接受起来有困难。</td></tr>
</table>
<a name="note.physical.v.logical"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">其它的面向对象语言仅让你定义一个对象的物理模型（“<span class="quote">这个对象有 <tt class="function">GetLength</tt> 方法</span>”），而 <span class="application">Python</span> 的专用类方法象 <tt class="function">__len__</tt> 允许你定义一个对象的逻辑模型（“<span class="quote">这个对象有一个长度</span>”）。
</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../object_oriented_framework/class_attributes.html">5.8. 类属性介绍</a><a name="compare.classattr.java"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 <span class="application">Java</span> 中，静态变量（在 <span class="application">Python</span> 中叫类属性）和实例变量（在 <span class="application">Python</span> 中叫数据属性）两者是紧跟在类定义之后定义的（一个有 <tt class="literal">static</tt> 关键字，一个没有）。在 <span class="application">Python</span> 中，只有类属性可以定义在这里，数据属性定义在 <tt class="function">__init__</tt> 方法中。</td></tr>
</table>
<a name="id2634056"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 <span class="application">Python</span> 中没有常量。如果你试图努力的话什么都可以改变。这一点满足 <span class="application">Python</span> 的核心原则之一：坏的行为应该被克服而不是被取缔。如果你真正想改变 <tt class="literal">None</tt> 的值，也可以做到，但当无法调试的时候别来找我。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../object_oriented_framework/private_functions.html">5.9. 私有函数</a><a name="tip.specialmethodnames"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 <span class="application">Python</span> 中，所有的专用方法（象 <a href="special_class_methods.html#fileinfo.specialmethods.setitem.example" title="例 5.13. __setitem__ 专用方法"><tt class="function">__setitem__</tt></a>）和内置属性（象 <a href="../getting_to_know_python/everything_is_an_object.html#odbchelper.import" title="例 2.3. 访问 buildConnectionString 函数的 doc string"><tt class="literal">__doc__</tt></a>）遵守一个标准的命名习惯：开始和结束都有两个下划下。不要对你自已的方法和属性用这种方法命名；到后面，它只会把你（或其它人）搞乱。</td></tr>
</table>
<p></p>
</li>
</ul>
<p><a href="../file_handling/index.html">第 6 章 异常和文件处理</a></p>
<ul>
<li>
<a href="../file_handling/index.html#fileinfo.exception">6.1. 异常处理</a><a name="compare.exceptions.java"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<span class="application">Python</span> 使用 <tt class="literal">try...except</tt> 来处理异常，使用 <tt class="literal">raise</tt> 来引发异常。  <span class="application">Java</span> 和 <span class="application"><span class="acronym">C++</span></span> 使用 <tt class="literal">try...catch</tt> 来处理异常，使用 <tt class="literal">throw</tt> 来引发异常。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../file_handling/os_module.html">6.5. 与 Directory 共事</a><a name="tip.os"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">只要有可能，你应该使用在 <tt class="filename">os</tt> 和 <tt class="filename">os.path</tt> 中的函数进行文件，目录，和路径的操作。这些模块是对平台相关模块的封装模块，所以象 <tt class="function">os.path.split</tt> 这样的函数可以工作在 <span class="acronym">UNIX</span>, Windows, <span class="abbrev">Mac</span> <span class="acronym">OS</span> 和 <span class="application">Python</span> 所支持的任一种平台上。</td></tr>
</table>
<p></p>
</li>
</ul>
<p><a href="../regular_expressions/index.html">第 7 章 正则表达式</a></p>
<ul>
<li>
<a href="../regular_expressions/roman_numerals.html">7.3. 个案研究：罗马字母</a><a name="id2663398"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">本章译者注：“被5整除的数”这个译法并不严谨，因为所有被10整除的数也能够被5整除，此处表达的含义是：那些包含有5的含义的罗马数字字符。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../regular_expressions/n_m_syntax.html">7.4. 使用{n,m} 语法</a><a name="id2665304"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">没有一个轻松的方法来确定两个正则表达式是否为等价的，你能采用的最好的办法就是列出很多的测试样例，确定这两个正则表达式对所有的相关输入都有相同的输出。在本书后面的章节，关于如何书写测试样例有更多的讨论。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../regular_expressions/n_m_syntax.html#id2665316">7.4.1. 校验十位数和个位数</a><a name="id2666354"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">本章译者注：这个例子在正则表达式的匹配上没有问题，但是对于罗马数字的表示办法本身似乎有点问题，代表千位数的字符<tt class="literal">M</tt>，根据规定最多只能重复3次，但是在这个例子中重复了4次，但是这个罗马数字最后又表示3888，此处矛盾。不过，我们是为了搞清楚正则表达式的用法，罗马数字的表示法不是重点，因此从这个角度，这个例子没有问题。因此，在翻译的过程中保持了原文，大家在理解的时候需要注意一下这里。</td></tr>
</table>
<p></p>
</li>
</ul>
<p><a href="../html_processing/index.html">第 8 章 HTML 处理</a></p>
<ul>
<li>
<a href="../html_processing/introducing_sgmllib.html">8.2. sgmllib.py 介绍</a><a name="id2677428"></a><table class="important" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/important.png" alt="重要" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<span class="application">Python</span> 2.0 存在一个 bug，即 <tt class="classname">SGMLParser</tt> 完全不能识别声明(<tt class="function">handle_decl</tt> 永远不会调用)，这就意味着 <tt class="sgmltag-element">DOCTYPE</tt> 被静静地忽略掉了。在这错误在 <span class="application">Python</span> 2.1 中改正了。</td></tr>
</table>
<a name="tip.commandline.windows"></a><table class="tip" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/tip.png" alt="提示" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在 Windows 下的 <span class="application">ActivePython</span> <span class="acronym">IDE</span> 中，您可以在 “<span class="quote">Run script</span>” 对话框中指定命令行参数。用空格将多个参数分开。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../html_processing/basehtmlprocessor.html">8.4. BaseHTMLProcessor.py 介绍</a><a name="id2679460"></a><table class="important" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/important.png" alt="重要" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<span class="acronym">HTML</span> 规范要求所有非 <span class="acronym">HTML</span> (象客户端的 <span class="application">JavaScript</span>) 必须包括在 <span class="acronym">HTML</span> 注释中，但不是所有的页面都是这么做的 (而且所有的最新的浏览器也都容许不这样做) 。<tt class="classname">BaseHTMLProcessor</tt> 不允许这样，如果脚本嵌入的不正确，它将被当作 <span class="acronym">HTML</span> 一样进行分析。例如，如果脚本包含了小于和等于号，<tt class="classname">SGMLParser</tt> 可能会错误地认为找到了标记和属性。<tt class="classname">SGMLParser</tt> 总是把标记名和属性名转换成小写，这样可能破坏了脚本，并且 <tt class="classname">BaseHTMLProcessor</tt> 总是用双引号来将属性封闭起来 (尽管原始的 <span class="acronym">HTML</span> 文档可能使用单引号或没有引号) ，这样必然会破坏脚本。应该总是将您的客户端脚本放在 <span class="acronym">HTML</span> 注释中进行保护。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../html_processing/locals_and_globals.html">8.5. locals 和 globals</a><a name="id2680054"></a><table class="important" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/important.png" alt="重要" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<span class="application">Python</span> 2.2 引入了一种略有不同但重要的改变，它会影响名字空间的搜索顺序: 嵌套的作用域。

在 <span class="application">Python</span> 2.2 版本之前，当您在一个<a href="../file_handling/all_together.html#fileinfo.nested" title="例 6.21. listDirectory">嵌套函数</a> 或 <a href="../power_of_introspection/lambda_functions.html" title="4.7. 使用 lambda 函数"><tt class="literal">lambda</tt> 函数</a> 中引用一个变量时，<span class="application">Python</span> 会在当前 (嵌套的或 <tt class="literal">lambda</tt>) 函数的名字空间中搜索，然后在模块的名字空间。<span class="application">Python</span> 2.2 将只在当前 (嵌套的或 <tt class="literal">lambda</tt>) 函数的名字空间中搜索，<span class="emphasis"><em>然后是在父函数的名字空间</em></span>中搜索，接着是模块的名字空间中搜索。<span class="application">Python</span> 2.1 可 以两种方式工作，缺省地，按 <span class="application">Python</span> 2.0 的方式工作。但是您可以把下面一行代码增加到您的模块头部，使您的模块工作起来象 <span class="application">Python</span> 2.2 的方式:<pre class="programlisting"><span class='pykeyword'>
from</span> __future__ <span class='pykeyword'>import</span> nested_scopes</pre>
</td></tr>
</table>
<a name="tip.localsbyname"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">使用 <tt class="function">locals</tt> 和 <tt class="function">globals</tt> 函数，通过提供变量的字符串名字您可以动态地得到任何变量的值。这种方法提供了这样的功能: <a href="../power_of_introspection/getattr.html" title="4.4. 通过 getattr 获取对象引用"><tt class="function">getattr</tt></a> 函数允许您通过提供函数的字符串名来动态地访问任意的函数。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../html_processing/dictionary_based_string_formatting.html">8.6. 基于 dictionary 的字符串格式化</a><a name="id2681831"></a><table class="important" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/important.png" alt="重要" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">使用 <tt class="function">locals</tt> 来应用基于 dictionary 的字符串格式化是一种方便的作法，它可以使复杂的字符串格式化表达式更易读。但它需要花费一定的代价。在调用 <tt class="function">locals</tt> 方面有一点性能上的问题，这是由于 <a href="locals_and_globals.html#dialect.locals.readonly.example" title="例 8.12. locals 是只读的, globals 不是"> <tt class="function">locals</tt> 创建了局部名字空间的一个拷贝 </a> 引起的。</td></tr>
</table>
<p></p>
</li>
</ul>
<p><a href="../xml_processing/index.html">第 9 章 XML 处理</a></p>
<ul>
<li>
<a href="../xml_processing/packages.html">9.2. 包</a><a name="id2694322"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">一个包是一个其中带有特殊文件 <tt class="filename">__init__.py</tt> 的目录。<tt class="filename">__init__.py</tt> 文件定义了包的属性和方法。其实它可以什么也不定义；可以只是一个空文件，但是必须要存在。如果 <tt class="filename">__init__.py</tt> 不存在，这个目录就仅仅是一个目录，而不是一个包，它就不能被导入或者包含其它的模块和嵌套包。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../xml_processing/attributes.html">9.6. 访问元素属性</a><a name="id2698248"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">这部分由于某个涵义重叠的术语可能让人有点糊涂。在一个 <span class="acronym">XML</span> 文档中，元素可以有属性，而 <span class="application">Python</span> 对象也有属性。当你解析一个 <span class="acronym">XML</span> 文档时，你得到了一组 <span class="application">Python</span> 对象，它们代表 <span class="acronym">XML</span> 文档中的所有片段，同时有些 <span class="application">Python</span> 对象代表 <span class="acronym">XML</span> 元素的属性。但是表示（<span class="acronym">XML</span>）属性的（<span class="application">Python</span>）对象也有（<span class="application">Python</span>）属性，它们用于访问对象表示的（<span class="acronym">XML</span>）属性。我告诉过你它让人糊涂。我会公开提出关于如何更明显地区分这些不同的建议。
</td></tr>
</table>
<a name="id2698834"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">类似于字典，一个 <span class="acronym">XML</span> 元素的属性没有顺序。属性可以以某种顺序<span class="emphasis"><em>偶然</em></span>列在最初的 <span class="acronym">XML</span> 文档中，而在 <span class="acronym">XML</span> 文档解析为 <span class="application">Python</span> 对象时，<tt class="classname">Attr</tt> 对象以某种顺序<span class="emphasis"><em>偶然</em></span>列出，这些顺序都是任意的，没有任何特别的含义。你应该总是使用名称来访问单个属性，就像字典的键一样。</td></tr>
</table>
<p></p>
</li>
</ul>
<p><a href="../scripts_and_streams/index.html">第 10 章 Scripts 和 Streams</a></p>
<ul></ul>
<p><a href="../http_web_services/index.html">第 11 章 HTTP Web 服务</a></p>
<ul><li>
<a href="../http_web_services/etags.html">11.6. 处理 Last-Modified 和 ETag</a><a name="tip.etag.vs.lastmodified"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在这些例子中, HTTP 服务器同时支持 <tt class="literal">Last-Modified</tt> 和 <tt class="literal">ETag</tt> 头信息, 但并非所有的服务器皆如此。 作为一个 web 服务的客户, 你应该为支持两种头信息做准备, 但是你的程序也应该为服务器仅支持其中一种头信息或两种头信息都不支持而做准备。</td></tr>
</table>
<p></p>
</li></ul>
<p><a href="../soap_web_services/index.html">第 12 章 SOAP Web 服务</a></p>
<ul></ul>
<p><a href="../unit_testing/index.html">第 13 章 单元测试</a></p>
<ul><li>
<a href="../unit_testing/diving_in.html">13.2. 深入</a><a name="note.unittest"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<span class="application">Python</span> 2.1 和之后的版本已经包含了 <tt class="filename">unittest</tt>。<span class="application">Python</span> 2.0 用户则可以从 <a href="http://pyunit.sourceforge.net/"><tt class="systemitem">pyunit.sourceforge.net</tt></a>下载。</td></tr>
</table>
<p></p>
</li></ul>
<p><a href="../unit_testing/stage_1.html">第 14 章 以测试优先为原则的编程</a></p>
<ul>
<li>
<a href="../unit_testing/stage_3.html">14.3. roman.py, 第 3 阶段</a><a name="id2748091"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">全面的单元测试能够告诉你的最重要的事情是什么时候停止编写代码。当一个函数的所有单元测试都通过了，停止编写这个函数。一旦一个完整模块的单元测试通过了，停止编写这个模块。</td></tr>
</table>
<p></p>
</li>
<li>
<a href="../unit_testing/stage_5.html">14.5. roman.py, 第 5 阶段</a><a name="id2749816"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">当所有测试都通过了，停止编程。</td></tr>
</table>
<p></p>
</li>
</ul>
<p><a href="../refactoring/index.html">第 15 章 重构</a></p>
<ul><li>
<a href="../refactoring/refactoring.html">15.3. 重构</a><a name="id2752225"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">在需要多次使用同一个正则表达式的情况下，应该将它进行编译以获得一个 pattern 对象，然后直接调用这个 pattern 对象的方法。</td></tr>
</table>
<p></p>
</li></ul>
<p><a href="../functional_programming/index.html">第 16 章 有效编程（Functional Programming）</a></p>
<ul><li>
<a href="../functional_programming/finding_the_path.html">16.2. 找到路径</a><a name="os.path.abspath.exist.note"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">传递给 <tt class="function">os.path.abspath</tt> 的路径名和文件名可以不存在。</td></tr>
</table>
<a name="os.path.normpath.note"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<tt class="function">os.path.abspath</tt> 不仅构建完整路径名，还能格式化路径名。 这意味着如果你正工作于 <tt class="filename">/usr/</tt> 目录， <tt class="literal">os.path.abspath('bin/../local/bin')</tt> 将会返回 <tt class="filename">/usr/local/bin</tt> 。 它以尽可能简单的方式格式化路径名。 如果你只是希望简单地返回这样的格式化路径名而不需要完整路径名可以使用 <tt class="function">os.path.normpath</tt>。</td></tr>
</table>
<a name="os.path.abspath.crossplatform.note"></a><table class="note" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/note.png" alt="注意" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">就像 <tt class="filename">os</tt> 和 <tt class="filename">os.path</tt> 模块的其他函数， <tt class="function">os.path.abspath</tt> 是跨平台的。 如果你是在 Windows （使用反斜杠作为路径符号）或 <span class="abbrev">Mac</span> <span class="acronym">OS</span> （使用冒号）上运行，它们同样工作，只是将获得与我稍有不同的结果。 <tt class="filename">os</tt> 的所有函数都是这样的。</td></tr>
</table>
<p></p>
</li></ul>
<p><a href="../dynamic_functions/index.html">第 17 章 动态函数</a></p>
<ul></ul>
<p><a href="../performance_tuning/index.html">第 18 章 性能优化</a></p>
<ul><li>
<a href="../performance_tuning/timeit.html">18.2. 使用 timeit 模块</a><a name="id2783909"></a><table class="tip" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/tip.png" alt="提示" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">你可以在命令行使用 <tt class="filename">timeit</tt> 模块来测试一个已存在的 <span class="application">Python</span> 程序，而不需要修改代码。在 <a href="http://docs.python.org/lib/node396.html">http://docs.python.org/lib/node396.html</a> 查看文档中关于命令行选项的内容。</td></tr>
</table>
<a name="id2784139"></a><table class="tip" border="0" summary="">
<tr><td rowspan="2" align="center" valign="top" width="1%"><img src="../images/tip.png" alt="提示" title="" width="24" height="24"></td></tr>
<tr><td colspan="2" align="left" valign="top" width="99%">
<tt class="filename">timeit</tt> 模块只有在你知道那段代码需要优化时使用。 如果你有一个很大的 <span class="application">Python</span> 程序并且不知道你的性能问题所在，到 <a href="http://docs.python.org/lib/module-hotshot.html"> 查看 <tt class="filename">hotshot</tt> 模块</a>。</td></tr>
</table>
<p></p>
</li></ul>
</div>
<table class="Footer" width="100%" border="0" cellpadding="0" cellspacing="0" summary="">
<tr>
<td width="35%" align="left">
<br><a class="NavigationArrow" href="abstracts.html">&lt;&lt; 五分钟回顾</a>
</td>
<td width="30%" align="center">
<br> <span class="divider">|</span>  <span class="divider">|</span> </td>
<td width="35%" align="right">
<br><a class="NavigationArrow" href="examples.html">示例清单 &gt;&gt;</a>
</td>
</tr>
<tr><td colspan="3"><br></td></tr>
</table>
<div class="Footer"><p class="copyright">版权 © 2000, 2001, 2002, 2003, 2004 <a href="mailto:mark@diveintopython.org">Mark Pilgrim</a></p></div>
</body>
</html>
