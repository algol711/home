<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>附录 B. 五分钟回顾</title>
<link rel="stylesheet" href="../diveintopython.css" type="text/css">
<link rev="made" href="mailto:f8dy@diveintopython.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.52.2">
<meta name="keywords" content="Python, Dive Into Python, tutorial, object-oriented, programming, documentation, book, free">
<meta name="description" content="Python from novice to pro">
<link rel="home" href="../toc/index.html" title="Dive Into Python">
<link rel="up" href="../toc/index.html" title="Dive Into Python">
<link rel="previous" href="furtherreading.html" title="附录 A. 进一步阅读">
<link rel="next" href="tips.html" title="附录 C. 技巧和窍门">
</head>
<body>
<table id="Header" width="100%" border="0" cellpadding="0" cellspacing="0" summary="">
<tr>
<td id="breadcrumb" colspan="5" align="left" valign="top">导航: <a href="../index.html">起始页</a> &gt; <a href="../toc/index.html">Dive Into Python</a> &gt; <span class="thispage">五分钟回顾</span>
</td>
<td id="navigation" align="right" valign="top">   <a href="furtherreading.html" title="上一页: “进一步阅读”">&lt;&lt;</a>   <a href="tips.html" title="下一页: “技巧和窍门”">&gt;&gt;</a>
</td>
</tr>
<tr>
<td colspan="3" id="logocontainer">
<h1 id="logo"><a href="../index.html" accesskey="1">Python 研究(Dive Into Python)</a></h1>
<p id="tagline">Python 从新手到高手 [DIP_5_4_CPUG_RELEASE]</p>
</td>
<td colspan="3" align="right"><form id="search" method="GET" action="http://www.google.com/custom"><p><label for="q" accesskey="4">Find: </label><input type="text" id="q" name="q" size="20" maxlength="255" value=" "> <input type="submit" value="搜索"><input type="hidden" name="cof" value="LW:752;L:http://diveintopython.org/images/diveintopython.png;LH:42;AH:left;GL:0;AWFID:3ced2bb1f7f1b212;"><input type="hidden" name="domains" value="diveintopython.org"><input type="hidden" name="sitesearch" value="diveintopython.org"></p></form></td>
</tr>
</table>
<!--#include virtual="/inc/ads" --><div class="appendix" lang="zh_cn">
<div class="titlepage">
<div><div><h2 class="title">
<a name="abstracts"></a>附录 B. 五分钟回顾</h2></div></div>
<div></div>
</div>
<p><a href="../installing_python/index.html">第 1 章 安装 Python</a></p>
<ul>
<li>
<a href="../installing_python/index.html#install.choosing">1.1. 哪一种 Python 适合您？</a><blockquote><div class="abstract"><p>学习 <span class="application">Python</span> 的第一件事就是安装, 不是吗？</p></div></blockquote>
</li>
<li>
<a href="../installing_python/windows.html">1.2. Windows 上的 Python</a><blockquote><div class="abstract"><p>在 Windows 上, 安装 <span class="application">Python</span> 有两种选择。</p></div></blockquote>
</li>
<li>
<a href="../installing_python/macosx.html">1.3. Mac OS X 上的 Python </a><blockquote><div class="abstract"><p>在 <span class="abbrev">Mac</span> <span class="acronym">OS</span> X 上, 对于安装 <span class="application">Python</span> 有两种选择: 安装或不安装。您可能想要安装它。</p></div></blockquote>
</li>
<li>
<a href="../installing_python/macos9.html">1.4. Mac OS 9 上的 Python </a><blockquote><div class="abstract"><p><span class="abbrev">Mac</span> <span class="acronym">OS</span> 9 上没有预装任何版本的 <span class="application">Python</span>, 安装相对简单, 只有一种选择。</p></div></blockquote>
</li>
<li>
<a href="../installing_python/redhat.html">1.5. RedHat Linux 上的 Python </a><blockquote><div class="abstract"><p>在 <a href="http://www.python.org/ftp/python/">http://www.python.org/ftp/python/</a> 选择列出的最新的版本号, 然后选择
其中的<tt class="filename">rpms/</tt> 目录下载最新的  <span class="application">Python</span> <span class="acronym">RPM</span> 。  
使用 <span><b class="command">rpm</b></span> 命令进行安装, 操作如下所示:</p></div></blockquote>
</li>
<li>
<a href="../installing_python/debian.html">1.6. Debian GNU/Linux 上的 Python </a><blockquote><div class="abstract"><p>如果您碰巧运行在 Debian <span class="acronym">GNU</span>/Linux 上, 安装 <span class="application">Python</span> 需要使用 <span><b class="command">apt</b></span> 命令。</p></div></blockquote>
</li>
<li>
<a href="../installing_python/source.html">1.7. 从源代码安装 Python </a><blockquote><div class="abstract"><p>如果您宁愿从源码创建, 可以从 <a href="http://www.python.org/ftp/python/">http://www.python.org/ftp/python/</a>下载 <span class="application">Python</span> 的源代码。选择最新的版本, 下载<tt class="filename">.tgz</tt> 文件, 执行通常的 <b class="userinput"><tt>configure</tt></b>, <b class="userinput"><tt>make</tt></b>, <b class="userinput"><tt>make install</tt></b> 步骤。</p></div></blockquote>
</li>
<li>
<a href="../installing_python/shell.html">1.8. 使用 Python 的交互 Shell</a><blockquote><div class="abstract"><p>既然我们已经安装了 <span class="application">Python</span> , 那么我们运行的这个交互shell是什么东西呢？</p></div></blockquote>
</li>
<li>
<a href="../installing_python/summary.html">1.9. 小结</a><blockquote><div class="abstract"><p>您现在应该已经安装了一个可以工作的 <span class="application">Python</span> 版本了。</p></div></blockquote>
</li>
</ul>
<p><a href="../getting_to_know_python/index.html">第 2 章 第一个 Python 程序</a></p>
<ul>
<li>
<a href="../getting_to_know_python/index.html#odbchelper.divein">2.1. 概览</a><blockquote><div class="abstract"><p>这是一个完整的, 可执行的 <span class="application">Python</span> 程序。</p></div></blockquote>
</li>
<li>
<a href="../getting_to_know_python/declaring_functions.html">2.2. 函数声明</a><blockquote><div class="abstract"><p>与其它大多数语言一样 <span class="application">Python</span> 有函数, 但是它没有像 <span class="application"><span class="acronym">C++</span></span> 一样的独立的头文件；或者像 <span class="application">Pascal</span> 一样的分离的  <tt class="literal">interface</tt>/<tt class="literal">implementation</tt> 段。 一旦需要函数时, 像下面这样声明即可:</p></div></blockquote>
</li>
<li>
<a href="../getting_to_know_python/documenting_functions.html">2.3. 文档化函数</a><blockquote><div class="abstract"><p>可以通过给出一个 <tt class="literal">doc string</tt> (文档字符串) 文档化一个 <span class="application">Python</span> 函数。</p></div></blockquote>
</li>
<li>
<a href="../getting_to_know_python/everything_is_an_object.html">2.4. 万物皆对象</a><blockquote><div class="abstract"><p>在 <span class="application">Python</span> 中, 函数同其它东西一样也是对象。</p></div></blockquote>
</li>
<li>
<a href="../getting_to_know_python/indenting_code.html">2.5. 代码缩进</a><blockquote><div class="abstract"><p><span class="application">Python</span> 函数没有明显的 <tt class="literal">begin</tt> 和 <tt class="literal">end</tt>, 没有花括号, 用于标函数的开始和结束。  唯一的分隔符是一个冒号 (<tt class="literal">:</tt>), 接着代码本身是缩进的。</p></div></blockquote>
</li>
<li>
<a href="../getting_to_know_python/testing_modules.html">2.6. 测试模块</a><blockquote><div class="abstract"><p>所有的 <span class="application">Python</span> 模块都是对象并且有几个有用的属性。 您可以使用这些属性方便地测试您所书写的模块。 下面是一个使用  <tt class="literal">if</tt> <tt class="literal">__name__</tt> 的技巧。</p></div></blockquote>
</li>
</ul>
<p><a href="../native_data_types/index.html">第 3 章 内置数据类型</a></p>
<ul>
<li>
<a href="../native_data_types/index.html#odbchelper.dict">3.1. Dictionary 介绍</a><blockquote><div class="abstract"><p>Dictionary 是 <span class="application">Python</span> 的内置数据类型之一, 它定义了键和值之间一对一的关系。</p></div></blockquote>
</li>
<li>
<a href="../native_data_types/lists.html">3.2. List 介绍</a><blockquote><div class="abstract"><p>List 是 <span class="application">Python</span> 中使用最频繁的数据类型。 如果您对 list 仅有的经验就是在 <span class="application">Visual Basic</span> 中的数组或 <span class="application">Powerbuilder</span> 中的数据存储, 那么就打起精神学习 <span class="application">Python</span> 的 list 吧。</p></div></blockquote>
</li>
<li>
<a href="../native_data_types/tuples.html">3.3. Tuple 介绍</a><blockquote><div class="abstract"><p>Tuple 是不可变 list。 一旦创建了一个 tuple 就不能以任何方式改变它。</p></div></blockquote>
</li>
<li>
<a href="../native_data_types/declaring_variables.html">3.4. 变量声明</a><blockquote><div class="abstract"><p><span class="application">Python</span> 与大多数其它语言一样有局部变量和全局变量之分, 但是它没有明显的变量声明。变量通过首次赋值产生, 当超出作用范围时自动消亡。</p></div></blockquote>
</li>
<li>
<a href="../native_data_types/formatting_strings.html">3.5. 格式化字符串</a><blockquote><div class="abstract"><p><span class="application">Python</span> 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式, 但最基本的用法是将一个值插入到一个有字符串格式符 <tt class="literal">%s</tt> 的字符串中。</p></div></blockquote>
</li>
<li>
<a href="../native_data_types/mapping_lists.html">3.6. 映射 list</a><blockquote><div class="abstract"><p><span class="application">Python</span> 的强大特性之一是其对 list 的解析, 它提供一种紧凑的方法, 可以通过对 list 中的每个元素应用一个函数, 从而将一个 list 映射为另一个 list。</p></div></blockquote>
</li>
<li>
<a href="../native_data_types/joining_lists.html">3.7. 连接 list 与分割字符串</a><blockquote><div class="abstract"><p>您有了一个形如 <tt class="literal"><i class="replaceable">key</i>=<i class="replaceable">value</i></tt> 的 key-value 对 list, 并且想将它们合成为单个字符串。为了将任意包含字符串的 list 连接成单个字符串, 可以使用字符串对象的 <tt class="function">join</tt> 方法。</p></div></blockquote>
</li>
<li>
<a href="../native_data_types/summary.html">3.8. 小结</a><blockquote><div class="abstract"><p>现在 <tt class="filename">odbchelper.py</tt> 程序和它的输出结果都应该非常清楚了。</p></div></blockquote>
</li>
</ul>
<p><a href="../power_of_introspection/index.html">第 4 章 自省的威力</a></p>
<ul>
<li>
<a href="../power_of_introspection/index.html#apihelper.divein">4.1. 概览</a><blockquote><div class="abstract"><p>下面是一个完整可运行的 <span class="application">Python</span> 程序。大概看一下这段程序，你应该可以理解不少了。用数字标出的行阐述了 <a href="../getting_to_know_python/index.html" title="第 2 章 第一个 Python 程序">第 2 章 <i>第一个 Python 程序</i></a> 中涉及的一些概念。如果剩下来的代码看起来有点奇怪，不用担心，通过阅读本章你将会理解所有这些。</p></div></blockquote>
</li>
<li>
<a href="../power_of_introspection/optional_arguments.html">4.2. 使用可选参数和命名参数</a><blockquote><div class="abstract"><p><span class="application">Python</span> 允许函数参数有缺省值；如果调用函数时不使用参数，参数将获得它的缺省值。此外，通过使用命名参数还可以以任意顺序指定参数。<span class="application">SQL Server</span> Transact/<span class="acronym">SQL</span> 中的存储过程也可以做到这些；如果你是脚本高手，你可以略过这部分。</p></div></blockquote>
</li>
<li>
<a href="../power_of_introspection/built_in_functions.html">4.3. 使用 type、str、dir 和其它内置函数</a><blockquote><div class="abstract"><p><span class="application">Python</span> 有小部分相当有用的内置函数。除这些函数之外，其它所有的函数都被分到了各个模块中。其实这是一个非常明智的设计决策，避免了核心语言变得像其它脚本语言一样臃肿（咳 咳，<span class="application">Visual Basic</span>）。</p></div></blockquote>
</li>
<li>
<a href="../power_of_introspection/getattr.html">4.4. 通过 getattr 获取对象引用</a><blockquote><div class="abstract"><p>你已经知道 <a href="../getting_to_know_python/everything_is_an_object.html" title="2.4. 万物皆对象"><span class="application">Python</span> 函数是对象</a>。  你不知道的是，使用 <tt class="function">getattr</tt> 函数，可以得到一个直到运行时才知道名称的函数的引用。</p></div></blockquote>
</li>
<li>
<a href="../power_of_introspection/filtering_lists.html">4.5. 过滤列表</a><blockquote><div class="abstract"><p>如你所知，<span class="application">Python</span> 具有通过列表解析（<a href="../native_data_types/mapping_lists.html" title="3.6. 映射 list">第 3.6 节 “映射 list”</a>）将列表映射到其它列表的强大能力。这种能力同过滤机制结合使用，使列表中的有些元素被映射的同时跳过另外一些元素。</p></div></blockquote>
</li>
<li>
<a href="../power_of_introspection/and_or.html">4.6. and 和 or 的特殊性质</a><blockquote><div class="abstract"><p>在<span class="application">Python</span> 中，<tt class="literal">and</tt> 和 <tt class="literal">or</tt> 执行布尔逻辑演算，如你所期待的一样，但是它们并不返回布尔值；而是，返回它们实际进行比较的值之一。</p></div></blockquote>
</li>
<li>
<a href="../power_of_introspection/lambda_functions.html">4.7. 使用 lambda 函数</a><blockquote><div class="abstract"><p><span class="application">Python</span> 支持一种有趣的语法，它允许你快速定义单行的最小函数。这些叫做 <tt class="literal">lambda</tt> 的函数，是从 <span class="application">Lisp</span> 借用来的，可以用在任何需要函数的地方。</p></div></blockquote>
</li>
<li>
<a href="../power_of_introspection/all_together.html">4.8. 全部放在一起</a><blockquote><div class="abstract"><p>最后一行代码是唯一还没有解释过的，它完成全部的工作。但是现在工作已经简单了，因为所需要的每件事都已经按照需求建立好了。所有的多米诺骨牌已经就位，到了将它们推倒的时候了。</p></div></blockquote>
</li>
<li>
<a href="../power_of_introspection/summary.html">4.9. 小结</a><blockquote><div class="abstract"><p><tt class="filename">apihelper.py</tt> 程序和它的输出现在应该非常清晰了。</p></div></blockquote>
</li>
</ul>
<p><a href="../object_oriented_framework/index.html">第 5 章 对象和面向对象</a></p>
<ul>
<li>
<a href="../object_oriented_framework/index.html#fileinfo.divein">5.1. 概览</a><blockquote><div class="abstract"><p>下面是一个完整的，可运行的 <span class="application">Python</span> 程序。请阅读模块、类和函数的 <a href="../getting_to_know_python/documenting_functions.html" title="2.3. 文档化函数"><tt class="literal">doc string</tt>s</a>，可以大概了解这个程序所做的事情和工作情况。象平时一样，不用担心你不理解的东西，这就是本章其它部分将告诉你的内容。</p></div></blockquote>
</li>
<li>
<a href="../object_oriented_framework/importing_modules.html">5.2. 使用 from module import 导入模块</a><blockquote><div class="abstract"><p><span class="application">Python</span> 有两种导入模块的方法。两种都有用，你应该知道什么时候使用哪一种方法。一种方法， <tt class="literal">import <i class="replaceable">module</i></tt>，你已经在<a href="../getting_to_know_python/everything_is_an_object.html" title="2.4. 万物皆对象">第 2.4 节 “万物皆对象”</a>看过了。另一种方法完成同样的事情，但是它与第一种有着细微但重要的区别。</p></div></blockquote>
</li>
<li>
<a href="../object_oriented_framework/defining_classes.html">5.3. 类的定义</a><blockquote><div class="abstract"><p><span class="application">Python</span> 是完全面向对象的：你可以定义自已的类，从自已的或内置的类继承，然后从你定义的类创建实例。</p></div></blockquote>
</li>
<li>
<a href="../object_oriented_framework/instantiating_classes.html">5.4. 类的实例化</a><blockquote><div class="abstract"><p>在 <span class="application">Python</span> 中对类进行实例化很直接。为了对类进行实例化，只要调用类，好象它是一个函数，传入定义在 <tt class="function">__init__</tt> 方法中的参数。返回值将是新创建的对象。</p></div></blockquote>
</li>
<li>
<a href="../object_oriented_framework/userdict.html">5.5. 探索 UserDict: 一个封装类</a><blockquote><div class="abstract"><p>如你所见， <tt class="classname">FileInfo</tt> 是一个象字典一样动作的类。为了进一步揭示这一点，让我们看一看在 <tt class="filename">UserDict</tt> 模块中的 <tt class="classname">UserDict</tt> 类，它是我们的 <tt class="classname">FileInfo</tt> 类的父类。它没有什么特别的，也是用 <span class="application">Python</span> 写的，并且保存在一个 <tt class="literal">.py</tt> 文件里，就象我们其他的代码。特别之处在于，它保存在你的 <span class="application">Python</span> 安装目录的  <tt class="filename">lib</tt>  目录下。</p></div></blockquote>
</li>
<li>
<a href="../object_oriented_framework/special_class_methods.html">5.6. 专用类方法</a><blockquote><div class="abstract"><p>除了普通的类方法，还有一些对于 <span class="application">Python</span> 类可以定义的专用方法。专用方法是在特殊情况下或当使用特别语法时由 <span class="application">Python</span> 替你调用的，而不是在代码中直接调用（象普通的方法那样）。</p></div></blockquote>
</li>
<li>
<a href="../object_oriented_framework/special_class_methods2.html">5.7. 高级专用类方法</a><blockquote><div class="abstract"><p>除了 <tt class="function">__getitem__</tt> 和 <tt class="function">__setitem__</tt> 之外 <span class="application">Python</span>  还有更多的专用函数。某些可以让你模拟出你甚至可能不知道的功能。</p></div></blockquote>
</li>
<li>
<a href="../object_oriented_framework/class_attributes.html">5.8. 类属性介绍</a><blockquote><div class="abstract"><p>你已经知道了 <a href="userdict.html#fileinfo.userdict.init.example" title="例 5.9. 定义 UserDict 类">数据属性</a>，它们是被一个特定的类实例所拥有的变量。<span class="application">Python</span> 也支持类属性，它们是由类本身所拥有的。</p></div></blockquote>
</li>
<li>
<a href="../object_oriented_framework/private_functions.html">5.9. 私有函数</a><blockquote><div class="abstract"><p>与大多数的语言不同，一个 <span class="application">Python</span> 函数，方法，或属性是私有还是公有，完全取决于它的名字。</p></div></blockquote>
</li>
<li>
<a href="../object_oriented_framework/summary.html">5.10. 小结</a><blockquote><div class="abstract"><p>实打实的对象把戏到此为止。 你将在 <a href="../soap_web_services/index.html">第 12 章</a> 中看到一个真实世界应用程序的专有类方法, 它使用 <tt class="function">getattr</tt> 创建一个到远程 Web 服务的代理。</p></div></blockquote>
</li>
</ul>
<p><a href="../file_handling/index.html">第 6 章 异常和文件处理</a></p>
<ul>
<li>
<a href="../file_handling/index.html#fileinfo.exception">6.1. 异常处理</a><blockquote><div class="abstract"><p>与许多面向对象语言一样，<span class="application">Python</span> 具有异常处理，通过使用 <tt class="literal">try...except</tt>  块来实现。</p></div></blockquote>
</li>
<li>
<a href="../file_handling/file_objects.html">6.2. 与文件对象共事</a><blockquote><div class="abstract"><p><span class="application">Python</span> 有一个内置函数，<tt class="function">open</tt>，用来打开在磁盘上的文件。<tt class="function">open</tt> 返回一个文件对象，它拥有一些方法和属性，可以得到打开文件的信息，和对打开文件进行操作。</p></div></blockquote>
</li>
<li>
<a href="../file_handling/for_loops.html">6.3. for 循环</a><blockquote><div class="abstract"><p>与其它大多数语言一样，<span class="application">Python</span> 也拥有 <tt class="literal">for</tt> 循环。你到现在还未曾看到它们的唯一原因就是，<span class="application">Python</span> 在其它太多的方面表现出色，通常你不需要它们。</p></div></blockquote>
</li>
<li>
<a href="../file_handling/more_on_modules.html">6.4. 使用 sys.modules</a><blockquote><div class="abstract"><p>与其它任何 <span class="application">Python</span> 的东西一样, 模块也是对象。 一旦导入，总可以用全局 dictionary <tt class="literal"><tt class="filename">sys</tt>.modules</tt> 来得到一个模块的引用。</p></div></blockquote>
</li>
<li>
<a href="../file_handling/os_module.html">6.5. 与 Directory 共事</a><blockquote><div class="abstract"><p><tt class="filename">os.path</tt> 模块有几个操作文件和目录的函数。 这里, 我们看看如何操作路径名和列出一个目录的内容。</p></div></blockquote>
</li>
<li>
<a href="../file_handling/all_together.html">6.6. 全部放在一起</a><blockquote><div class="abstract"><p>再一次，所有的多米诺骨牌都放好了。我们已经看过每行代码是如何工作的了。现在往回走一步，看一下放在一起是怎么样的。</p></div></blockquote>
</li>
<li>
<a href="../file_handling/summary.html">6.7. 小结</a><blockquote><div class="abstract"><p>在 <a href="../object_oriented_framework/index.html">第 5 章</a> 介绍的 <tt class="filename">fileinfo.py</tt> 程序现在应该完全理解了。</p></div></blockquote>
</li>
</ul>
<p><a href="../regular_expressions/index.html">第 7 章 正则表达式</a></p>
<ul>
<li>
<a href="../regular_expressions/index.html#re.intro">7.1. 概览</a><blockquote><div class="abstract"><p>如果你要解决的问题利用字符串函数能够完成，你应该使用他们。他们快速、简单且容易阅读，而对于快速、简单、可读性强的代码等方面有很多内容。但是，如果你发现你用了许多不同的字符串函数和 if语句来处理一个特殊情况，或者你组合使用了 <tt class="function">split</tt> 、<tt class="function">join</tt> 等函数而导致用一种奇怪的甚至读不下去的方式理解列表，此时，你也许需要转到正则表达式了。</p></div></blockquote>
</li>
<li>
<a href="../regular_expressions/street_addresses.html">7.2. 个案研究：街道地址</a><blockquote><div class="abstract"><p>这一系列的例子是由我几年前日常工作中的现实问题启发而来的，当时我需要从一个老化系统中导出街道地址，在将他们导入新的系统之前，进行清理和标准化。（看，我不是只将这些东西堆到一起，他有实际的用处）。这个例子展示我如何处理这个问题。</p></div></blockquote>
</li>
<li>
<a href="../regular_expressions/roman_numerals.html">7.3. 个案研究：罗马字母</a><blockquote><div class="abstract"><p>你可能经常看到罗马数字，即使你没有意识到他们。你可能曾经在老电影或者电视中看到他们（“<span class="quote">版权所有 <tt class="literal">MCMXLVI</tt></span>” 而不是 “<span class="quote">版权所有<tt class="literal">1946</tt></span>”），或者在某图书馆或某大学的贡献墙上看到他们(“<span class="quote">成立于 <tt class="literal">MDCCCLXXXVIII</tt></span>”而不是“<span class="quote">成立于<tt class="literal">1888</tt></span>”)。你也可能在某些文献的大纲或者目录上看到他们。这是一个表示数字的系统，他能够真正回溯到远古的罗马帝国（因此而得名）。</p></div></blockquote>
</li>
<li>
<a href="../regular_expressions/n_m_syntax.html">7.4. 使用{n,m} 语法</a><blockquote><div class="abstract"><p>在 <a href="roman_numerals.html" title="7.3. 个案研究：罗马字母">前面的章节</a>,你处理了相同字符可以重复三次的情况，在正则表达式中有另外一个方式来表达这种情况，并且使代码的可读性更好。首先来看我们在前面的例子中使用的方法。</p></div></blockquote>
</li>
<li>
<a href="../regular_expressions/verbose.html">7.5. 松散正则表达式</a><blockquote><div class="abstract"><p>迄今为止，你只是处理过被我称之为“<span class="quote">紧凑</span>”类型的正则表达式。正如你曾看到的，它们难以阅读，即使你清楚正则表达式的含义，你也不能保证六个月以后你还能理解它。你真正所需的就是利用内联文档（inline documentation）。</p></div></blockquote>
</li>
<li>
<a href="../regular_expressions/phone_numbers.html">7.6. 个案研究: 解析电话号码</a><blockquote><div class="abstract"><p>迄今为止，你主要是匹配整个模式，不论是匹配上，还是没有匹配上。但是正则表达式还有比这更为强大的功能。当一个模式<span class="emphasis"><em>确实</em></span>匹配上时，你可以获取模式中特定的片断，你可以发现具体匹配的位置。</p></div></blockquote>
</li>
<li>
<a href="../regular_expressions/summary.html">7.7. 小结</a><blockquote><div class="abstract"><p>这只是正则表达式能够完成工作的很少一部分。换句话说，即使你现在备受打击，相信我，你也不是什么也没见过了。</p></div></blockquote>
</li>
</ul>
<p><a href="../html_processing/index.html">第 8 章 HTML 处理</a></p>
<ul>
<li>
<a href="../html_processing/index.html#dialect.divein">8.1. 概览</a><blockquote><div class="abstract"><p>
我经常在 <a href="http://groups.google.com/groups?group=comp.lang.python">comp.lang.python</a> 上看到关于如下的问题:  “<span class="quote"> 怎么才能从我的 <span class="acronym">HTML</span> 文档中列出所有的 [头|图像|链接] 呢？</span>” “<span class="quote">怎么才能 [分析|解释|munge] 我的 <span class="acronym">HTML</span> 文档的文本，但是不要标记呢？</span>”  “<span class="quote">怎么才能一次给我所有的 <span class="acronym">HTML</span> 标记 [增加|删除|加引号] 属性呢？</span>” 本章将回答所有这些问题。</p></div></blockquote>
</li>
<li>
<a href="../html_processing/introducing_sgmllib.html">8.2. sgmllib.py 介绍</a><blockquote><div class="abstract"><p><span class="acronym">HTML</span> 处理分成三步: 将 <span class="acronym">HTML</span> 分解成它的组成片段，对片段进行加工，接着将片段再重新合成 HTML。第一步是通过 <tt class="filename">sgmllib.py</tt> 来完成的，它是标准 <span class="application">Python</span> 库的一部分。</p></div></blockquote>
</li>
<li>
<a href="../html_processing/extracting_data.html">8.3. 从 HTML 文档中提取数据</a><blockquote><div class="abstract"><p>为了从 <span class="acronym">HTML</span> 文档中提取数据，将 <tt class="classname">SGMLParser</tt> 类进行子类化，然后对想要捕捉的标记或实体定义方法。</p></div></blockquote>
</li>
<li>
<a href="../html_processing/basehtmlprocessor.html">8.4. BaseHTMLProcessor.py 介绍</a><blockquote><div class="abstract"><p><tt class="classname">SGMLParser</tt> 自身不会产生任何结果。它只是分析，分析，再分析，对于它找到的有趣的东西会调用相应的一个方法，但是这些方法什么都不做。<tt class="classname">SGMLParser</tt> 是一个 <span class="acronym">HTML</span> <span class="emphasis"><em>消费者 (consumer)</em></span>: 它接收 <span class="acronym">HTML</span>，将其分解成小的、结构化的小块。正如您所看到的，在 <a href="extracting_data.html" title="8.3. 从 HTML 文档中提取数据">前一节</a> 中，您可以通过将 <tt class="classname">SGMLParser</tt> 子类化来定义一个类，它可以捕捉特别标记和生成有用东西，如一个网页中所有链接的一个列表。现在我们将沿着这条路更深一步。我们要定义一个可以捕捉 <tt class="classname">SGMLParser</tt> 所丢出来的所有东西的一个类，接着重建整个 <span class="acronym">HTML</span> 文档。用技术术语来说，这个类将是一个 <span class="acronym">HTML</span> <span class="emphasis"><em>生产者 (producer)</em></span>。</p></div></blockquote>
</li>
<li>
<a href="../html_processing/locals_and_globals.html">8.5. locals 和 globals</a><blockquote><div class="abstract"><p>我们先偏离一下 <span class="acronym">HTML</span> 处理的主题, 讨论一下 <span class="application">Python</span> 如何处理变量。  <span class="application">Python</span> 有两个内置的函数, <tt class="function">locals</tt> 和 <tt class="function">globals</tt>, 它们提供了基于 dictionary 的访问局部和全局变量的方式。</p></div></blockquote>
</li>
<li>
<a href="../html_processing/dictionary_based_string_formatting.html">8.6. 基于 dictionary 的字符串格式化</a><blockquote><div class="abstract"><p>有另外一种字符串格式化的形式，它使用 dictionary 而不是值的 tuple。</p></div></blockquote>
</li>
<li>
<a href="../html_processing/quoting_attribute_values.html">8.7. 给属性值加引号</a><blockquote><div class="abstract"><p>在 <a href="http://groups.google.com/groups?group=comp.lang.python">comp.lang.python</a> 上的一个常见问题是 “<span class="quote">我有一些 <span class="acronym">HTML</span> 文档，属性值没有用引号括起来，并且我想将它们全部括起来，我怎么才能实现它呢？</span>”
<sup>[<a name="id2681898" href="#ftn.id2681898">4</a>]</sup>  (一般这种事情的出现是由于一个项目经理加入到一个大的项目中来，而他又抱着 <span class="acronym">HTML</span> 是一种标记语言的教条，要求所有的页面必须能够通过 <span class="acronym">HTML</span> 校验器的验证。而属性值没有被引号括起来是一种常见的对 <span class="acronym">HTML</span> 规范的违反。) 不管什么原因，未括起来的属性值通过将 <span class="acronym">HTML</span> 送进 <tt class="classname">BaseHTMLProcessor</tt> 可以容易地修复。
</p></div></blockquote>
</li>
<li>
<a href="../html_processing/dialect.html">8.8. dialect.py 介绍</a><blockquote><div class="abstract"><p><tt class="classname">Dialectizer</tt> 是 <tt class="classname">BaseHTMLProcessor</tt> 的简单 (和拙劣) 的派生类。它通过一系列的替换对文本块进行了处理，但是它确保在 <tt class="literal"><tt class="sgmltag-element">&lt;pre&gt;</tt>...<tt class="sgmltag-element">&lt;/pre&gt;</tt></tt> 块之间的任何东西不被修改地通过。</p></div></blockquote>
</li>
<li>
<a href="../html_processing/all_together.html">8.9. 全部放在一起</a><blockquote><div class="abstract"><p>到了该将迄今为止我们已经学过并用得不错的东西放在一起的时候了。我希望您专心些。</p></div></blockquote>
</li>
<li>
<a href="../html_processing/summary.html">8.10. 小结</a><blockquote><div class="abstract"><p><span class="application">Python</span> 向您提供了一个强大工具，<tt class="filename">sgmllib.py</tt>，可以通过将 <span class="acronym">HTML</span> 结构转变为一种对象模型来进行处理。可以以许多不同的方式来使用这个工具。</p></div></blockquote>
</li>
</ul>
<p><a href="../xml_processing/index.html">第 9 章 XML 处理</a></p>
<ul>
<li>
<a href="../xml_processing/index.html#kgp.divein">9.1. 概览</a><blockquote><div class="abstract"><p>处理 <span class="acronym">XML</span> 有两种基本的方式。一种叫做 <span class="acronym">SAX</span>（“<span class="quote">Simple <span class="acronym">API</span> for <span class="acronym">XML</span></span>”），它的工作方式是，一次读出一点 <span class="acronym">XML</span> 内容，然后对发现的每一个元素调用一个方法。（如果你读了 <a href="../html_processing/index.html" title="第 8 章 HTML 处理">第 8 章 <i>HTML 处理</i></a>，这应该听起来很熟悉，因为这是 <tt class="filename">sgmllib</tt> 工作的方式。）另一种方式叫做 <span class="acronym">DOM</span> （“<span class="quote">Document Object Model</span>”），它的工作方式是，一次性读入整个 <span class="acronym">XML</span> 文档，然后使用 <span class="application">Python</span> 类创建一个内部表示形式（以树结构进行连接）。<span class="application">Python</span> 拥有这两种解析方式的标准模块，但是本章只涉及 <span class="acronym">DOM</span>。</p></div></blockquote>
</li>
<li>
<a href="../xml_processing/packages.html">9.2. 包</a><blockquote><div class="abstract"><p>实际上解析一个 <span class="acronym">XML</span> 文档是很简单的：只要一行代码。但是，在你接触那行代码前，需要暂时岔开一下，讨论一下包。</p></div></blockquote>
</li>
<li>
<a href="../xml_processing/parsing_xml.html">9.3. XML 解析</a><blockquote><div class="abstract"><p>正如我说的，实际解析一个 <span class="acronym">XML</span> 文档是非常简单的：只要一行代码。从这里出发到哪儿去就是你自己的事了。</p></div></blockquote>
</li>
<li>
<a href="../xml_processing/unicode.html">9.4. Unicode</a><blockquote><div class="abstract"><p>Unicode 是一个系统，用来表示世界上所有不同语言的字符。当 <span class="application">Python</span> 解析一个 <span class="acronym">XML</span> 文档时，所有的数据都是以unicode的形式保存在内存中的。</p></div></blockquote>
</li>
<li>
<a href="../xml_processing/searching.html">9.5. 搜索元素</a><blockquote><div class="abstract"><p>通过一步步访问每一个节点的方式遍历 <span class="acronym">XML</span> 文档可能很乏味。如果你正在寻找些特别的东西，又恰恰它们深深埋入了你的 <span class="acronym">XML</span> 文档，有个捷径让你可以快速找到它：<tt class="function">getElementsByTagName</tt> 。</p></div></blockquote>
</li>
<li>
<a href="../xml_processing/attributes.html">9.6. 访问元素属性</a><blockquote><div class="abstract"><p><span class="acronym">XML</span> 元素可以有一个或者多个属性，一旦你已经解析了一个 <span class="acronym">XML</span> 文档，访问它们就太简单了。</p></div></blockquote>
</li>
<li>
<a href="../xml_processing/summary.html">9.7. Segue</a><blockquote><div class="abstract"><p>OK，that's it for the hard-core XML stuff. 下一章将继续使用相同的示例程序，但是焦点在于能使程序更加灵活的其它方面：使用输入流处理，使用 <tt class="function">getattr</tt> 进行方法分发，并使用命令行标识允许用户重新配置程序而无需修改代码。</p></div></blockquote>
</li>
</ul>
<p><a href="../scripts_and_streams/index.html">第 10 章 Scripts 和 Streams</a></p>
<ul>
<li>
<a href="../scripts_and_streams/index.html#kgp.openanything">10.1. 抽象输入源</a><blockquote><div class="abstract"><p><span class="application">Python</span> 的最强大力量之一是它的动态绑定，并且动态绑定最强大的用法之一是<span class="emphasis"><em>类文件(file-like)对象</em></span>。</p></div></blockquote>
</li>
<li>
<a href="../scripts_and_streams/stdin_stdout_stderr.html">10.2. 标准输入、输出和错误</a><blockquote><div class="abstract"><p><span class="acronym">UNIX</span> 用户已经对标准输入，标准输出和标准错误的概念非常熟悉了。这一节是为其他不熟悉的人准备的。</p></div></blockquote>
</li>
<li>
<a href="../scripts_and_streams/caching.html">10.3. 缓冲节点查询</a><blockquote><div class="abstract"><p><tt class="filename">kgp.py</tt> 使用了多种技巧，对你进行 <span class="acronym">XML</span> 处理而言它们或许有用。第一个就是，使用输入文档的结构稳定特征来构建节点缓冲。</p></div></blockquote>
</li>
<li>
<a href="../scripts_and_streams/child_nodes.html">10.4. 查找节点的直接子节点</a><blockquote><div class="abstract"><p>解析 <span class="acronym">XML</span> 文档时，另一个有用的己技巧是查找某个特定元素的所有直接子元素。例如，在语法文件中，一个 <tt class="sgmltag-element">ref</tt> 元素可以有数个 <tt class="sgmltag-element">p</tt> 元素，其中每一个都可以包含很多东西，包括其他的 <tt class="sgmltag-element">p</tt> 元素。你只要查找作为 <tt class="sgmltag-element">ref</tt> 孩子的 <tt class="sgmltag-element">p</tt> 元素，不用查找其他 <tt class="sgmltag-element">p</tt> 元素的孩子 <tt class="sgmltag-element">p</tt> 元素。</p></div></blockquote>
</li>
<li>
<a href="../scripts_and_streams/handlers_by_node_type.html">10.5. 通过节点类型创建独立的处理句柄 Creating separate handlers by node type</a><blockquote><div class="abstract"><p>第三个有用的 <span class="acronym">XML</span> 处理技巧是将你的代码基于节点类型和元素名称分散到逻辑函数中。解析后的 <span class="acronym">XML</span> 文档是由各种类型的节点组成的，每一个都是通过 <span class="application">Python</span> 对象表示的。文档本身的根层次通过一个<tt class="classname">Document</tt>对象表示。<tt class="classname">Document</tt>还包含了一个或者多个<tt class="classname">Element</tt>对象（for actual <span class="acronym">XML</span> tags），其中的每一个可以包含其它的<tt class="classname">Element</tt>对象，<tt class="classname">Text</tt>对象（for bits of text），或者<tt class="classname">Comment</tt>对象（for embedded comments）。 <span class="application">Python</span> 使编写分离每个节点类型逻辑的分发器非常容易。</p></div></blockquote>
</li>
<li>
<a href="../scripts_and_streams/command_line_arguments.html">10.6. 处理命令行参数</a><blockquote><div class="abstract"><p><span class="application">Python</span> 完备支持创建在命令行运行的程序，并且连同命令行参数和短长样式来指定各种选项。这些并非是 <span class="acronym">XML</span> 特定的，但是这样的脚本可以充分使用命令行处理，看来是时候提一下它了。</p></div></blockquote>
</li>
<li>
<a href="../scripts_and_streams/all_together.html">10.7. 全部放在一起</a><blockquote><div class="abstract"><p>你已经了解很多基础的东西。让我们回来看看所有片段是如何整合到一起的。</p></div></blockquote>
</li>
<li>
<a href="../scripts_and_streams/summary.html">10.8. 小结</a><blockquote><div class="abstract"><p><span class="application">Python</span> 带有解析和操作 <span class="acronym">XML</span> 文档非常强大的库。这个 <tt class="filename">minidom</tt> 接收一个 <span class="acronym">XML</span> 文件并将其解析为 <span class="application">Python</span> 对象，提供了对任意元素的随即访问。进一步，本章展示了如何利用 <span class="application">Python</span> 创建一个“真实”独立的命令行脚本，连同命令行标志，命令行参数，错误处理，甚至从前一个程序的管道接收输入的能力。</p></div></blockquote>
</li>
</ul>
<p><a href="../http_web_services/index.html">第 11 章 HTTP Web 服务</a></p>
<ul>
<li>
<a href="../http_web_services/index.html#oa.divein">11.1. 概览</a><blockquote><div class="abstract"><p> 在讲解 <a href="../html_processing/extracting_data.html#dialect.extract.urllib" title="例 8.5. urllib 介绍">如何下载 web 页</a> 和 <a href="../scripts_and_streams/index.html#kgp.openanything.urllib" title="例 10.2. 解析来自 URL 的 XML ">如何从 URL 解析 XML</a>时, 你已经学习了关于 <a href="../html_processing/index.html" title="第 8 章 HTML 处理">HTML 处理</a> 和 <a href="../xml_processing/index.html" title="第 9 章 XML 处理">XML 处理</a>， 接下来让我们来更全面地探讨有关 HTTP web 服务的主题。</p></div></blockquote>
</li>
<li>
<a href="../http_web_services/review.html">11.2. 避免通过 HTTP 重复地获取数据</a><blockquote><div class="abstract"><p>假如说你想用 HTTP 下载资源, 例如一个 Atom feed 汇聚。你不仅仅想下载一次; 而是想一次又一次地下载它, 如每小时一次,  从提供 news feed 的站点获得最新的消息。让我们首先用一种直接而原始的方法来实现它, 然后看看如何改进它。
</p></div></blockquote>
</li>
<li>
<a href="../http_web_services/http_features.html">11.3. HTTP 的特性</a><blockquote><div class="abstract"><p>这里有五个你必须关注的 HTTP 重要特性。</p></div></blockquote>
</li>
<li>
<a href="../http_web_services/debugging.html">11.4. 调试 HTTP web 服务</a><blockquote><div class="abstract"><p>首先, 让我们开启 <span class="application">Python</span> HTTP 库的调试特性并查看网络线路上的传输过程。  这对本章的全部内容都很有用, 因为你将添加越来越多的特性。</p></div></blockquote>
</li>
<li>
<a href="../http_web_services/user_agent.html">11.5. 设置 User-Agent</a><blockquote><div class="abstract"><p>改善你的 HTTP web 服务客户的第一步就是用 <tt class="literal">User-Agent</tt> 适当地鉴别你自己。为了做到这一点, 你需要远离基本的 <tt class="filename">urllib</tt> 而深入到 <tt class="filename">urllib2</tt>。</p></div></blockquote>
</li>
<li>
<a href="../http_web_services/etags.html">11.6. 处理 Last-Modified 和 ETag</a><blockquote><div class="abstract"><p>既然你知道如何在你的 web 服务请求中添加自定义的 HTTP 头信息, 接下来看看添加 <tt class="literal">Last-Modified</tt> 和 <tt class="literal">ETag</tt> 头信息的支持。</p></div></blockquote>
</li>
<li>
<a href="../http_web_services/redirects.html">11.7. 处理重定向</a><blockquote><div class="abstract"><p>你可以使用两种不同的自定义 URL 头信息来处理永久重定向和临时重定向。</p></div></blockquote>
</li>
<li>
<a href="../http_web_services/gzip_compression.html">11.8. 处理被压缩的数据</a><blockquote><div class="abstract"><p>你要支持的最后一个重要的 HTTP 特性是压缩。  许多 web 服务具有发送压缩数据的能力, 这可以将网络线路上传输的大量数据消减 60% 以上。  尤其适用于 XML web 服务, 因为 XML 数据 的压缩率可以很高。</p></div></blockquote>
</li>
<li>
<a href="../http_web_services/alltogether.html">11.9. 全部放在一起</a><blockquote><div class="abstract"><p>你已经看到了构造一个职能的 HTTP web 客户的所有片断。 现在让我们看看如何将它们整合到一起。</p></div></blockquote>
</li>
<li>
<a href="../http_web_services/summary.html">11.10. 小结</a><blockquote><div class="abstract"><p><tt class="filename">openanything.py</tt> 及其函数现在可以完美地工作了。</p></div></blockquote>
</li>
</ul>
<p><a href="../soap_web_services/index.html">第 12 章 SOAP Web 服务</a></p>
<ul>
<li>
<a href="../soap_web_services/index.html#soap.divein">12.1. 概览</a><blockquote><div class="abstract"><p>你用 Google, 对吧?  它是一个很流行的搜索引擎。  你是否曾经希望能以程序化的方式访问 Google 的搜索结果呢?  现在你能做到了。  下面是一个用 <span class="application">Python</span> 搜索 Google 的程序。</p></div></blockquote>
</li>
<li>
<a href="../soap_web_services/install.html">12.2. 安装 SOAP 库</a><blockquote><div class="abstract"><p>与本书中的其他代码不同, 本章依赖的库不是 <span class="application">Python</span> 预安装的。</p></div></blockquote>
</li>
<li>
<a href="../soap_web_services/first_steps.html">12.3. 步入 SOAP</a><blockquote><div class="abstract"><p>调用远程函数是 <span class="acronym">SOAP</span> 的核心功能。有很多提供公开 <span class="acronym">SOAP</span> 访问的服务器提供用于展示的简单功能。</p></div></blockquote>
</li>
<li>
<a href="../soap_web_services/debugging.html">12.4.  SOAP 网络服务查错</a><blockquote><div class="abstract"><p> <span class="acronym">SOAP</span> 提供了一个很方便的方法用以查看背后的情形。</p></div></blockquote>
</li>
<li>
<a href="../soap_web_services/wsdl.html">12.5. WSDL 介绍</a><blockquote><div class="abstract"><p><tt class="classname">SOAPProxy</tt> 类本地方法调用并透明地转向到远程 <span class="acronym">SOAP</span> 方法。 正如你所看到的，这是很多的工作，<tt class="classname">SOAPProxy</tt> 快速和透明地完成他们。它没有做到的是提供任何方法自省的手段。</p></div></blockquote>
</li>
<li>
<a href="../soap_web_services/introspection.html">12.6. 以 WSDL 进行 SOAP 内省</a><blockquote><div class="abstract"><p>就像网络服务舞台上的所有事物， <span class="acronym">WSDL</span> 也经历了一个充满明争暗斗而且漫长多变的历史。 我不打算讲述这段令我伤心的历史。 还有一些其他的标准提供相同的支持，但 <span class="acronym">WSDL</span> 还是胜出，所以我们还是来学习一下如何使用它。</p></div></blockquote>
</li>
<li>
<a href="../soap_web_services/google.html">12.7. 搜索 Google</a><blockquote><div class="abstract"><p>让我们回到这章开始时你看到的那段代码，获得比当前气温更有价值和令人振奋的信息。</p></div></blockquote>
</li>
<li>
<a href="../soap_web_services/troubleshooting.html">12.8.  SOAP 网络服务故障排除</a><blockquote><div class="abstract"><p>是的，<span class="acronym">SOAP</span> 网络服务的世界中也不总是欢乐和阳光。 有时候也会有故障。</p></div></blockquote>
</li>
<li>
<a href="../soap_web_services/summary.html">12.9. 小结</a><blockquote><div class="abstract"><p><span class="acronym">SOAP</span> 网络服务是很复杂的，雄心勃勃的它试图涵盖网络服务的很多不同应用。这一章我们接触了它的一个简单应用。</p></div></blockquote>
</li>
</ul>
<p><a href="../unit_testing/index.html">第 13 章 单元测试</a></p>
<ul>
<li>
<a href="../unit_testing/index.html#roman.intro">13.1. 罗马数字程序介绍 II</a><blockquote><div class="abstract"><p>在前面的章节中，你迅速“<span class="quote">深入</span>”并试图以最快的速度理解了这个程序。 "	既然你已对 <span class="application">Python</span> 有了一定的了解，那么接下来将回顾这个程序并从其代码被开发<span class="emphasis"><em>之前</em></span>入手。</p></div></blockquote>
</li>
<li>
<a href="../unit_testing/diving_in.html">13.2. 深入</a><blockquote><div class="abstract"><p>现在你已经定义了你的转换程序所应有的功能，下面一步会有点儿出乎你的意料：你将要开发一个测试组件(test suite)来测试你未来的函数以确保它们工作正常。没错：你将为还未开发的程序开发测试代码。</p></div></blockquote>
</li>
<li>
<a href="../unit_testing/romantest.html">13.3. 介绍 romantest.py</a><blockquote><div class="abstract"><p>这是将被开发并保存为 <tt class="filename">roman.py</tt> 的罗马数字转换程序的完整测试组件(test suite)。很难立刻看出他们是如何协同工作的，似乎所有类或者方法之间都没有关系。这是有原因的，而且你很快就会明了。</p></div></blockquote>
</li>
<li>
<a href="../unit_testing/testing_for_success.html">13.4. 正面测试（Testing for success）</a><blockquote><div class="abstract"><p>单元测试的基础是构建独立的测试用例（test case）。 一个测试用例只回答一个关于被测试代码的问题。 </p></div></blockquote>
</li>
<li>
<a href="../unit_testing/testing_for_failure.html">13.5. 负面测试（Testing for failure）</a><blockquote><div class="abstract"><p>使用有效输入确保函数成功通过测试还不够，你还需要测试无效输入导致函数失败的情形。但并不是任何失败都可以，必须如你预期地失败。</p></div></blockquote>
</li>
<li>
<a href="../unit_testing/testing_for_sanity.html">13.6. 完备性检测（Testing for sanity）</a><blockquote><div class="abstract"><p>你经常会发现一组代码中包含互逆函数，它们通常是转换函数，一个把 A 转换为 B ，另一个把 B 转换为 A。 在这种情况下，创建“<span class="quote">完备性检测</span>”可以使你在由 A 转 B 再转 A 的过程中不会出现丢失精度和取整等错误。 </p></div></blockquote>
</li>
</ul>
<p><a href="../unit_testing/stage_1.html">第 14 章 以测试优先为原则的编程</a></p>
<ul>
<li>
<a href="../unit_testing/stage_1.html#roman.stage1">14.1. roman.py, 第 1 阶段</a><blockquote><div class="abstract"><p>到目前为止，单元测试已经完成，是时候开始编写被单元测试测试的代码的时候了。你将分阶段地完成这个工作，因此开始时所有的单元测试都是失败的，但在逐步完成 <tt class="filename">roman.py</tt> 的同时你会看到它们一个个地通过（测试） 。 </p></div></blockquote>
</li>
<li>
<a href="../unit_testing/stage_2.html">14.2. roman.py, 第 2 阶段</a><blockquote><div class="abstract"><p>现在你有了 <tt class="filename">roman</tt> 模块的大概框架， 到了开始写代码以通过测试的时候了。</p></div></blockquote>
</li>
<li>
<a href="../unit_testing/stage_3.html">14.3. roman.py, 第 3 阶段</a><blockquote><div class="abstract"><p>现在 <tt class="function">toRoman</tt> 对于有效的输入（<tt class="literal">1</tt> 到 <tt class="literal">3999</tt> 整数）已能正确工作，是正确处理那些无效输入（任何其他输入）的时候了。</p></div></blockquote>
</li>
<li>
<a href="../unit_testing/stage_4.html">14.4. roman.py, 第 4 阶段</a><blockquote><div class="abstract"><p>现在 <tt class="function">toRoman</tt> 完成了，是开始编写 <tt class="function">fromRoman</tt> 的时候了。感谢那个将每个罗马数字和对应整数关连的完美数据结构，这个工作不比 <tt class="function">toRoman</tt> 函数复杂。</p></div></blockquote>
</li>
<li>
<a href="../unit_testing/stage_5.html">14.5. roman.py, 第 5 阶段</a><blockquote><div class="abstract"><p>现在 <tt class="function">fromRoman</tt> 对于有效输入能够正常工作了，是揭开最后一个谜底的时候了：使它正常工作于无效输入的情况下。这意味着要找出一个方法检查一个字符串是不是有效的罗马数字。这比 <tt class="function">toRoman</tt> 中<a href="stage_3.html" title="14.3. roman.py, 第 3 阶段">验证有效的数字输入</a> 困难， 但是你可以使用一个强大的工具：正则表达式。</p></div></blockquote>
</li>
</ul>
<p><a href="../refactoring/index.html">第 15 章 重构</a></p>
<ul>
<li>
<a href="../refactoring/index.html#roman.bugs">15.1. 处理 bugs</a><blockquote><div class="abstract"><p>尽管你很努力地编写全面的单元测试，但是 bug 还是会出现。 我所说的 “<span class="quote">bug</span>” 是什么呢？ Bug 是你还没有编写的测试用例。</p></div></blockquote>
</li>
<li>
<a href="../refactoring/handling_changing_requirements.html">15.2. 应对需求变化</a><blockquote><div class="abstract"><p>尽管你竭尽努力地分析你的客户，并点灯熬油地提炼出精确的需求，但需求还是会是不断变化。 大部分客户在看到产品前不知道他们想要什么。即便知道，也不擅于精确表述出他们的有效需求。即便能表述出来，他们在下一个版本一定会要求更多的功能。 因此你需要做好更新测试用例的准备以应对需求的改变。</p></div></blockquote>
</li>
<li>
<a href="../refactoring/refactoring.html">15.3. 重构</a><blockquote><div class="abstract"><p>全面的单元测试带来的最大好处不是你的全部测试用例最终通过时的成就感；也不是被责怪破坏了别人的代码时能够<span class="emphasis"><em>证明</em></span>自己的自信。最大的好处是单元测试给了你自由去无情地重构。</p></div></blockquote>
</li>
<li>
<a href="../refactoring/postscript.html">15.4. 后记</a><blockquote><div class="abstract"><p>聪明的读者在学习 <a href="refactoring.html" title="15.3. 重构">前一节</a> 时想得会更深入一层。 现在写的这个程序中最令人头痛（性能负担）的是正则表达式，它是必需的，因为没有其它方法来处理罗马数字。但是，它们只有 5000 个，为什么不一次性地构建一个查询表来读取？ 不必用正则表达式凸现了这个主意的好处。 你建立了整数到罗马数字查询表的时候，罗马数字到整数的逆向查询表也构建了。</p></div></blockquote>
</li>
<li>
<a href="../refactoring/summary.html">15.5. 小结</a><blockquote><div class="abstract"><p>单元测试是一个强大的概念，使用得当的话既可以减少维护成本又可以增加长期项目的灵活性。 同样重要的是要意识到单元测试并不是“灵丹妙药”，也不是“银弹”。 编写好的测试用例很困难，保持其更新更需要磨练（特别是当顾客对修复严重的 Bug 大呼小叫之时）。 单元测试不是其它形式测试的替代品，比如说功能性测试、集成测试以及可用性测试。但它切实可行且功效明显，一旦相识，你会反问为什么以往没有应用它。</p></div></blockquote>
</li>
</ul>
<p><a href="../functional_programming/index.html">第 16 章 有效编程（Functional Programming）</a></p>
<ul>
<li>
<a href="../functional_programming/index.html#regression.divein">16.1. 概览</a><blockquote><div class="abstract"><p>在 <a href="../unit_testing/index.html" title="第 13 章 单元测试">第 13 章 <i>单元测试</i></a> 中，你学会了单元测试的哲学。在 <a href="../unit_testing/stage_1.html" title="第 14 章 以测试优先为原则的编程">第 14 章 <i>以测试优先为原则的编程</i></a>  中你步入了 <span class="application">Python</span> 基本的单元测试操作，在 <a href="../refactoring/index.html" title="第 15 章 重构">第 15 章 <i>重构</i></a> 部分，你看到单元测试如何另大规模重组变得容易。 本章将在这些程序范例的基础上，集中关注于超越单元测试本身的更高级的 <span class="application">Python</span> 特有技术。</p></div></blockquote>
</li>
<li>
<a href="../functional_programming/finding_the_path.html">16.2. 找到路径</a><blockquote><div class="abstract"><p>从命令行运行 <span class="application">Python</span> 代码时，知道所运行代码所在磁盘上的存储位置有时候是有必要的。</p></div></blockquote>
</li>
<li>
<a href="../functional_programming/filtering_lists.html">16.3. 过滤已访问列表</a><blockquote><div class="abstract"><p>你已经熟识了 <a href="../power_of_introspection/filtering_lists.html" title="4.5. 过滤列表"> 应用列表遍历来过滤列表</a>。 这里介绍的是达到相同效果的另一种令很多人感觉清晰的实现方法。</p></div></blockquote>
</li>
<li>
<a href="../functional_programming/mapping_lists.html">16.4. 关联已访问列表</a><blockquote><div class="abstract"><p>你对使用 <a href="../native_data_types/mapping_lists.html" title="3.6. 映射 list">列表遍历</a> 将列表关联起来的做法已经熟知。 另一种方法可以完成同样的工作：使用内建 <tt class="function">map</tt> 函数。 它的工作机理和 <a href="filtering_lists.html" title="16.3. 过滤已访问列表"><tt class="function">filter</tt></a> 函数类似。</p></div></blockquote>
</li>
<li>
<a href="../functional_programming/data_centric.html">16.5. 数据中心思想编程</a><blockquote><div class="abstract"><p>现在的你，可能正抓耳挠腮地狠想，为什么这样比使用 <tt class="literal">for</tt> 循环和直接调用函数好。这是一个非常好的问题。通常这是一个程序观问题。 使用 <tt class="function">map</tt> 和 <tt class="function">filter</tt> 强迫你围绕数据进行思考。</p></div></blockquote>
</li>
<li>
<a href="../functional_programming/dynamic_import.html">16.6. 动态导入模块</a><blockquote><div class="abstract"><p>好了，大道理谈够了。让我们谈谈动态倒入数据吧。</p></div></blockquote>
</li>
<li>
<a href="../functional_programming/all_together.html">16.7. 全部放在一起</a><blockquote><div class="abstract"><p>你已经学习了足够的知识，现在来分析本章范例代码的前七行：读取一个目录并从中导入选定的模块。</p></div></blockquote>
</li>
<li>
<a href="../functional_programming/summary.html">16.8. 小结</a><blockquote><div class="abstract"><p><tt class="filename">regression.py</tt> 程序及其输出到现在应该很清楚了。</p></div></blockquote>
</li>
</ul>
<p><a href="../dynamic_functions/index.html">第 17 章 动态函数</a></p>
<ul>
<li>
<a href="../dynamic_functions/index.html#plural.divein">17.1. 概览</a><blockquote><div class="abstract"><p>我想谈谈名词复数。 还有，返回其它函数的函数，高级的正则表达式和生成器（Generator）。生成器是 <span class="application">Python</span> 2.3 新引入的。 但首先还是让我们先来谈谈如何生成名词复数。</p></div></blockquote>
</li>
<li>
<a href="../dynamic_functions/stage1.html">17.2. plural.py, 第 1 阶段</a><blockquote><div class="abstract"><p>你所针对的单词，至少在英语中是字符串和字符。 另外你需要规则来找出不同的字符（字母）组合，并对他们进行不同的操作。这听起来像是正则表达式的工作。</p></div></blockquote>
</li>
<li>
<a href="../dynamic_functions/stage2.html">17.3. plural.py, 第 2 阶段</a><blockquote><div class="abstract"><p>现在你将增加一个抽象过程。 你从定义一个规则列表开始：如果这样，就做那个，否则判断下一规则。 让我们暂时将程序一部分复杂化以便使另一部分简单化。</p></div></blockquote>
</li>
<li>
<a href="../dynamic_functions/stage3.html">17.4. plural.py, 第 3 阶段</a><blockquote><div class="abstract"><p>将每个匹配和规则应用分别制作成函数没有必要。 你从来不会直接调用它们：你把它们定义于 <tt class="varname">rules</tt> 列表之中并从那里调用它们。 让我们隐去他们的函数名而抓住规则定义的主线。</p></div></blockquote>
</li>
<li>
<a href="../dynamic_functions/stage4.html">17.5. plural.py, 第 4 阶段</a><blockquote><div class="abstract"><p>让我们精炼出代码中的重复之处，以便更容易地定义新规则。</p></div></blockquote>
</li>
<li>
<a href="../dynamic_functions/stage5.html">17.6. plural.py, 第 5 阶段</a><blockquote><div class="abstract"><p>你已经精炼了所有重复代码，也尽可能地把复数规则提炼到定义一个字符串列表。 接下来的步骤是把这些字符串提出来放在另外的文件中，从而可以和使用它们的代码分开来维护。</p></div></blockquote>
</li>
<li>
<a href="../dynamic_functions/stage6.html">17.7. plural.py, 第 6 阶段</a><blockquote><div class="abstract"><p>现在你已准备好探讨生成器（Generator ）了。</p></div></blockquote>
</li>
<li>
<a href="../dynamic_functions/summary.html">17.8. 小结</a><blockquote><div class="abstract"><p>这一章中我们探讨了几个不同的高级技术。他们并不都适用于任何情况。</p></div></blockquote>
</li>
</ul>
<p><a href="../performance_tuning/index.html">第 18 章 性能优化</a></p>
<ul>
<li>
<a href="../performance_tuning/index.html#soundex.divein">18.1. 概览</a><blockquote><div class="abstract"><p>由于代码优化过程中存在太多的不明确因素，以至于你很难清楚该从何入手。</p></div></blockquote>
</li>
<li>
<a href="../performance_tuning/timeit.html">18.2. 使用 timeit 模块</a><blockquote><div class="abstract"><p>关于 <span class="application">Python</span> 代码优化你需要知道的最重要问题是，决不要自己编写计时函数。</p></div></blockquote>
</li>
<li>
<a href="../performance_tuning/regular_expressions.html">18.3. 优化正则表达式</a><blockquote><div class="abstract"><p> Soundex 函数的第一件事是检查输入是否是一个空字符串。 怎样做是最好的方法？</p></div></blockquote>
</li>
<li>
<a href="../performance_tuning/dictionary_lookups.html">18.4. 优化字典查找</a><blockquote><div class="abstract"><p> Soundex 算法的第二步是依照特定规则将字符转换为数字。 做到这点最好的方法是什么？</p></div></blockquote>
</li>
<li>
<a href="../performance_tuning/list_operations.html">18.5. 优化列表操作</a><blockquote><div class="abstract"><p>Soundex 算法的第三步是去除连续重复字符。 怎样做是最佳方法？</p></div></blockquote>
</li>
<li>
<a href="../performance_tuning/string_manipulation.html">18.6. 优化字符串操作</a><blockquote><div class="abstract"><p>Soundex 算法的最后一步是对短结果补零和截短长结果。最佳的做法是什么？</p></div></blockquote>
</li>
<li>
<a href="../performance_tuning/summary.html">18.7. 小结</a><blockquote><div class="abstract"><p>这一章展示了性能优化的几个重要方面，这里是就 <span class="application">Python</span> 而言，但它们却普遍使用。</p></div></blockquote>
</li>
</ul>
</div>
<table class="Footer" width="100%" border="0" cellpadding="0" cellspacing="0" summary="">
<tr>
<td width="35%" align="left">
<br><a class="NavigationArrow" href="furtherreading.html">&lt;&lt; 进一步阅读</a>
</td>
<td width="30%" align="center">
<br> <span class="divider">|</span>  <span class="divider">|</span> </td>
<td width="35%" align="right">
<br><a class="NavigationArrow" href="tips.html">技巧和窍门 &gt;&gt;</a>
</td>
</tr>
<tr><td colspan="3"><br></td></tr>
</table>
<div class="Footer"><p class="copyright">版权 © 2000, 2001, 2002, 2003, 2004 <a href="mailto:mark@diveintopython.org">Mark Pilgrim</a></p></div>
</body>
</html>
