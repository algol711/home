<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Kyoto Cabinet: kyotocabinet Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>kyotocabinet Namespace Reference</h1>
<p>All symbols of Kyoto Cabinet.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1CacheDB.html">CacheDB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">On-memory hash database with LRU deletion.  <a href="classkyotocabinet_1_1CacheDB.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1Comparator.html">Comparator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interfrace of comparator of record keys.  <a href="classkyotocabinet_1_1Comparator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1LexicalComparator.html">LexicalComparator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classkyotocabinet_1_1Comparator.html" title="Interfrace of comparator of record keys.">Comparator</a> in the lexical order.  <a href="classkyotocabinet_1_1LexicalComparator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1DecimalComparator.html">DecimalComparator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classkyotocabinet_1_1Comparator.html" title="Interfrace of comparator of record keys.">Comparator</a> in the decimal order.  <a href="classkyotocabinet_1_1DecimalComparator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1Compressor.html">Compressor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interfrace of data compression and decompression.  <a href="classkyotocabinet_1_1Compressor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1ZLIB.html">ZLIB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classkyotocabinet_1_1ZLIB.html" title="ZLIB compressor.">ZLIB</a> compressor.  <a href="classkyotocabinet_1_1ZLIB.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1LZO.html">LZO</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classkyotocabinet_1_1LZO.html" title="LZO compressor.">LZO</a> compressor.  <a href="classkyotocabinet_1_1LZO.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1LZMA.html">LZMA</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classkyotocabinet_1_1LZMA.html" title="LZMA compressor.">LZMA</a> compressor.  <a href="classkyotocabinet_1_1LZMA.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1ZLIBCompressor.html">ZLIBCompressor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classkyotocabinet_1_1Compressor.html" title="Interfrace of data compression and decompression.">Compressor</a> with <a class="el" href="classkyotocabinet_1_1ZLIB.html" title="ZLIB compressor.">ZLIB</a>.  <a href="classkyotocabinet_1_1ZLIBCompressor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1LZOCompressor.html">LZOCompressor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classkyotocabinet_1_1Compressor.html" title="Interfrace of data compression and decompression.">Compressor</a> with <a class="el" href="classkyotocabinet_1_1LZO.html" title="LZO compressor.">LZO</a>.  <a href="classkyotocabinet_1_1LZOCompressor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1LZMACompressor.html">LZMACompressor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classkyotocabinet_1_1Compressor.html" title="Interfrace of data compression and decompression.">Compressor</a> with <a class="el" href="classkyotocabinet_1_1LZMA.html" title="LZMA compressor.">LZMA</a>.  <a href="classkyotocabinet_1_1LZMACompressor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1ArcfourCompressor.html">ArcfourCompressor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classkyotocabinet_1_1Compressor.html" title="Interfrace of data compression and decompression.">Compressor</a> with the Arcfour cipher.  <a href="classkyotocabinet_1_1ArcfourCompressor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1DB.html">DB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface of database abstraction.  <a href="classkyotocabinet_1_1DB.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1BasicDB.html">BasicDB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic implementation of database.  <a href="classkyotocabinet_1_1BasicDB.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1MapReduce.html">MapReduce</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classkyotocabinet_1_1MapReduce.html" title="MapReduce framework.">MapReduce</a> framework.  <a href="classkyotocabinet_1_1MapReduce.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1DirDB.html">DirDB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Directory hash database.  <a href="classkyotocabinet_1_1DirDB.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1File.html">File</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Filesystem abstraction.  <a href="classkyotocabinet_1_1File.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1DirStream.html">DirStream</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Directory stream abstraction.  <a href="classkyotocabinet_1_1DirStream.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1HashDB.html">HashDB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classkyotocabinet_1_1File.html" title="Filesystem abstraction.">File</a> hash database.  <a href="classkyotocabinet_1_1HashDB.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1TinyHashMap.html">TinyHashMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory-saving hash map.  <a href="classkyotocabinet_1_1TinyHashMap.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1LinkedHashMap.html">LinkedHashMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Doubly-linked hash map.  <a href="classkyotocabinet_1_1LinkedHashMap.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1PlantDB.html">PlantDB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plant database.  <a href="classkyotocabinet_1_1PlantDB.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1PolyDB.html">PolyDB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Polymorphic database.  <a href="classkyotocabinet_1_1PolyDB.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1ProtoDB.html">ProtoDB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prototype implementation of database with STL.  <a href="classkyotocabinet_1_1ProtoDB.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1Regex.html">Regex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Regular expression.  <a href="classkyotocabinet_1_1Regex.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1StashDB.html">StashDB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Economical on-memory hash database.  <a href="classkyotocabinet_1_1StashDB.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1Thread.html">Thread</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Threading device.  <a href="classkyotocabinet_1_1Thread.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1Mutex.html">Mutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic mutual exclusion device.  <a href="classkyotocabinet_1_1Mutex.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1ScopedMutex.html">ScopedMutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scoped mutex device.  <a href="classkyotocabinet_1_1ScopedMutex.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1SlottedMutex.html">SlottedMutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Slotted mutex device.  <a href="classkyotocabinet_1_1SlottedMutex.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1SpinLock.html">SpinLock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lightweight mutual exclusion device.  <a href="classkyotocabinet_1_1SpinLock.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1ScopedSpinLock.html">ScopedSpinLock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scoped spin lock device.  <a href="classkyotocabinet_1_1ScopedSpinLock.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1SlottedSpinLock.html">SlottedSpinLock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Slotted spin lock devices.  <a href="classkyotocabinet_1_1SlottedSpinLock.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1RWLock.html">RWLock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reader-writer locking device.  <a href="classkyotocabinet_1_1RWLock.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1ScopedRWLock.html">ScopedRWLock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scoped reader-writer locking device.  <a href="classkyotocabinet_1_1ScopedRWLock.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1SlottedRWLock.html">SlottedRWLock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Slotted reader-writer lock devices.  <a href="classkyotocabinet_1_1SlottedRWLock.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1SpinRWLock.html">SpinRWLock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lightweight reader-writer locking device.  <a href="classkyotocabinet_1_1SpinRWLock.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1ScopedSpinRWLock.html">ScopedSpinRWLock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scoped reader-writer locking device.  <a href="classkyotocabinet_1_1ScopedSpinRWLock.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1SlottedSpinRWLock.html">SlottedSpinRWLock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Slotted lightweight reader-writer lock devices.  <a href="classkyotocabinet_1_1SlottedSpinRWLock.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1CondVar.html">CondVar</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Condition variable.  <a href="classkyotocabinet_1_1CondVar.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1TSDKey.html">TSDKey</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Key of thread specific data.  <a href="classkyotocabinet_1_1TSDKey.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1TSD.html">TSD</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Smart pointer to thread specific data.  <a href="classkyotocabinet_1_1TSD.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1AtomicInt64.html">AtomicInt64</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Integer with atomic operations.  <a href="classkyotocabinet_1_1AtomicInt64.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkyotocabinet_1_1TaskQueue.html">TaskQueue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classkyotocabinet_1_1TaskQueue_1_1Task.html" title="Interface of a task.">Task</a> queue device.  <a href="classkyotocabinet_1_1TaskQueue.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classkyotocabinet_1_1PlantDB.html">PlantDB</a>&lt; <a class="el" href="classkyotocabinet_1_1CacheDB.html">CacheDB</a>, <br class="typebreak"/>
BasicDB::TYPEGRASS &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#ab08bf5f25c36e8e6b06e7531b047acc7">GrassDB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An alias of the cache tree database.  <a href="#ab08bf5f25c36e8e6b06e7531b047acc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classkyotocabinet_1_1PlantDB.html">PlantDB</a>&lt; <a class="el" href="classkyotocabinet_1_1DirDB.html">DirDB</a>, <br class="typebreak"/>
BasicDB::TYPEFOREST &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#aadca6acd45bcad111229c9f92be7a66b">ForestDB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An alias of the directory tree database.  <a href="#aadca6acd45bcad111229c9f92be7a66b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classkyotocabinet_1_1PlantDB.html">PlantDB</a>&lt; <a class="el" href="classkyotocabinet_1_1HashDB.html">HashDB</a>, <br class="typebreak"/>
BasicDB::TYPETREE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a58209fa250ad75178ca0379f1034ad5e">TreeDB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An alias of the file tree database.  <a href="#a58209fa250ad75178ca0379f1034ad5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classkyotocabinet_1_1ProtoDB.html">ProtoDB</a>&lt; <a class="el" href="namespacekyotocabinet.html#aa9afff496b05bb033337d44c1cb55d1b">StringHashMap</a>, <br class="typebreak"/>
BasicDB::TYPEPHASH &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a68826fcd903705a08001af0180d713e6">ProtoHashDB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An alias of the prototype hash database.  <a href="#a68826fcd903705a08001af0180d713e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classkyotocabinet_1_1ProtoDB.html">ProtoDB</a>&lt; <a class="el" href="namespacekyotocabinet.html#a8c47c7e78c5bebb036bd6d887023a891">StringTreeMap</a>, <br class="typebreak"/>
BasicDB::TYPEPTREE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a7d8bb1fb74782bff49ec28d486c98801">ProtoTreeDB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An alias of the prototype tree database.  <a href="#a7d8bb1fb74782bff49ec28d486c98801"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::unordered_map<br class="typebreak"/>
&lt; std::string, std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#aa9afff496b05bb033337d44c1cb55d1b">StringHashMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An alias of hash map of strings.  <a href="#aa9afff496b05bb033337d44c1cb55d1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <br class="typebreak"/>
std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a8c47c7e78c5bebb036bd6d887023a891">StringTreeMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An alias of tree map of strings.  <a href="#a8c47c7e78c5bebb036bd6d887023a891"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#aa5717474fab1f19605adb576a985d158">atoi</a> (const char *str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a decimal string to an integer.  <a href="#aa5717474fab1f19605adb576a985d158"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a012be7793124f2f8c272e592c5514412">atoix</a> (const char *str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a decimal string with a metric prefix to an integer.  <a href="#a012be7793124f2f8c272e592c5514412"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a9d9165134c70c771e930046d01dd43a1">atoih</a> (const char *str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a hexadecimal string to an integer.  <a href="#a9d9165134c70c771e930046d01dd43a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#ab7eee3ce1842a348a434caebc2487c5a">atof</a> (const char *str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a decimal string to a real number.  <a href="#ab7eee3ce1842a348a434caebc2487c5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a04b7fe7ba51ef5ea76b95edab3c3862e">hton16</a> (uint16_t num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize a 16-bit number in the native order into the network byte order.  <a href="#a04b7fe7ba51ef5ea76b95edab3c3862e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a921daaea526494202f3322922412c537">hton32</a> (uint32_t num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize a 32-bit number in the native order into the network byte order.  <a href="#a921daaea526494202f3322922412c537"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a95c605fe3f2cc287a5dd58c7ff900858">hton64</a> (uint64_t num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize a 64-bit number in the native order into the network byte order.  <a href="#a95c605fe3f2cc287a5dd58c7ff900858"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a45d48051f7702c067fbe8e0bd3ee2df9">ntoh16</a> (uint16_t num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Denormalize a 16-bit number in the network byte order into the native order.  <a href="#a45d48051f7702c067fbe8e0bd3ee2df9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a4fb2dc6015957212746727c733ef1537">ntoh32</a> (uint32_t num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Denormalize a 32-bit number in the network byte order into the native order.  <a href="#a4fb2dc6015957212746727c733ef1537"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#ad7183e9051e01321afcb6d62ab52da05">ntoh64</a> (uint64_t num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Denormalize a 64-bit number in the network byte order into the native order.  <a href="#ad7183e9051e01321afcb6d62ab52da05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a1bfe6b5ec7606ecda2452b64781f5f31">writefixnum</a> (void *buf, uint64_t num, size_t width)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a number in fixed length format into a buffer.  <a href="#a1bfe6b5ec7606ecda2452b64781f5f31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#ad7f66a6264c9c32a1130eb46097061a8">readfixnum</a> (const void *buf, size_t width)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a number in fixed length format from a buffer.  <a href="#ad7f66a6264c9c32a1130eb46097061a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a03c4e24c499a108d621db0a11d90373a">writevarnum</a> (void *buf, uint64_t num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a number in variable length format into a buffer.  <a href="#a03c4e24c499a108d621db0a11d90373a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a16132e0ce72cae571f1141fd6ffc1be2">readvarnum</a> (const void *buf, size_t size, uint64_t *np)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a number in variable length format from a buffer.  <a href="#a16132e0ce72cae571f1141fd6ffc1be2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a13e22f466f762c802b40d350d6348de8">sizevarnum</a> (uint64_t num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the size of variable length format of a number.  <a href="#a13e22f466f762c802b40d350d6348de8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a0a5204c2146a15fc10235415c2116a7e">hashmurmur</a> (const void *buf, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the hash value by MurMur hashing.  <a href="#a0a5204c2146a15fc10235415c2116a7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a081b00a7f1052ce0ac40cf231c8308b6">hashfnv</a> (const void *buf, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the hash value by FNV hashing.  <a href="#a081b00a7f1052ce0ac40cf231c8308b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a910aece64bb0969898dff3f2ab25c545">hashpath</a> (const void *buf, size_t size, char *obuf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the hash value suitable for a file name.  <a href="#a910aece64bb0969898dff3f2ab25c545"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a15a184c29c0a15c9a2c5ec284952be94">nearbyprime</a> (uint64_t num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a prime number nearby a number.  <a href="#a15a184c29c0a15c9a2c5ec284952be94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#abd08290326188b7ef61352b7e9b50bb3">nan</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the quiet Not-a-Number value.  <a href="#abd08290326188b7ef61352b7e9b50bb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a9f586ee148f0a7a508bb4bfac161af96">inf</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the positive infinity value.  <a href="#a9f586ee148f0a7a508bb4bfac161af96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a663493c7e34035c4a2ce51915fdaf4c7">chknan</a> (double num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check a number is a Not-a-Number value.  <a href="#a663493c7e34035c4a2ce51915fdaf4c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#aad77342fb052bbffafc0291d2de7c182">chkinf</a> (double num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check a number is an infinity value.  <a href="#aad77342fb052bbffafc0291d2de7c182"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a3254622e310d259aa88abc2e615e3901">vstrprintf</a> (std::string *dest, const char *format, va_list ap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a formatted string at the end of a string.  <a href="#a3254622e310d259aa88abc2e615e3901"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a1f152bed78c4e6a1c0a21ddb8e1ab951">strprintf</a> (std::string *dest, const char *format,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a formatted string at the end of a string.  <a href="#a1f152bed78c4e6a1c0a21ddb8e1ab951"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a492b51509ee03e32b5e7b72fa3ac2b97">strprintf</a> (const char *format,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a formatted string.  <a href="#a492b51509ee03e32b5e7b72fa3ac2b97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a295fcdb0ba9274e2d986a66e1eb189b8">strsplit</a> (const std::string &amp;str, char delim, std::vector&lt; std::string &gt; *elems)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split a string with a delimiter.  <a href="#a295fcdb0ba9274e2d986a66e1eb189b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#ae70c36738b29ac18f88920ea07b621c9">strsplit</a> (const std::string &amp;str, const std::string &amp;delims, std::vector&lt; std::string &gt; *elems)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split a string with delimiters.  <a href="#ae70c36738b29ac18f88920ea07b621c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#ab8be5cf3c65a54efdee6823b8877298b">hexencode</a> (const void *buf, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encode a serial object by hexadecimal encoding.  <a href="#ab8be5cf3c65a54efdee6823b8877298b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#ac456e8436103c1ae54ff34e683228af3">hexdecode</a> (const char *str, size_t *sp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode a string encoded by hexadecimal encoding.  <a href="#ac456e8436103c1ae54ff34e683228af3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#adab2ffa1e9de00c542b87732e9502351">urlencode</a> (const void *buf, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encode a serial object by URL encoding.  <a href="#adab2ffa1e9de00c542b87732e9502351"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#adc574a3e7323cf4a3f5a27ed2e8d08a9">urldecode</a> (const char *str, size_t *sp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode a string encoded by URL encoding.  <a href="#adc574a3e7323cf4a3f5a27ed2e8d08a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#ae840cb8f87aedaf6cf0eb8d54f822bba">quoteencode</a> (const void *buf, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encode a serial object by Quoted-printable encoding.  <a href="#ae840cb8f87aedaf6cf0eb8d54f822bba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a26d8324a921bdd0d044e27163b9a65f9">quotedecode</a> (const char *str, size_t *sp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode a string encoded by Quoted-printable encoding.  <a href="#a26d8324a921bdd0d044e27163b9a65f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a42d22d135cee058108f0c48bbd023391">baseencode</a> (const void *buf, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encode a serial object by Base64 encoding.  <a href="#a42d22d135cee058108f0c48bbd023391"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a8cbe7c5bbb37e28c482cf4cef0ce151a">basedecode</a> (const char *str, size_t *sp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode a string encoded by Base64 encoding.  <a href="#a8cbe7c5bbb37e28c482cf4cef0ce151a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a88eeb6a4d66d8327c65ca26ae6aac9d7">arccipher</a> (const void *ptr, size_t size, const void *kbuf, size_t ksiz, void *obuf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cipher or decipher a serial object with the Arcfour stream cipher.  <a href="#a88eeb6a4d66d8327c65ca26ae6aac9d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a2b17149eb5e49f646877e0bf6b573c7a">memdup</a> (const char *ptr, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate a region on memory.  <a href="#a2b17149eb5e49f646877e0bf6b573c7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a447ff12b751702fb98a347fad4e5c682">strdup</a> (const char *str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate a string on memory.  <a href="#a447ff12b751702fb98a347fad4e5c682"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#ac3a56f2f62176765b41414e3fef23b83">strtoupper</a> (char *str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the letters of a string into upper case.  <a href="#ac3a56f2f62176765b41414e3fef23b83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a8c9f497da0a7ac76efcf4e41385413a2">strtolower</a> (char *str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the letters of a string into lower case.  <a href="#a8c9f497da0a7ac76efcf4e41385413a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#aa75ce8ab1f4e37dd7cd57be23bf0e194">strtrim</a> (char *str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cut space characters at head or tail of a string.  <a href="#aa75ce8ab1f4e37dd7cd57be23bf0e194"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#aad57c9f970d26f638f8d6953aa966f11">strsqzspc</a> (char *str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Squeeze space characters in a string and trim it.  <a href="#aad57c9f970d26f638f8d6953aa966f11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a74e08dd57d6b6450074bbaa8e9d9271c">strnrmspc</a> (char *str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize space characters in a string and trim it.  <a href="#a74e08dd57d6b6450074bbaa8e9d9271c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a1212cff81fe1a20944a240665c319668">stricmp</a> (const char *astr, const char *bstr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two strings with case insensitive evaluation.  <a href="#a1212cff81fe1a20944a240665c319668"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#ad79bd82ec5cc9ddbf34f9ab414cf95c7">strfwm</a> (const char *str, const char *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether a string begins with a key.  <a href="#ad79bd82ec5cc9ddbf34f9ab414cf95c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#ab148bce1cca2922a5f7075caa4ad2123">strifwm</a> (const char *str, const char *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether a string begins with a key by case insensitive evaluation.  <a href="#ab148bce1cca2922a5f7075caa4ad2123"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#afc5c3258491f0a660ea080ec6a9426d2">strbwm</a> (const char *str, const char *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether a string ends with a key.  <a href="#afc5c3258491f0a660ea080ec6a9426d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a543b8989aae0cc8740ab708491a66ab4">stribwm</a> (const char *str, const char *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether a string ends with a key by case insensitive evaluation.  <a href="#a543b8989aae0cc8740ab708491a66ab4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a2ae6776e020b467da36bebfc8481ec64">xmalloc</a> (size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a region on memory.  <a href="#a2ae6776e020b467da36bebfc8481ec64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a2d98e474ce5ca22a0bfb86dec3ce2f70">xcalloc</a> (size_t nmemb, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a nullified region on memory.  <a href="#a2d98e474ce5ca22a0bfb86dec3ce2f70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#adb2446fa2193a5b106c29ca3b3bcaf22">xrealloc</a> (void *ptr, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Re-allocate a region on memory.  <a href="#adb2446fa2193a5b106c29ca3b3bcaf22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a7c21a6d631ddf3c18d6f06b0f1e13dc0">xfree</a> (void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a region on memory.  <a href="#a7c21a6d631ddf3c18d6f06b0f1e13dc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#ae686b10dc068a87cfff3efbf8210871c">mapalloc</a> (size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a nullified region on mapped memory.  <a href="#ae686b10dc068a87cfff3efbf8210871c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a9a3e6d5e5ebaf38678e7aab5211e4f3c">mapfree</a> (void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a region on mapped memory.  <a href="#a9a3e6d5e5ebaf38678e7aab5211e4f3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a68ae1421d2ad5fbef0fd6bbd95a3d070">time</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the time of day in seconds.  <a href="#a68ae1421d2ad5fbef0fd6bbd95a3d070"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a58f79107311ee1da186b17da369a48f7">getpid</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the process ID.  <a href="#a58f79107311ee1da186b17da369a48f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#ab71699ea209e6d97f0791b05514b0673">getenv</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the value of an environment variable.  <a href="#ab71699ea209e6d97f0791b05514b0673"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a8ec5349bbc201b86bc25d57854f721f4">getsysinfo</a> (std::map&lt; std::string, std::string &gt; *strmap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get system information of the environment.  <a href="#a8ec5349bbc201b86bc25d57854f721f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#aeba9ae5c16e3fd41076f1ae94e04de2d">setstdiobin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the standard streams into the binary mode.  <a href="#aeba9ae5c16e3fd41076f1ae94e04de2d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkyotocabinet_1_1LexicalComparator.html">LexicalComparator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#af7ffd701348e1d8c35cd130b5fb0558a">LEXICALCOMP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepared variable of the comparator in the lexical order.  <a href="#af7ffd701348e1d8c35cd130b5fb0558a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkyotocabinet_1_1DecimalComparator.html">DecimalComparator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a243f1e65d8b0b3af31328b0794fc28b2">DECIMALCOMP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepared variable of the comparator in the decimal order.  <a href="#a243f1e65d8b0b3af31328b0794fc28b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkyotocabinet_1_1ZLIBCompressor.html">ZLIBCompressor</a>&lt; ZLIB::RAW &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#afa0292afc7d1cad8c11664eb7010f2b8">ZLIBRAWCOMP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepared variable of the compressor with <a class="el" href="classkyotocabinet_1_1ZLIB.html" title="ZLIB compressor.">ZLIB</a> raw mode.  <a href="#afa0292afc7d1cad8c11664eb7010f2b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a7855c2c86eeb2a9fc4a6859849cfb6e7">VERSION</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The package version.  <a href="#a7855c2c86eeb2a9fc4a6859849cfb6e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a9c82ab8aff1b5efc9e349a246c9aa596">LIBVER</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The library version.  <a href="#a9c82ab8aff1b5efc9e349a246c9aa596"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a796cda120f959b202d6ccafbae3375dd">LIBREV</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The library revision.  <a href="#a796cda120f959b202d6ccafbae3375dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a6bbcf24f7c6c6e73ea6e5d4d9780e32d">FMTVER</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The database format version.  <a href="#a6bbcf24f7c6c6e73ea6e5d4d9780e32d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a0b0b324b04de971dcfbdf9c468cfe0f1">SYSNAME</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The system name.  <a href="#a0b0b324b04de971dcfbdf9c468cfe0f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#ac05b9fa9306959d9d28d1a1d51bb0a97">BIGEND</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The flag for big endian environments.  <a href="#ac05b9fa9306959d9d28d1a1d51bb0a97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a9fc7eb536d5c574c904a20b58ce112dc">CLOCKTICK</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The clock tick of interruption.  <a href="#a9fc7eb536d5c574c904a20b58ce112dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a7c6ac8fdaf73bbd5790dafceb7e62cea">PAGESIZE</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The size of a page.  <a href="#a7c6ac8fdaf73bbd5790dafceb7e62cea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#ab283c8e794f96c0ae83d32a7c4d4e2ea">FEATURES</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The extra feature list.  <a href="#ab283c8e794f96c0ae83d32a7c4d4e2ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#aa921de5427ce0136d56ed08401f3460e">NUMBUFSIZ</a> = 32</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The buffer size for numeric data.  <a href="#aa921de5427ce0136d56ed08401f3460e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekyotocabinet.html#a1e1dbed942de860fad53047d3c586a5b">MEMMAXSIZ</a> = INT32_MAX / 2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum memory size for debugging.  <a href="#a1e1dbed942de860fad53047d3c586a5b"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>All symbols of Kyoto Cabinet. </p>
<p>Common namespace of Kyoto Cabinet.</p>
<p>Helper functions. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ab08bf5f25c36e8e6b06e7531b047acc7"></a><!-- doxytag: member="kyotocabinet::GrassDB" ref="ab08bf5f25c36e8e6b06e7531b047acc7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classkyotocabinet_1_1PlantDB.html">PlantDB</a>&lt;<a class="el" href="classkyotocabinet_1_1CacheDB.html">CacheDB</a>, BasicDB::TYPEGRASS&gt; <a class="el" href="classkyotocabinet_1_1PlantDB.html">kyotocabinet::GrassDB</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An alias of the cache tree database. </p>

</div>
</div>
<a class="anchor" id="aadca6acd45bcad111229c9f92be7a66b"></a><!-- doxytag: member="kyotocabinet::ForestDB" ref="aadca6acd45bcad111229c9f92be7a66b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classkyotocabinet_1_1PlantDB.html">PlantDB</a>&lt;<a class="el" href="classkyotocabinet_1_1DirDB.html">DirDB</a>, BasicDB::TYPEFOREST&gt; <a class="el" href="classkyotocabinet_1_1PlantDB.html">kyotocabinet::ForestDB</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An alias of the directory tree database. </p>

</div>
</div>
<a class="anchor" id="a58209fa250ad75178ca0379f1034ad5e"></a><!-- doxytag: member="kyotocabinet::TreeDB" ref="a58209fa250ad75178ca0379f1034ad5e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classkyotocabinet_1_1PlantDB.html">PlantDB</a>&lt;<a class="el" href="classkyotocabinet_1_1HashDB.html">HashDB</a>, BasicDB::TYPETREE&gt; <a class="el" href="classkyotocabinet_1_1PlantDB.html">kyotocabinet::TreeDB</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An alias of the file tree database. </p>

</div>
</div>
<a class="anchor" id="a68826fcd903705a08001af0180d713e6"></a><!-- doxytag: member="kyotocabinet::ProtoHashDB" ref="a68826fcd903705a08001af0180d713e6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classkyotocabinet_1_1ProtoDB.html">ProtoDB</a>&lt;<a class="el" href="namespacekyotocabinet.html#aa9afff496b05bb033337d44c1cb55d1b">StringHashMap</a>, BasicDB::TYPEPHASH&gt; <a class="el" href="classkyotocabinet_1_1ProtoDB.html">kyotocabinet::ProtoHashDB</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An alias of the prototype hash database. </p>

</div>
</div>
<a class="anchor" id="a7d8bb1fb74782bff49ec28d486c98801"></a><!-- doxytag: member="kyotocabinet::ProtoTreeDB" ref="a7d8bb1fb74782bff49ec28d486c98801" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classkyotocabinet_1_1ProtoDB.html">ProtoDB</a>&lt;<a class="el" href="namespacekyotocabinet.html#a8c47c7e78c5bebb036bd6d887023a891">StringTreeMap</a>, BasicDB::TYPEPTREE&gt; <a class="el" href="classkyotocabinet_1_1ProtoDB.html">kyotocabinet::ProtoTreeDB</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An alias of the prototype tree database. </p>

</div>
</div>
<a class="anchor" id="aa9afff496b05bb033337d44c1cb55d1b"></a><!-- doxytag: member="kyotocabinet::StringHashMap" ref="aa9afff496b05bb033337d44c1cb55d1b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unordered_map&lt;std::string, std::string&gt; <a class="el" href="namespacekyotocabinet.html#aa9afff496b05bb033337d44c1cb55d1b">kyotocabinet::StringHashMap</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An alias of hash map of strings. </p>

</div>
</div>
<a class="anchor" id="a8c47c7e78c5bebb036bd6d887023a891"></a><!-- doxytag: member="kyotocabinet::StringTreeMap" ref="a8c47c7e78c5bebb036bd6d887023a891" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, std::string&gt; <a class="el" href="namespacekyotocabinet.html#a8c47c7e78c5bebb036bd6d887023a891">kyotocabinet::StringTreeMap</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An alias of tree map of strings. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa5717474fab1f19605adb576a985d158"></a><!-- doxytag: member="kyotocabinet::atoi" ref="aa5717474fab1f19605adb576a985d158" args="(const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t kyotocabinet::atoi </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a decimal string to an integer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the decimal string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the integer. If the string does not contain numeric expression, 0 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a012be7793124f2f8c272e592c5514412"></a><!-- doxytag: member="kyotocabinet::atoix" ref="a012be7793124f2f8c272e592c5514412" args="(const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t kyotocabinet::atoix </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a decimal string with a metric prefix to an integer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the decimal string, which can be trailed by a binary metric prefix. "K", "M", "G", "T", "P", and "E" are supported. They are case-insensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the integer. If the string does not contain numeric expression, 0 is returned. If the integer overflows the domain, INT64_MAX or INT64_MIN is returned according to the sign. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d9165134c70c771e930046d01dd43a1"></a><!-- doxytag: member="kyotocabinet::atoih" ref="a9d9165134c70c771e930046d01dd43a1" args="(const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t kyotocabinet::atoih </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a hexadecimal string to an integer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the hexadecimal string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the integer. If the string does not contain numeric expression, 0 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7eee3ce1842a348a434caebc2487c5a"></a><!-- doxytag: member="kyotocabinet::atof" ref="ab7eee3ce1842a348a434caebc2487c5a" args="(const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double kyotocabinet::atof </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a decimal string to a real number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the decimal string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the real number. If the string does not contain numeric expression, 0.0 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a04b7fe7ba51ef5ea76b95edab3c3862e"></a><!-- doxytag: member="kyotocabinet::hton16" ref="a04b7fe7ba51ef5ea76b95edab3c3862e" args="(uint16_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t kyotocabinet::hton16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize a 16-bit number in the native order into the network byte order. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>the 16-bit number in the native order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number in the network byte order. </dd></dl>

</div>
</div>
<a class="anchor" id="a921daaea526494202f3322922412c537"></a><!-- doxytag: member="kyotocabinet::hton32" ref="a921daaea526494202f3322922412c537" args="(uint32_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t kyotocabinet::hton32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize a 32-bit number in the native order into the network byte order. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>the 32-bit number in the native order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number in the network byte order. </dd></dl>

</div>
</div>
<a class="anchor" id="a95c605fe3f2cc287a5dd58c7ff900858"></a><!-- doxytag: member="kyotocabinet::hton64" ref="a95c605fe3f2cc287a5dd58c7ff900858" args="(uint64_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t kyotocabinet::hton64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize a 64-bit number in the native order into the network byte order. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>the 64-bit number in the native order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number in the network byte order. </dd></dl>

</div>
</div>
<a class="anchor" id="a45d48051f7702c067fbe8e0bd3ee2df9"></a><!-- doxytag: member="kyotocabinet::ntoh16" ref="a45d48051f7702c067fbe8e0bd3ee2df9" args="(uint16_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t kyotocabinet::ntoh16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Denormalize a 16-bit number in the network byte order into the native order. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>the 16-bit number in the network byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the converted number in the native order. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fb2dc6015957212746727c733ef1537"></a><!-- doxytag: member="kyotocabinet::ntoh32" ref="a4fb2dc6015957212746727c733ef1537" args="(uint32_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t kyotocabinet::ntoh32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Denormalize a 32-bit number in the network byte order into the native order. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>the 32-bit number in the network byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the converted number in the native order. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7183e9051e01321afcb6d62ab52da05"></a><!-- doxytag: member="kyotocabinet::ntoh64" ref="ad7183e9051e01321afcb6d62ab52da05" args="(uint64_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t kyotocabinet::ntoh64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Denormalize a 64-bit number in the network byte order into the native order. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>the 64-bit number in the network byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the converted number in the native order. </dd></dl>

</div>
</div>
<a class="anchor" id="a1bfe6b5ec7606ecda2452b64781f5f31"></a><!-- doxytag: member="kyotocabinet::writefixnum" ref="a1bfe6b5ec7606ecda2452b64781f5f31" args="(void *buf, uint64_t num, size_t width)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kyotocabinet::writefixnum </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>width</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a number in fixed length format into a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the desitination buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>the number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>the width. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7f66a6264c9c32a1130eb46097061a8"></a><!-- doxytag: member="kyotocabinet::readfixnum" ref="ad7f66a6264c9c32a1130eb46097061a8" args="(const void *buf, size_t width)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t kyotocabinet::readfixnum </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>width</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a number in fixed length format from a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the source buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>the width. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the read number. </dd></dl>

</div>
</div>
<a class="anchor" id="a03c4e24c499a108d621db0a11d90373a"></a><!-- doxytag: member="kyotocabinet::writevarnum" ref="a03c4e24c499a108d621db0a11d90373a" args="(void *buf, uint64_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t kyotocabinet::writevarnum </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>num</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a number in variable length format into a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the desitination buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>the number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the length of the written region. </dd></dl>

</div>
</div>
<a class="anchor" id="a16132e0ce72cae571f1141fd6ffc1be2"></a><!-- doxytag: member="kyotocabinet::readvarnum" ref="a16132e0ce72cae571f1141fd6ffc1be2" args="(const void *buf, size_t size, uint64_t *np)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t kyotocabinet::readvarnum </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&nbsp;</td>
          <td class="paramname"> <em>np</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a number in variable length format from a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the source buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the size of the source buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>np</em>&nbsp;</td><td>the pointer to the variable into which the read number is assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the length of the read region, or 0 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a13e22f466f762c802b40d350d6348de8"></a><!-- doxytag: member="kyotocabinet::sizevarnum" ref="a13e22f466f762c802b40d350d6348de8" args="(uint64_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t kyotocabinet::sizevarnum </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check the size of variable length format of a number. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size of variable length format. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a5204c2146a15fc10235415c2116a7e"></a><!-- doxytag: member="kyotocabinet::hashmurmur" ref="a0a5204c2146a15fc10235415c2116a7e" args="(const void *buf, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t kyotocabinet::hashmurmur </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the hash value by MurMur hashing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the source buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the size of the source buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the hash value. </dd></dl>

</div>
</div>
<a class="anchor" id="a081b00a7f1052ce0ac40cf231c8308b6"></a><!-- doxytag: member="kyotocabinet::hashfnv" ref="a081b00a7f1052ce0ac40cf231c8308b6" args="(const void *buf, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t kyotocabinet::hashfnv </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the hash value by FNV hashing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the source buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the size of the source buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the hash value. </dd></dl>

</div>
</div>
<a class="anchor" id="a910aece64bb0969898dff3f2ab25c545"></a><!-- doxytag: member="kyotocabinet::hashpath" ref="a910aece64bb0969898dff3f2ab25c545" args="(const void *buf, size_t size, char *obuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t kyotocabinet::hashpath </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>obuf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the hash value suitable for a file name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the source buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the size of the source buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obuf</em>&nbsp;</td><td>the buffer into which the result hash string is written. It must be more than NUMBUFSIZ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the auxiliary hash value. </dd></dl>

</div>
</div>
<a class="anchor" id="a15a184c29c0a15c9a2c5ec284952be94"></a><!-- doxytag: member="kyotocabinet::nearbyprime" ref="a15a184c29c0a15c9a2c5ec284952be94" args="(uint64_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t kyotocabinet::nearbyprime </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a prime number nearby a number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>a natural number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the result number. </dd></dl>

</div>
</div>
<a class="anchor" id="abd08290326188b7ef61352b7e9b50bb3"></a><!-- doxytag: member="kyotocabinet::nan" ref="abd08290326188b7ef61352b7e9b50bb3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double kyotocabinet::nan </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the quiet Not-a-Number value. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the quiet Not-a-Number value. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f586ee148f0a7a508bb4bfac161af96"></a><!-- doxytag: member="kyotocabinet::inf" ref="a9f586ee148f0a7a508bb4bfac161af96" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double kyotocabinet::inf </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the positive infinity value. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the positive infinity value. </dd></dl>

</div>
</div>
<a class="anchor" id="a663493c7e34035c4a2ce51915fdaf4c7"></a><!-- doxytag: member="kyotocabinet::chknan" ref="a663493c7e34035c4a2ce51915fdaf4c7" args="(double num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kyotocabinet::chknan </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check a number is a Not-a-Number value. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true for the number is a Not-a-Number value, or false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="aad77342fb052bbffafc0291d2de7c182"></a><!-- doxytag: member="kyotocabinet::chkinf" ref="aad77342fb052bbffafc0291d2de7c182" args="(double num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kyotocabinet::chkinf </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check a number is an infinity value. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true for the number is an infinity value, or false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a3254622e310d259aa88abc2e615e3901"></a><!-- doxytag: member="kyotocabinet::vstrprintf" ref="a3254622e310d259aa88abc2e615e3901" args="(std::string *dest, const char *format, va_list ap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kyotocabinet::vstrprintf </td>
          <td>(</td>
          <td class="paramtype">std::string *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>ap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a formatted string at the end of a string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>the destination string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>the printf-like format string. The conversion character `' can be used with such flag characters as `s', `d', `o', `u', `x', `X', `c', `e', `E', `f', `g', `G', and `'. `S' treats the pointer to a std::string object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ap</em>&nbsp;</td><td>used according to the format string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f152bed78c4e6a1c0a21ddb8e1ab951"></a><!-- doxytag: member="kyotocabinet::strprintf" ref="a1f152bed78c4e6a1c0a21ddb8e1ab951" args="(std::string *dest, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kyotocabinet::strprintf </td>
          <td>(</td>
          <td class="paramtype">std::string *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a formatted string at the end of a string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>the destination string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>the printf-like format string. The conversion character `' can be used with such flag characters as `s', `d', `o', `u', `x', `X', `c', `e', `E', `f', `g', `G', and `'. `S' treats the pointer to a std::string object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>used according to the format string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a492b51509ee03e32b5e7b72fa3ac2b97"></a><!-- doxytag: member="kyotocabinet::strprintf" ref="a492b51509ee03e32b5e7b72fa3ac2b97" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string kyotocabinet::strprintf </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a formatted string. </p>
<p>Generate a formatted string on memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>the printf-like format string. The conversion character `' can be used with such flag characters as `s', `d', `o', `u', `x', `X', `c', `e', `E', `f', `g', `G', and `'. `S' treats the pointer to a std::string object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>used according to the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the result string. </dd></dl>

</div>
</div>
<a class="anchor" id="a295fcdb0ba9274e2d986a66e1eb189b8"></a><!-- doxytag: member="kyotocabinet::strsplit" ref="a295fcdb0ba9274e2d986a66e1eb189b8" args="(const std::string &amp;str, char delim, std::vector&lt; std::string &gt; *elems)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t kyotocabinet::strsplit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&nbsp;</td>
          <td class="paramname"> <em>elems</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a string with a delimiter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>the delimiter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>elems</em>&nbsp;</td><td>a vector object into which the result elements are pushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of result elements. </dd></dl>

</div>
</div>
<a class="anchor" id="ae70c36738b29ac18f88920ea07b621c9"></a><!-- doxytag: member="kyotocabinet::strsplit" ref="ae70c36738b29ac18f88920ea07b621c9" args="(const std::string &amp;str, const std::string &amp;delims, std::vector&lt; std::string &gt; *elems)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t kyotocabinet::strsplit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>delims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&nbsp;</td>
          <td class="paramname"> <em>elems</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a string with delimiters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delims</em>&nbsp;</td><td>the delimiters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>elems</em>&nbsp;</td><td>a vector object into which the result elements are pushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of result elements. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8be5cf3c65a54efdee6823b8877298b"></a><!-- doxytag: member="kyotocabinet::hexencode" ref="ab8be5cf3c65a54efdee6823b8877298b" args="(const void *buf, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * kyotocabinet::hexencode </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encode a serial object by hexadecimal encoding. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the pointer to the region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the size of the region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the result string. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Because the region of the return value is allocated with the the new[] operator, it should be released with the delete[] operator when it is no longer in use. </dd></dl>

</div>
</div>
<a class="anchor" id="ac456e8436103c1ae54ff34e683228af3"></a><!-- doxytag: member="kyotocabinet::hexdecode" ref="ac456e8436103c1ae54ff34e683228af3" args="(const char *str, size_t *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * kyotocabinet::hexdecode </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>sp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decode a string encoded by hexadecimal encoding. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>specifies the encoded string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sp</em>&nbsp;</td><td>the pointer to the variable into which the size of the region of the return value is assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the region of the result. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string. Because the region of the return value is allocated with the the new[] operator, it should be released with the delete[] operator when it is no longer in use. </dd></dl>

</div>
</div>
<a class="anchor" id="adab2ffa1e9de00c542b87732e9502351"></a><!-- doxytag: member="kyotocabinet::urlencode" ref="adab2ffa1e9de00c542b87732e9502351" args="(const void *buf, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * kyotocabinet::urlencode </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encode a serial object by URL encoding. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the pointer to the region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the size of the region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the result string. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Because the region of the return value is allocated with the the new[] operator, it should be released with the delete[] operator when it is no longer in use. </dd></dl>

</div>
</div>
<a class="anchor" id="adc574a3e7323cf4a3f5a27ed2e8d08a9"></a><!-- doxytag: member="kyotocabinet::urldecode" ref="adc574a3e7323cf4a3f5a27ed2e8d08a9" args="(const char *str, size_t *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * kyotocabinet::urldecode </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>sp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decode a string encoded by URL encoding. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>specifies the encoded string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sp</em>&nbsp;</td><td>the pointer to the variable into which the size of the region of the return value is assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the region of the result. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string. Because the region of the return value is allocated with the the new[] operator, it should be released with the delete[] operator when it is no longer in use. </dd></dl>

</div>
</div>
<a class="anchor" id="ae840cb8f87aedaf6cf0eb8d54f822bba"></a><!-- doxytag: member="kyotocabinet::quoteencode" ref="ae840cb8f87aedaf6cf0eb8d54f822bba" args="(const void *buf, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * kyotocabinet::quoteencode </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encode a serial object by Quoted-printable encoding. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the pointer to the region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the size of the region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the result string. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Because the region of the return value is allocated with the the new[] operator, it should be released with the delete[] operator when it is no longer in use. </dd></dl>

</div>
</div>
<a class="anchor" id="a26d8324a921bdd0d044e27163b9a65f9"></a><!-- doxytag: member="kyotocabinet::quotedecode" ref="a26d8324a921bdd0d044e27163b9a65f9" args="(const char *str, size_t *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * kyotocabinet::quotedecode </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>sp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decode a string encoded by Quoted-printable encoding. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>specifies the encoded string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sp</em>&nbsp;</td><td>the pointer to the variable into which the size of the region of the return value is assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the region of the result. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string. Because the region of the return value is allocated with the the new[] operator, it should be released with the delete[] operator when it is no longer in use. </dd></dl>

</div>
</div>
<a class="anchor" id="a42d22d135cee058108f0c48bbd023391"></a><!-- doxytag: member="kyotocabinet::baseencode" ref="a42d22d135cee058108f0c48bbd023391" args="(const void *buf, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * kyotocabinet::baseencode </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encode a serial object by Base64 encoding. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the pointer to the region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the size of the region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the result string. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Because the region of the return value is allocated with the the new[] operator, it should be released with the delete[] operator when it is no longer in use. </dd></dl>

</div>
</div>
<a class="anchor" id="a8cbe7c5bbb37e28c482cf4cef0ce151a"></a><!-- doxytag: member="kyotocabinet::basedecode" ref="a8cbe7c5bbb37e28c482cf4cef0ce151a" args="(const char *str, size_t *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * kyotocabinet::basedecode </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>sp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decode a string encoded by Base64 encoding. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>specifies the encoded string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sp</em>&nbsp;</td><td>the pointer to the variable into which the size of the region of the return value is assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the region of the result. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string. Because the region of the return value is allocated with the the new[] operator, it should be released with the delete[] operator when it is no longer in use. </dd></dl>

</div>
</div>
<a class="anchor" id="a88eeb6a4d66d8327c65ca26ae6aac9d7"></a><!-- doxytag: member="kyotocabinet::arccipher" ref="a88eeb6a4d66d8327c65ca26ae6aac9d7" args="(const void *ptr, size_t size, const void *kbuf, size_t ksiz, void *obuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kyotocabinet::arccipher </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>kbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ksiz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>obuf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cipher or decipher a serial object with the Arcfour stream cipher. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>the pointer to the region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the size of the region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kbuf</em>&nbsp;</td><td>the pointer to the region of the cipher key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ksiz</em>&nbsp;</td><td>the size of the region of the cipher key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obuf</em>&nbsp;</td><td>the pointer to the region into which the result data is written. The size of the buffer should be equal to or more than the input region. The region can be the same as the source region. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b17149eb5e49f646877e0bf6b573c7a"></a><!-- doxytag: member="kyotocabinet::memdup" ref="a2b17149eb5e49f646877e0bf6b573c7a" args="(const char *ptr, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * kyotocabinet::memdup </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicate a region on memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>the source buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the size of the source buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Because the region of the return value is allocated with the the new[] operator, it should be released with the delete[] operator when it is no longer in use. </dd></dl>

</div>
</div>
<a class="anchor" id="a447ff12b751702fb98a347fad4e5c682"></a><!-- doxytag: member="kyotocabinet::strdup" ref="a447ff12b751702fb98a347fad4e5c682" args="(const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * kyotocabinet::strdup </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicate a string on memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the source string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Because the region of the return value is allocated with the the new[] operator, it should be released with the delete[] operator when it is no longer in use. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3a56f2f62176765b41414e3fef23b83"></a><!-- doxytag: member="kyotocabinet::strtoupper" ref="ac3a56f2f62176765b41414e3fef23b83" args="(char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * kyotocabinet::strtoupper </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert the letters of a string into upper case. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the string itself. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c9f497da0a7ac76efcf4e41385413a2"></a><!-- doxytag: member="kyotocabinet::strtolower" ref="a8c9f497da0a7ac76efcf4e41385413a2" args="(char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * kyotocabinet::strtolower </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert the letters of a string into lower case. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the string itself. </dd></dl>

</div>
</div>
<a class="anchor" id="aa75ce8ab1f4e37dd7cd57be23bf0e194"></a><!-- doxytag: member="kyotocabinet::strtrim" ref="aa75ce8ab1f4e37dd7cd57be23bf0e194" args="(char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * kyotocabinet::strtrim </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cut space characters at head or tail of a string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the string itself. </dd></dl>

</div>
</div>
<a class="anchor" id="aad57c9f970d26f638f8d6953aa966f11"></a><!-- doxytag: member="kyotocabinet::strsqzspc" ref="aad57c9f970d26f638f8d6953aa966f11" args="(char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * kyotocabinet::strsqzspc </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Squeeze space characters in a string and trim it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the string itself. </dd></dl>

</div>
</div>
<a class="anchor" id="a74e08dd57d6b6450074bbaa8e9d9271c"></a><!-- doxytag: member="kyotocabinet::strnrmspc" ref="a74e08dd57d6b6450074bbaa8e9d9271c" args="(char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * kyotocabinet::strnrmspc </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize space characters in a string and trim it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the string itself. </dd></dl>

</div>
</div>
<a class="anchor" id="a1212cff81fe1a20944a240665c319668"></a><!-- doxytag: member="kyotocabinet::stricmp" ref="a1212cff81fe1a20944a240665c319668" args="(const char *astr, const char *bstr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t kyotocabinet::stricmp </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>astr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>bstr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two strings with case insensitive evaluation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>astr</em>&nbsp;</td><td>a string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bstr</em>&nbsp;</td><td>the other string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>positive if the former is big, negative if the latter is big, 0 if both are equivalent. </dd></dl>

</div>
</div>
<a class="anchor" id="ad79bd82ec5cc9ddbf34f9ab414cf95c7"></a><!-- doxytag: member="kyotocabinet::strfwm" ref="ad79bd82ec5cc9ddbf34f9ab414cf95c7" args="(const char *str, const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kyotocabinet::strfwm </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether a string begins with a key. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the forward matching key string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the target string begins with the key, else, it is false. </dd></dl>

</div>
</div>
<a class="anchor" id="ab148bce1cca2922a5f7075caa4ad2123"></a><!-- doxytag: member="kyotocabinet::strifwm" ref="ab148bce1cca2922a5f7075caa4ad2123" args="(const char *str, const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kyotocabinet::strifwm </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether a string begins with a key by case insensitive evaluation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the forward matching key string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the target string begins with the key, else, it is false. </dd></dl>

</div>
</div>
<a class="anchor" id="afc5c3258491f0a660ea080ec6a9426d2"></a><!-- doxytag: member="kyotocabinet::strbwm" ref="afc5c3258491f0a660ea080ec6a9426d2" args="(const char *str, const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kyotocabinet::strbwm </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether a string ends with a key. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the backward matching key string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the target string ends with the key, else, it is false. </dd></dl>

</div>
</div>
<a class="anchor" id="a543b8989aae0cc8740ab708491a66ab4"></a><!-- doxytag: member="kyotocabinet::stribwm" ref="a543b8989aae0cc8740ab708491a66ab4" args="(const char *str, const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kyotocabinet::stribwm </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether a string ends with a key by case insensitive evaluation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the backward matching key string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the target string ends with the key, else, it is false. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ae6776e020b467da36bebfc8481ec64"></a><!-- doxytag: member="kyotocabinet::xmalloc" ref="a2ae6776e020b467da36bebfc8481ec64" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * kyotocabinet::xmalloc </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a region on memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the size of the region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the allocated region. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d98e474ce5ca22a0bfb86dec3ce2f70"></a><!-- doxytag: member="kyotocabinet::xcalloc" ref="a2d98e474ce5ca22a0bfb86dec3ce2f70" args="(size_t nmemb, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * kyotocabinet::xcalloc </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a nullified region on memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nmemb</em>&nbsp;</td><td>the number of elements. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the size of each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the allocated region. </dd></dl>

</div>
</div>
<a class="anchor" id="adb2446fa2193a5b106c29ca3b3bcaf22"></a><!-- doxytag: member="kyotocabinet::xrealloc" ref="adb2446fa2193a5b106c29ca3b3bcaf22" args="(void *ptr, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * kyotocabinet::xrealloc </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Re-allocate a region on memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>the pointer to the region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the size of the region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the re-allocated region. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c21a6d631ddf3c18d6f06b0f1e13dc0"></a><!-- doxytag: member="kyotocabinet::xfree" ref="a7c21a6d631ddf3c18d6f06b0f1e13dc0" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kyotocabinet::xfree </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a region on memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>the pointer to the region. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae686b10dc068a87cfff3efbf8210871c"></a><!-- doxytag: member="kyotocabinet::mapalloc" ref="ae686b10dc068a87cfff3efbf8210871c" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* kyotocabinet::mapalloc </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a nullified region on mapped memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the size of the region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the allocated region. It should be released with the memfree call. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a3e6d5e5ebaf38678e7aab5211e4f3c"></a><!-- doxytag: member="kyotocabinet::mapfree" ref="a9a3e6d5e5ebaf38678e7aab5211e4f3c" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kyotocabinet::mapfree </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a region on mapped memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>the pointer to the allocated region. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68ae1421d2ad5fbef0fd6bbd95a3d070"></a><!-- doxytag: member="kyotocabinet::time" ref="a68ae1421d2ad5fbef0fd6bbd95a3d070" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double kyotocabinet::time </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the time of day in seconds. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the time of day in seconds. The accuracy is in microseconds. </dd></dl>

</div>
</div>
<a class="anchor" id="a58f79107311ee1da186b17da369a48f7"></a><!-- doxytag: member="kyotocabinet::getpid" ref="a58f79107311ee1da186b17da369a48f7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t kyotocabinet::getpid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the process ID. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the process ID. </dd></dl>

</div>
</div>
<a class="anchor" id="ab71699ea209e6d97f0791b05514b0673"></a><!-- doxytag: member="kyotocabinet::getenv" ref="ab71699ea209e6d97f0791b05514b0673" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* kyotocabinet::getenv </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the value of an environment variable. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value of the environment variable, or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ec5349bbc201b86bc25d57854f721f4"></a><!-- doxytag: member="kyotocabinet::getsysinfo" ref="a8ec5349bbc201b86bc25d57854f721f4" args="(std::map&lt; std::string, std::string &gt; *strmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kyotocabinet::getsysinfo </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, std::string &gt; *&nbsp;</td>
          <td class="paramname"> <em>strmap</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get system information of the environment. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strmap</em>&nbsp;</td><td>a string map to contain the result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeba9ae5c16e3fd41076f1ae94e04de2d"></a><!-- doxytag: member="kyotocabinet::setstdiobin" ref="aeba9ae5c16e3fd41076f1ae94e04de2d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kyotocabinet::setstdiobin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the standard streams into the binary mode. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="af7ffd701348e1d8c35cd130b5fb0558a"></a><!-- doxytag: member="kyotocabinet::LEXICALCOMP" ref="af7ffd701348e1d8c35cd130b5fb0558a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkyotocabinet_1_1LexicalComparator.html">LexicalComparator</a> <a class="el" href="namespacekyotocabinet.html#af7ffd701348e1d8c35cd130b5fb0558a">kyotocabinet::LEXICALCOMP</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepared variable of the comparator in the lexical order. </p>

</div>
</div>
<a class="anchor" id="a243f1e65d8b0b3af31328b0794fc28b2"></a><!-- doxytag: member="kyotocabinet::DECIMALCOMP" ref="a243f1e65d8b0b3af31328b0794fc28b2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkyotocabinet_1_1DecimalComparator.html">DecimalComparator</a> <a class="el" href="namespacekyotocabinet.html#a243f1e65d8b0b3af31328b0794fc28b2">kyotocabinet::DECIMALCOMP</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepared variable of the comparator in the decimal order. </p>

</div>
</div>
<a class="anchor" id="afa0292afc7d1cad8c11664eb7010f2b8"></a><!-- doxytag: member="kyotocabinet::ZLIBRAWCOMP" ref="afa0292afc7d1cad8c11664eb7010f2b8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkyotocabinet_1_1ZLIBCompressor.html">ZLIBCompressor</a>&lt;ZLIB::RAW&gt; <a class="el" href="namespacekyotocabinet.html#afa0292afc7d1cad8c11664eb7010f2b8">kyotocabinet::ZLIBRAWCOMP</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepared variable of the compressor with <a class="el" href="classkyotocabinet_1_1ZLIB.html" title="ZLIB compressor.">ZLIB</a> raw mode. </p>

</div>
</div>
<a class="anchor" id="a7855c2c86eeb2a9fc4a6859849cfb6e7"></a><!-- doxytag: member="kyotocabinet::VERSION" ref="a7855c2c86eeb2a9fc4a6859849cfb6e7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const <a class="el" href="namespacekyotocabinet.html#a7855c2c86eeb2a9fc4a6859849cfb6e7">kyotocabinet::VERSION</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The package version. </p>

</div>
</div>
<a class="anchor" id="a9c82ab8aff1b5efc9e349a246c9aa596"></a><!-- doxytag: member="kyotocabinet::LIBVER" ref="a9c82ab8aff1b5efc9e349a246c9aa596" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="namespacekyotocabinet.html#a9c82ab8aff1b5efc9e349a246c9aa596">kyotocabinet::LIBVER</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The library version. </p>

</div>
</div>
<a class="anchor" id="a796cda120f959b202d6ccafbae3375dd"></a><!-- doxytag: member="kyotocabinet::LIBREV" ref="a796cda120f959b202d6ccafbae3375dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="namespacekyotocabinet.html#a796cda120f959b202d6ccafbae3375dd">kyotocabinet::LIBREV</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The library revision. </p>

</div>
</div>
<a class="anchor" id="a6bbcf24f7c6c6e73ea6e5d4d9780e32d"></a><!-- doxytag: member="kyotocabinet::FMTVER" ref="a6bbcf24f7c6c6e73ea6e5d4d9780e32d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="namespacekyotocabinet.html#a6bbcf24f7c6c6e73ea6e5d4d9780e32d">kyotocabinet::FMTVER</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The database format version. </p>

</div>
</div>
<a class="anchor" id="a0b0b324b04de971dcfbdf9c468cfe0f1"></a><!-- doxytag: member="kyotocabinet::SYSNAME" ref="a0b0b324b04de971dcfbdf9c468cfe0f1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="namespacekyotocabinet.html#a0b0b324b04de971dcfbdf9c468cfe0f1">kyotocabinet::SYSNAME</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The system name. </p>

</div>
</div>
<a class="anchor" id="ac05b9fa9306959d9d28d1a1d51bb0a97"></a><!-- doxytag: member="kyotocabinet::BIGEND" ref="ac05b9fa9306959d9d28d1a1d51bb0a97" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="namespacekyotocabinet.html#ac05b9fa9306959d9d28d1a1d51bb0a97">kyotocabinet::BIGEND</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The flag for big endian environments. </p>

</div>
</div>
<a class="anchor" id="a9fc7eb536d5c574c904a20b58ce112dc"></a><!-- doxytag: member="kyotocabinet::CLOCKTICK" ref="a9fc7eb536d5c574c904a20b58ce112dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="namespacekyotocabinet.html#a9fc7eb536d5c574c904a20b58ce112dc">kyotocabinet::CLOCKTICK</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The clock tick of interruption. </p>

</div>
</div>
<a class="anchor" id="a7c6ac8fdaf73bbd5790dafceb7e62cea"></a><!-- doxytag: member="kyotocabinet::PAGESIZE" ref="a7c6ac8fdaf73bbd5790dafceb7e62cea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="namespacekyotocabinet.html#a7c6ac8fdaf73bbd5790dafceb7e62cea">kyotocabinet::PAGESIZE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size of a page. </p>

</div>
</div>
<a class="anchor" id="ab283c8e794f96c0ae83d32a7c4d4e2ea"></a><!-- doxytag: member="kyotocabinet::FEATURES" ref="ab283c8e794f96c0ae83d32a7c4d4e2ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const <a class="el" href="namespacekyotocabinet.html#ab283c8e794f96c0ae83d32a7c4d4e2ea">kyotocabinet::FEATURES</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The extra feature list. </p>

</div>
</div>
<a class="anchor" id="aa921de5427ce0136d56ed08401f3460e"></a><!-- doxytag: member="kyotocabinet::NUMBUFSIZ" ref="aa921de5427ce0136d56ed08401f3460e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="namespacekyotocabinet.html#aa921de5427ce0136d56ed08401f3460e">kyotocabinet::NUMBUFSIZ</a> = 32</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The buffer size for numeric data. </p>

</div>
</div>
<a class="anchor" id="a1e1dbed942de860fad53047d3c586a5b"></a><!-- doxytag: member="kyotocabinet::MEMMAXSIZ" ref="a1e1dbed942de860fad53047d3c586a5b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="namespacekyotocabinet.html#a1e1dbed942de860fad53047d3c586a5b">kyotocabinet::MEMMAXSIZ</a> = INT32_MAX / 2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum memory size for debugging. </p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Nov 10 12:49:50 2010 for Kyoto Cabinet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
