<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Kyoto Cabinet: Python 2.x Binding of Kyoto Cabinet</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Python 2.x Binding of Kyoto Cabinet </h1><h2><a class="anchor" id="Introduction">
Introduction</a></h2>
<p>Kyoto Cabinet is a library of routines for managing a database. The database is a simple data file containing records, each is a pair of a key and a value. Every key and value is serial bytes with variable length. Both binary data and character string can be used as a key and a value. Each key must be unique within a database. There is neither concept of data tables nor data types. Records are organized in hash table or B+ tree.</p>
<p>The following access methods are provided to the database: storing a record with a key and a value, deleting a record by a key, retrieving a record by a key. Moreover, traversal access to every key are provided. These access methods are similar to ones of the original DBM (and its followers: NDBM and GDBM) library defined in the UNIX standard. Kyoto Cabinet is an alternative for the DBM because of its higher performance.</p>
<p>Each operation of the hash database has the time complexity of "O(1)". Therefore, in theory, the performance is constant regardless of the scale of the database. In practice, the performance is determined by the speed of the main memory or the storage device. If the size of the database is less than the capacity of the main memory, the performance will seem on-memory speed, which is faster than std::map of STL. Of course, the database size can be greater than the capacity of the main memory and the upper limit is 8 exabytes. Even in that case, each operation needs only one or two seeking of the storage device.</p>
<p>Each operation of the B+ tree database has the time complexity of "O(log N)". Therefore, in theory, the performance is logarithmic to the scale of the database. Although the performance of random access of the B+ tree database is slower than that of the hash database, the B+ tree database supports sequential access in order of the keys, which realizes forward matching search for strings and range search for integers. The performance of sequential access is much faster than that of random access.</p>
<p>This library wraps the polymorphic database of the C++ API. So, you can select the internal data structure by specifying the database name in runtime. This library works on Python 2.x (2.6 or later) only. Python 3.x requires another dedicated package.</p>
<h2><a class="anchor" id="Installation">
Installation</a></h2>
<p>Install the latest version of Kyoto Cabinet beforehand and get the package of the Python binding of Kyoto Cabinet.</p>
<p>Enter the directory of the extracted package then perform installation.</p>
<div class="fragment"><pre class="fragment">
make
make check
su
make install
</pre></div><p>Symbols of the module `kyotocabinet' should be included in each source file of application programs.</p>
<div class="fragment"><pre class="fragment">
import kyotocabinet
</pre></div><p>An instance of the class `DB' is used in order to handle a database. You can store, delete, and retrieve records with the instance.</p>
<h2><a class="anchor" id="Example">
Example</a></h2>
<p>The following code is a typical example to use a database.</p>
<div class="fragment"><pre class="fragment">
from kyotocabinet import *
import sys

# create the database object
db = DB()

# open the database
if not db.open("casket.kch", DB.OWRITER | DB.OCREATE):
    print &gt;&gt;sys.stderr, "open error: " + str(db.error())

# store records
if not db.set("foo", "hop") or \
        not db.set("bar", "step") or \
        not db.set("baz", "jump"):
    print &gt;&gt;sys.stderr, "set error: " + str(db.error())

# retrieve records
value = db.get("foo")
if value:
    print value
else:
    print &gt;&gt;sys.stderr, "get error: " + str(db.error())

# traverse records
cur = db.cursor()
cur.jump()
while True:
    rec = cur.get(True)
    if not rec: break
    print rec[0] + ":" + rec[1]
cur.disable()

# close the database
if not db.close():
    print &gt;&gt;sys.stderr, "close error: " + str(db.error())
</pre></div><p>The following code is a more complex example, which uses the Visitor pattern.</p>
<div class="fragment"><pre class="fragment">
from kyotocabinet import *
import sys

# create the database object
db = DB()

# open the database
if not db.open("casket.kch", DB.OREADER):
    print &gt;&gt;sys.stderr, "open error: " + str(db.error())

# define the visitor
class VisitorImpl(Visitor):
    # call back function for an existing record
    def visit_full(self, key, value):
        print "%s:%s" % (key, value)
        return self.NOP
    # call back function for an empty record space
    def visit_empty(self, key):
        print &gt;&gt;sys.stderr, "%s is missing" % key
        return self.NOP
visitor = VisitorImpl()

# retrieve a record with visitor
if not db.accept("foo", visitor, False) or \
        not db.accept("dummy", visitor, False):
    print &gt;&gt;sys.stderr, "accept error: " + str(db.error())

# traverse records with visitor
if not db.iterate(visitor, False):
    print &gt;&gt;sys.stderr, "iterate error: " + str(db.error())

# close the database
if not db.close():
    print &gt;&gt;sys.stderr, "close error: " + str(db.error())
</pre></div><p>The following code is also a complex example, which is more suited to the Ruby style.</p>
<div class="fragment"><pre class="fragment">
from kyotocabinet import *
import sys

# define the functor
def dbproc(db):

  # store records
  db['foo'] = b'step';   # string is fundamental
  db[u'bar'] = 'hop';    # unicode is also ok
  db[3] = 'jump';        # number is also ok

  # retrieve a record value
  print db['foo']

  # update records in transaction
  def tranproc():
      db['foo'] = 2.71828
      return True
  db.transaction(tranproc)

  # multiply a record value
  def mulproc(key, value):
      return float(value) * 2
  db.accept('foo', mulproc)

  # traverse records by iterator
  for key in db:
      print "%s:%s" % (key, db[key])

  # upcase values by iterator
  def upproc(key, value):
      return value.upper()
  db.iterate(upproc)

  # traverse records by cursor
  def curproc(cur):
      cur.jump()
      def printproc(key, value):
          print "%s:%s" % (key, value)
          return Visitor.NOP
      while cur.accept(printproc):
          cur.step()
  db.cursor_process(curproc)

# process the database by the functor
DB.process(dbproc, 'casket.kch')
</pre></div><h2><a class="anchor" id="LICENSE">
LICENSE</a></h2>
<div class="fragment"><pre class="fragment">
Copyright (C) 2009-2010 FAL Labs
All rights reserved.
</pre></div><p>Kyoto Cabinet is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>Kyoto Cabinet is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. </p>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Nov 10 14:48:56 2010 for Kyoto Cabinet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
